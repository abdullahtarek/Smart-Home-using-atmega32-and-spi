
Rtos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003358  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000042  00800060  00003358  000033ec  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000003d3  008000a2  008000a2  0000342e  2**0
                  ALLOC
  3 .stab         00001428  00000000  00000000  00003430  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000051b  00000000  00000000  00004858  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000200  00000000  00000000  00004d78  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004196  00000000  00000000  00004f78  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000010b7  00000000  00000000  0000910e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001ae0  00000000  00000000  0000a1c5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000df0  00000000  00000000  0000bca8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000171c  00000000  00000000  0000ca98  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004532  00000000  00000000  0000e1b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001c8  00000000  00000000  000126e6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 ee 06 	jmp	0xddc	; 0xddc <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 1f 0e 	jmp	0x1c3e	; 0x1c3e <__vector_10>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e5       	ldi	r30, 0x58	; 88
      68:	f3 e3       	ldi	r31, 0x33	; 51
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a2 3a       	cpi	r26, 0xA2	; 162
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	a2 ea       	ldi	r26, 0xA2	; 162
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 37       	cpi	r26, 0x75	; 117
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <main>
      8a:	0c 94 aa 19 	jmp	0x3354	; 0x3354 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <ADC_vinit>:


void ADC_vinit()
{
	// 5v vref
	ADMUX |=(1<<REFS0);
      92:	3e 9a       	sbi	0x07, 6	; 7
	ADMUX &= (~(1<<REFS1));
      94:	3f 98       	cbi	0x07, 7	; 7
	
	//port number |= (1<<0);
	
	ADCSRA |=(1<<ADEN); // Enable ADC
      96:	37 9a       	sbi	0x06, 7	; 6
	
	// devide by 64
	ADCSRA |=(1<<ADPS2);
      98:	32 9a       	sbi	0x06, 2	; 6
	ADCSRA |=(1<<ADPS1);
      9a:	31 9a       	sbi	0x06, 1	; 6
	ADCSRA &= (~(1<<ADPS0));
      9c:	30 98       	cbi	0x06, 0	; 6
	
	sei();
      9e:	78 94       	sei
	
	ADCSRA |= (1<<ADIE);//Enable interrupts
      a0:	33 9a       	sbi	0x06, 3	; 6
	
}
      a2:	08 95       	ret

000000a4 <ADC_u16convert>:

void ADC_u16convert()
{
	ADCSRA |= (1<<ADSC);
      a4:	36 9a       	sbi	0x06, 6	; 6
	
	unsigned short ret = (ADCL) | (ADCH<<8)  ;
	
	
	return ret;*/
}
      a6:	08 95       	ret

000000a8 <write_eeprom>:
 *  Author: Abdullah
 */ 
#include <avr/io.h>
void write_eeprom(short address , char data)
{
	while(((EECR& (1<<EEWE))>>EEWE)==1)
      a8:	e1 99       	sbic	0x1c, 1	; 28
      aa:	fe cf       	rjmp	.-4      	; 0xa8 <write_eeprom>
	{
		/*wait until EEPROM IS FREE */
	}
	
	//adrress of the EEPROM and because it is 1024 is 12 bits so to chars one high and one low
	EEARL = (char)address;
      ac:	8e bb       	out	0x1e, r24	; 30
	EEARH= (char)(address>>8);
      ae:	89 2f       	mov	r24, r25
      b0:	99 0f       	add	r25, r25
      b2:	99 0b       	sbc	r25, r25
      b4:	8f bb       	out	0x1f, r24	; 31
	//Set data
	EEDR = data;
      b6:	6d bb       	out	0x1d, r22	; 29
	//set master
	EECR |= (1<<EEMWE);
      b8:	e2 9a       	sbi	0x1c, 2	; 28
	//set write enable
	EECR |= (1<<EEWE);
      ba:	e1 9a       	sbi	0x1c, 1	; 28
}
      bc:	08 95       	ret

000000be <read_eeprom>:
char read_eeprom(short address)
{
	while( ((EECR & (1<<EEWE))>>EEWE) ==1)
      be:	e1 99       	sbic	0x1c, 1	; 28
      c0:	fe cf       	rjmp	.-4      	; 0xbe <read_eeprom>
	{
		//wiat until EEPROM is free	
	}
	
	//adress
	EEARL = (char)address;
      c2:	8e bb       	out	0x1e, r24	; 30
	EEARH= (char)(address>>8);
      c4:	89 2f       	mov	r24, r25
      c6:	99 0f       	add	r25, r25
      c8:	99 0b       	sbc	r25, r25
      ca:	8f bb       	out	0x1f, r24	; 31
	//
	EECR |= (1<<EERE);
      cc:	e0 9a       	sbi	0x1c, 0	; 28
	
	return EEDR;	
      ce:	8d b3       	in	r24, 0x1d	; 29
      d0:	08 95       	ret

000000d2 <prvTestWaitCondition>:

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
      d2:	44 23       	and	r20, r20
      d4:	41 f4       	brne	.+16     	; 0xe6 <prvTestWaitCondition+0x14>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
      d6:	68 23       	and	r22, r24
      d8:	79 23       	and	r23, r25
		{
			xWaitConditionMet = pdTRUE;
      da:	81 e0       	ldi	r24, 0x01	; 1
      dc:	61 15       	cp	r22, r1
      de:	71 05       	cpc	r23, r1
      e0:	51 f4       	brne	.+20     	; 0xf6 <prvTestWaitCondition+0x24>
      e2:	80 e0       	ldi	r24, 0x00	; 0
      e4:	08 95       	ret
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
      e6:	9b 01       	movw	r18, r22
      e8:	28 23       	and	r18, r24
      ea:	39 23       	and	r19, r25
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
		{
			xWaitConditionMet = pdTRUE;
      ec:	81 e0       	ldi	r24, 0x01	; 1
      ee:	62 17       	cp	r22, r18
      f0:	73 07       	cpc	r23, r19
      f2:	09 f0       	breq	.+2      	; 0xf6 <prvTestWaitCondition+0x24>
      f4:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
}
      f6:	08 95       	ret

000000f8 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
      f8:	cf 93       	push	r28
      fa:	df 93       	push	r29
	EventGroup_t *pxEventBits;

		/* Allocate the event group. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
      fc:	8b e0       	ldi	r24, 0x0B	; 11
      fe:	90 e0       	ldi	r25, 0x00	; 0
     100:	0e 94 12 02 	call	0x424	; 0x424 <pvPortMalloc>
     104:	ec 01       	movw	r28, r24

		if( pxEventBits != NULL )
     106:	00 97       	sbiw	r24, 0x00	; 0
     108:	31 f0       	breq	.+12     	; 0x116 <xEventGroupCreate+0x1e>
		{
			pxEventBits->uxEventBits = 0;
     10a:	fc 01       	movw	r30, r24
     10c:	11 92       	st	Z+, r1
     10e:	11 92       	st	Z+, r1
     110:	cf 01       	movw	r24, r30
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     112:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListInitialise>
		{
			traceEVENT_GROUP_CREATE_FAILED();
		}

		return ( EventGroupHandle_t ) pxEventBits;
	}
     116:	8c 2f       	mov	r24, r28
     118:	9d 2f       	mov	r25, r29
     11a:	df 91       	pop	r29
     11c:	cf 91       	pop	r28
     11e:	08 95       	ret

00000120 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     120:	af 92       	push	r10
     122:	bf 92       	push	r11
     124:	cf 92       	push	r12
     126:	df 92       	push	r13
     128:	ef 92       	push	r14
     12a:	ff 92       	push	r15
     12c:	0f 93       	push	r16
     12e:	1f 93       	push	r17
     130:	cf 93       	push	r28
     132:	df 93       	push	r29
     134:	5c 01       	movw	r10, r24
     136:	6b 01       	movw	r12, r22
     138:	e4 2e       	mov	r14, r20
     13a:	f2 2e       	mov	r15, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     13c:	0e 94 1c 12 	call	0x2438	; 0x2438 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     140:	f5 01       	movw	r30, r10
     142:	c0 81       	ld	r28, Z
     144:	d1 81       	ldd	r29, Z+1	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     146:	ce 01       	movw	r24, r28
     148:	b6 01       	movw	r22, r12
     14a:	4f 2d       	mov	r20, r15
     14c:	0e 94 69 00 	call	0xd2	; 0xd2 <prvTestWaitCondition>

		if( xWaitConditionMet != pdFALSE )
     150:	88 23       	and	r24, r24
     152:	51 f0       	breq	.+20     	; 0x168 <xEventGroupWaitBits+0x48>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     154:	ee 20       	and	r14, r14
     156:	01 f1       	breq	.+64     	; 0x198 <xEventGroupWaitBits+0x78>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     158:	c0 94       	com	r12
     15a:	d0 94       	com	r13
     15c:	cc 22       	and	r12, r28
     15e:	dd 22       	and	r13, r29
     160:	f5 01       	movw	r30, r10
     162:	d1 82       	std	Z+1, r13	; 0x01
     164:	c0 82       	st	Z, r12
     166:	18 c0       	rjmp	.+48     	; 0x198 <xEventGroupWaitBits+0x78>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     168:	01 15       	cp	r16, r1
     16a:	11 05       	cpc	r17, r1
     16c:	a9 f0       	breq	.+42     	; 0x198 <xEventGroupWaitBits+0x78>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     16e:	ee 20       	and	r14, r14
     170:	19 f4       	brne	.+6      	; 0x178 <xEventGroupWaitBits+0x58>
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
     172:	60 e0       	ldi	r22, 0x00	; 0
     174:	70 e0       	ldi	r23, 0x00	; 0
     176:	02 c0       	rjmp	.+4      	; 0x17c <xEventGroupWaitBits+0x5c>
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     178:	60 e0       	ldi	r22, 0x00	; 0
     17a:	71 e0       	ldi	r23, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     17c:	f1 10       	cpse	r15, r1
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     17e:	74 60       	ori	r23, 0x04	; 4
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     180:	6c 29       	or	r22, r12
     182:	7d 29       	or	r23, r13
     184:	c5 01       	movw	r24, r10
     186:	02 96       	adiw	r24, 0x02	; 2
     188:	a8 01       	movw	r20, r16
     18a:	0e 94 a9 14 	call	0x2952	; 0x2952 <vTaskPlaceOnUnorderedEventList>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     18e:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
     192:	88 23       	and	r24, r24
     194:	39 f4       	brne	.+14     	; 0x1a4 <xEventGroupWaitBits+0x84>
     196:	04 c0       	rjmp	.+8      	; 0x1a0 <xEventGroupWaitBits+0x80>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     198:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskResumeAll>
     19c:	ce 01       	movw	r24, r28
     19e:	21 c0       	rjmp	.+66     	; 0x1e2 <xEventGroupWaitBits+0xc2>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     1a0:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     1a4:	0e 94 2f 16 	call	0x2c5e	; 0x2c5e <uxTaskResetEventItemValue>
     1a8:	ec 01       	movw	r28, r24

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     1aa:	91 fd       	sbrc	r25, 1
     1ac:	18 c0       	rjmp	.+48     	; 0x1de <xEventGroupWaitBits+0xbe>
		{
			taskENTER_CRITICAL();
     1ae:	0f b6       	in	r0, 0x3f	; 63
     1b0:	f8 94       	cli
     1b2:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     1b4:	f5 01       	movw	r30, r10
     1b6:	c0 81       	ld	r28, Z
     1b8:	d1 81       	ldd	r29, Z+1	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     1ba:	ce 01       	movw	r24, r28
     1bc:	b6 01       	movw	r22, r12
     1be:	4f 2d       	mov	r20, r15
     1c0:	0e 94 69 00 	call	0xd2	; 0xd2 <prvTestWaitCondition>
     1c4:	88 23       	and	r24, r24
     1c6:	49 f0       	breq	.+18     	; 0x1da <xEventGroupWaitBits+0xba>
				{
					if( xClearOnExit != pdFALSE )
     1c8:	ee 20       	and	r14, r14
     1ca:	39 f0       	breq	.+14     	; 0x1da <xEventGroupWaitBits+0xba>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     1cc:	c0 94       	com	r12
     1ce:	d0 94       	com	r13
     1d0:	cc 22       	and	r12, r28
     1d2:	dd 22       	and	r13, r29
     1d4:	f5 01       	movw	r30, r10
     1d6:	d1 82       	std	Z+1, r13	; 0x01
     1d8:	c0 82       	st	Z, r12
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     1da:	0f 90       	pop	r0
     1dc:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     1de:	ce 01       	movw	r24, r28
     1e0:	90 70       	andi	r25, 0x00	; 0
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     1e2:	df 91       	pop	r29
     1e4:	cf 91       	pop	r28
     1e6:	1f 91       	pop	r17
     1e8:	0f 91       	pop	r16
     1ea:	ff 90       	pop	r15
     1ec:	ef 90       	pop	r14
     1ee:	df 90       	pop	r13
     1f0:	cf 90       	pop	r12
     1f2:	bf 90       	pop	r11
     1f4:	af 90       	pop	r10
     1f6:	08 95       	ret

000001f8 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     1f8:	fc 01       	movw	r30, r24
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     1fa:	0f b6       	in	r0, 0x3f	; 63
     1fc:	f8 94       	cli
     1fe:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     200:	80 81       	ld	r24, Z
     202:	91 81       	ldd	r25, Z+1	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     204:	60 95       	com	r22
     206:	70 95       	com	r23
     208:	68 23       	and	r22, r24
     20a:	79 23       	and	r23, r25
     20c:	71 83       	std	Z+1, r23	; 0x01
     20e:	60 83       	st	Z, r22
	}
	taskEXIT_CRITICAL();
     210:	0f 90       	pop	r0
     212:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     214:	08 95       	ret

00000216 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     216:	fc 01       	movw	r30, r24
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
     218:	80 81       	ld	r24, Z
     21a:	91 81       	ldd	r25, Z+1	; 0x01
     21c:	08 95       	ret

0000021e <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     21e:	af 92       	push	r10
     220:	bf 92       	push	r11
     222:	cf 92       	push	r12
     224:	df 92       	push	r13
     226:	ef 92       	push	r14
     228:	ff 92       	push	r15
     22a:	0f 93       	push	r16
     22c:	1f 93       	push	r17
     22e:	cf 93       	push	r28
     230:	df 93       	push	r29
     232:	8c 01       	movw	r16, r24
     234:	eb 01       	movw	r28, r22
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     236:	0f 2e       	mov	r0, r31
     238:	f5 e0       	ldi	r31, 0x05	; 5
     23a:	cf 2e       	mov	r12, r31
     23c:	dd 24       	eor	r13, r13
     23e:	f0 2d       	mov	r31, r0
     240:	c8 0e       	add	r12, r24
     242:	d9 1e       	adc	r13, r25
	vTaskSuspendAll();
     244:	0e 94 1c 12 	call	0x2438	; 0x2438 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     248:	d8 01       	movw	r26, r16
     24a:	17 96       	adiw	r26, 0x07	; 7
     24c:	ed 91       	ld	r30, X+
     24e:	fc 91       	ld	r31, X
     250:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     252:	8d 91       	ld	r24, X+
     254:	9c 91       	ld	r25, X
     256:	11 97       	sbiw	r26, 0x01	; 1
     258:	8c 2b       	or	r24, r28
     25a:	9d 2b       	or	r25, r29
     25c:	11 96       	adiw	r26, 0x01	; 1
     25e:	9c 93       	st	X, r25
     260:	8e 93       	st	-X, r24

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     262:	ce 16       	cp	r12, r30
     264:	df 06       	cpc	r13, r31
     266:	c1 f1       	breq	.+112    	; 0x2d8 <xEventGroupSetBits+0xba>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     268:	aa 24       	eor	r10, r10
     26a:	bb 24       	eor	r11, r11
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     26c:	ff 24       	eor	r15, r15
     26e:	f3 94       	inc	r15
     270:	ee 24       	eor	r14, r14
     272:	01 c0       	rjmp	.+2      	; 0x276 <xEventGroupSetBits+0x58>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     274:	fe 01       	movw	r30, r28
		{
			pxNext = listGET_NEXT( pxListItem );
     276:	c2 81       	ldd	r28, Z+2	; 0x02
     278:	d3 81       	ldd	r29, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     27a:	80 81       	ld	r24, Z
     27c:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     27e:	bc 01       	movw	r22, r24
     280:	60 70       	andi	r22, 0x00	; 0
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     282:	9c 01       	movw	r18, r24
     284:	30 70       	andi	r19, 0x00	; 0

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     286:	92 fd       	sbrc	r25, 2
     288:	0b c0       	rjmp	.+22     	; 0x2a0 <xEventGroupSetBits+0x82>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     28a:	d8 01       	movw	r26, r16
     28c:	8d 91       	ld	r24, X+
     28e:	9c 91       	ld	r25, X
     290:	11 97       	sbiw	r26, 0x01	; 1
     292:	82 23       	and	r24, r18
     294:	93 23       	and	r25, r19
				{
					xMatchFound = pdTRUE;
     296:	4f 2d       	mov	r20, r15
     298:	00 97       	sbiw	r24, 0x00	; 0
     29a:	69 f4       	brne	.+26     	; 0x2b6 <xEventGroupSetBits+0x98>
     29c:	4e 2d       	mov	r20, r14
     29e:	0b c0       	rjmp	.+22     	; 0x2b6 <xEventGroupSetBits+0x98>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     2a0:	d8 01       	movw	r26, r16
     2a2:	8d 91       	ld	r24, X+
     2a4:	9c 91       	ld	r25, X
     2a6:	11 97       	sbiw	r26, 0x01	; 1
     2a8:	82 23       	and	r24, r18
     2aa:	93 23       	and	r25, r19
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     2ac:	4f 2d       	mov	r20, r15
     2ae:	28 17       	cp	r18, r24
     2b0:	39 07       	cpc	r19, r25
     2b2:	09 f0       	breq	.+2      	; 0x2b6 <xEventGroupSetBits+0x98>
     2b4:	4e 2d       	mov	r20, r14
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     2b6:	44 23       	and	r20, r20
     2b8:	59 f0       	breq	.+22     	; 0x2d0 <xEventGroupSetBits+0xb2>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     2ba:	70 ff       	sbrs	r23, 0
     2bc:	02 c0       	rjmp	.+4      	; 0x2c2 <xEventGroupSetBits+0xa4>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     2be:	a2 2a       	or	r10, r18
     2c0:	b3 2a       	or	r11, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     2c2:	d8 01       	movw	r26, r16
     2c4:	6d 91       	ld	r22, X+
     2c6:	7c 91       	ld	r23, X
     2c8:	72 60       	ori	r23, 0x02	; 2
     2ca:	cf 01       	movw	r24, r30
     2cc:	0e 94 0d 15 	call	0x2a1a	; 0x2a1a <xTaskRemoveFromUnorderedEventList>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     2d0:	cc 16       	cp	r12, r28
     2d2:	dd 06       	cpc	r13, r29
     2d4:	79 f6       	brne	.-98     	; 0x274 <xEventGroupSetBits+0x56>
     2d6:	02 c0       	rjmp	.+4      	; 0x2dc <xEventGroupSetBits+0xbe>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     2d8:	aa 24       	eor	r10, r10
     2da:	bb 24       	eor	r11, r11
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     2dc:	c5 01       	movw	r24, r10
     2de:	80 95       	com	r24
     2e0:	90 95       	com	r25
     2e2:	f8 01       	movw	r30, r16
     2e4:	a0 80       	ld	r10, Z
     2e6:	b1 80       	ldd	r11, Z+1	; 0x01
     2e8:	a8 22       	and	r10, r24
     2ea:	b9 22       	and	r11, r25
     2ec:	b1 82       	std	Z+1, r11	; 0x01
     2ee:	a0 82       	st	Z, r10
	}
	( void ) xTaskResumeAll();
     2f0:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
     2f4:	d8 01       	movw	r26, r16
     2f6:	8c 91       	ld	r24, X
     2f8:	11 96       	adiw	r26, 0x01	; 1
     2fa:	9c 91       	ld	r25, X
     2fc:	11 97       	sbiw	r26, 0x01	; 1
     2fe:	df 91       	pop	r29
     300:	cf 91       	pop	r28
     302:	1f 91       	pop	r17
     304:	0f 91       	pop	r16
     306:	ff 90       	pop	r15
     308:	ef 90       	pop	r14
     30a:	df 90       	pop	r13
     30c:	cf 90       	pop	r12
     30e:	bf 90       	pop	r11
     310:	af 90       	pop	r10
     312:	08 95       	ret

00000314 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     314:	af 92       	push	r10
     316:	bf 92       	push	r11
     318:	cf 92       	push	r12
     31a:	df 92       	push	r13
     31c:	ef 92       	push	r14
     31e:	ff 92       	push	r15
     320:	0f 93       	push	r16
     322:	1f 93       	push	r17
     324:	cf 93       	push	r28
     326:	df 93       	push	r29
     328:	6c 01       	movw	r12, r24
     32a:	eb 01       	movw	r28, r22
     32c:	7a 01       	movw	r14, r20
     32e:	59 01       	movw	r10, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     330:	0e 94 1c 12 	call	0x2438	; 0x2438 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     334:	f6 01       	movw	r30, r12
     336:	00 81       	ld	r16, Z
     338:	11 81       	ldd	r17, Z+1	; 0x01

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     33a:	c6 01       	movw	r24, r12
     33c:	be 01       	movw	r22, r28
     33e:	0e 94 0f 01 	call	0x21e	; 0x21e <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     342:	c0 2b       	or	r28, r16
     344:	d1 2b       	or	r29, r17
     346:	c7 01       	movw	r24, r14
     348:	8c 23       	and	r24, r28
     34a:	9d 23       	and	r25, r29
     34c:	8e 15       	cp	r24, r14
     34e:	9f 05       	cpc	r25, r15
     350:	51 f4       	brne	.+20     	; 0x366 <xEventGroupSync+0x52>
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     352:	80 95       	com	r24
     354:	90 95       	com	r25
     356:	f6 01       	movw	r30, r12
     358:	20 81       	ld	r18, Z
     35a:	31 81       	ldd	r19, Z+1	; 0x01
     35c:	82 23       	and	r24, r18
     35e:	93 23       	and	r25, r19
     360:	91 83       	std	Z+1, r25	; 0x01
     362:	80 83       	st	Z, r24
     364:	12 c0       	rjmp	.+36     	; 0x38a <xEventGroupSync+0x76>

			xTicksToWait = 0;
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     366:	a1 14       	cp	r10, r1
     368:	b1 04       	cpc	r11, r1
     36a:	61 f0       	breq	.+24     	; 0x384 <xEventGroupSync+0x70>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     36c:	b7 01       	movw	r22, r14
     36e:	75 60       	ori	r23, 0x05	; 5
     370:	c6 01       	movw	r24, r12
     372:	02 96       	adiw	r24, 0x02	; 2
     374:	a5 01       	movw	r20, r10
     376:	0e 94 a9 14 	call	0x2952	; 0x2952 <vTaskPlaceOnUnorderedEventList>
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     37a:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
     37e:	88 23       	and	r24, r24
     380:	49 f4       	brne	.+18     	; 0x394 <xEventGroupSync+0x80>
     382:	06 c0       	rjmp	.+12     	; 0x390 <xEventGroupSync+0x7c>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     384:	f6 01       	movw	r30, r12
     386:	c0 81       	ld	r28, Z
     388:	d1 81       	ldd	r29, Z+1	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     38a:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskResumeAll>
     38e:	1c c0       	rjmp	.+56     	; 0x3c8 <xEventGroupSync+0xb4>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     390:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     394:	0e 94 2f 16 	call	0x2c5e	; 0x2c5e <uxTaskResetEventItemValue>

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     398:	91 fd       	sbrc	r25, 1
     39a:	14 c0       	rjmp	.+40     	; 0x3c4 <xEventGroupSync+0xb0>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     39c:	0f b6       	in	r0, 0x3f	; 63
     39e:	f8 94       	cli
     3a0:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     3a2:	f6 01       	movw	r30, r12
     3a4:	80 81       	ld	r24, Z
     3a6:	91 81       	ldd	r25, Z+1	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     3a8:	97 01       	movw	r18, r14
     3aa:	28 23       	and	r18, r24
     3ac:	39 23       	and	r19, r25
     3ae:	2e 15       	cp	r18, r14
     3b0:	3f 05       	cpc	r19, r15
     3b2:	31 f4       	brne	.+12     	; 0x3c0 <xEventGroupSync+0xac>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     3b4:	20 95       	com	r18
     3b6:	30 95       	com	r19
     3b8:	28 23       	and	r18, r24
     3ba:	39 23       	and	r19, r25
     3bc:	31 83       	std	Z+1, r19	; 0x01
     3be:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     3c0:	0f 90       	pop	r0
     3c2:	0f be       	out	0x3f, r0	; 63
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     3c4:	ec 01       	movw	r28, r24
     3c6:	d0 70       	andi	r29, 0x00	; 0
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     3c8:	8c 2f       	mov	r24, r28
     3ca:	9d 2f       	mov	r25, r29
     3cc:	df 91       	pop	r29
     3ce:	cf 91       	pop	r28
     3d0:	1f 91       	pop	r17
     3d2:	0f 91       	pop	r16
     3d4:	ff 90       	pop	r15
     3d6:	ef 90       	pop	r14
     3d8:	df 90       	pop	r13
     3da:	cf 90       	pop	r12
     3dc:	bf 90       	pop	r11
     3de:	af 90       	pop	r10
     3e0:	08 95       	ret

000003e2 <vEventGroupDelete>:
	return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     3e2:	cf 93       	push	r28
     3e4:	df 93       	push	r29
     3e6:	ec 01       	movw	r28, r24
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

	vTaskSuspendAll();
     3e8:	0e 94 1c 12 	call	0x2438	; 0x2438 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     3ec:	8a 81       	ldd	r24, Y+2	; 0x02
     3ee:	88 23       	and	r24, r24
     3f0:	49 f0       	breq	.+18     	; 0x404 <vEventGroupDelete+0x22>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     3f2:	8f 81       	ldd	r24, Y+7	; 0x07
     3f4:	98 85       	ldd	r25, Y+8	; 0x08
     3f6:	60 e0       	ldi	r22, 0x00	; 0
     3f8:	72 e0       	ldi	r23, 0x02	; 2
     3fa:	0e 94 0d 15 	call	0x2a1a	; 0x2a1a <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     3fe:	8a 81       	ldd	r24, Y+2	; 0x02
     400:	88 23       	and	r24, r24
     402:	b9 f7       	brne	.-18     	; 0x3f2 <vEventGroupDelete+0x10>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     404:	ce 01       	movw	r24, r28
     406:	0e 94 b2 02 	call	0x564	; 0x564 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     40a:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskResumeAll>
}
     40e:	df 91       	pop	r29
     410:	cf 91       	pop	r28
     412:	08 95       	ret

00000414 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
     414:	ba 01       	movw	r22, r20
     416:	0e 94 0f 01 	call	0x21e	; 0x21e <xEventGroupSetBits>
}
     41a:	08 95       	ret

0000041c <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
     41c:	ba 01       	movw	r22, r20
     41e:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <xEventGroupClearBits>
}
     422:	08 95       	ret

00000424 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     424:	0f 93       	push	r16
     426:	1f 93       	push	r17
     428:	cf 93       	push	r28
     42a:	df 93       	push	r29
     42c:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     42e:	0e 94 1c 12 	call	0x2438	; 0x2438 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     432:	80 91 a2 00 	lds	r24, 0x00A2
     436:	88 23       	and	r24, r24
     438:	f9 f4       	brne	.+62     	; 0x478 <pvPortMalloc+0x54>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     43a:	8c ea       	ldi	r24, 0xAC	; 172
     43c:	90 e0       	ldi	r25, 0x00	; 0
     43e:	90 93 a4 00 	sts	0x00A4, r25
     442:	80 93 a3 00 	sts	0x00A3, r24
	xStart.xBlockSize = ( size_t ) 0;
     446:	10 92 a6 00 	sts	0x00A6, r1
     44a:	10 92 a5 00 	sts	0x00A5, r1

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     44e:	8f e1       	ldi	r24, 0x1F	; 31
     450:	93 e0       	ldi	r25, 0x03	; 3
     452:	90 93 aa 00 	sts	0x00AA, r25
     456:	80 93 a9 00 	sts	0x00A9, r24
	xEnd.pxNextFreeBlock = NULL;
     45a:	e9 ea       	ldi	r30, 0xA9	; 169
     45c:	f0 e0       	ldi	r31, 0x00	; 0
     45e:	12 92       	st	-Z, r1
     460:	12 92       	st	-Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     462:	90 93 af 00 	sts	0x00AF, r25
     466:	80 93 ae 00 	sts	0x00AE, r24
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     46a:	f0 93 ad 00 	sts	0x00AD, r31
     46e:	e0 93 ac 00 	sts	0x00AC, r30
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
     472:	81 e0       	ldi	r24, 0x01	; 1
     474:	80 93 a2 00 	sts	0x00A2, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     478:	20 97       	sbiw	r28, 0x00	; 0
     47a:	09 f4       	brne	.+2      	; 0x47e <pvPortMalloc+0x5a>
     47c:	62 c0       	rjmp	.+196    	; 0x542 <pvPortMalloc+0x11e>
		{
			xWantedSize += heapSTRUCT_SIZE;
     47e:	9e 01       	movw	r18, r28
     480:	2c 5f       	subi	r18, 0xFC	; 252
     482:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     484:	23 96       	adiw	r28, 0x03	; 3
     486:	83 e0       	ldi	r24, 0x03	; 3
     488:	ce 31       	cpi	r28, 0x1E	; 30
     48a:	d8 07       	cpc	r29, r24
     48c:	08 f0       	brcs	.+2      	; 0x490 <pvPortMalloc+0x6c>
     48e:	5c c0       	rjmp	.+184    	; 0x548 <pvPortMalloc+0x124>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     490:	e0 91 a3 00 	lds	r30, 0x00A3
     494:	f0 91 a4 00 	lds	r31, 0x00A4

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     498:	a3 ea       	ldi	r26, 0xA3	; 163
     49a:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     49c:	02 c0       	rjmp	.+4      	; 0x4a2 <pvPortMalloc+0x7e>
     49e:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     4a0:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     4a2:	82 81       	ldd	r24, Z+2	; 0x02
     4a4:	93 81       	ldd	r25, Z+3	; 0x03
     4a6:	82 17       	cp	r24, r18
     4a8:	93 07       	cpc	r25, r19
     4aa:	20 f4       	brcc	.+8      	; 0x4b4 <pvPortMalloc+0x90>
     4ac:	80 81       	ld	r24, Z
     4ae:	91 81       	ldd	r25, Z+1	; 0x01
     4b0:	00 97       	sbiw	r24, 0x00	; 0
     4b2:	a9 f7       	brne	.-22     	; 0x49e <pvPortMalloc+0x7a>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     4b4:	c0 e0       	ldi	r28, 0x00	; 0
     4b6:	e7 3a       	cpi	r30, 0xA7	; 167
     4b8:	fc 07       	cpc	r31, r28
     4ba:	09 f4       	brne	.+2      	; 0x4be <pvPortMalloc+0x9a>
     4bc:	48 c0       	rjmp	.+144    	; 0x54e <pvPortMalloc+0x12a>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     4be:	8d 91       	ld	r24, X+
     4c0:	9c 91       	ld	r25, X
     4c2:	11 97       	sbiw	r26, 0x01	; 1
     4c4:	8c 01       	movw	r16, r24
     4c6:	0c 5f       	subi	r16, 0xFC	; 252
     4c8:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     4ca:	80 81       	ld	r24, Z
     4cc:	91 81       	ldd	r25, Z+1	; 0x01
     4ce:	11 96       	adiw	r26, 0x01	; 1
     4d0:	9c 93       	st	X, r25
     4d2:	8e 93       	st	-X, r24

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     4d4:	82 81       	ldd	r24, Z+2	; 0x02
     4d6:	93 81       	ldd	r25, Z+3	; 0x03
     4d8:	82 1b       	sub	r24, r18
     4da:	93 0b       	sbc	r25, r19
     4dc:	89 30       	cpi	r24, 0x09	; 9
     4de:	91 05       	cpc	r25, r1
     4e0:	18 f1       	brcs	.+70     	; 0x528 <pvPortMalloc+0x104>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     4e2:	af 01       	movw	r20, r30
     4e4:	42 0f       	add	r20, r18
     4e6:	53 1f       	adc	r21, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     4e8:	da 01       	movw	r26, r20
     4ea:	13 96       	adiw	r26, 0x03	; 3
     4ec:	9c 93       	st	X, r25
     4ee:	8e 93       	st	-X, r24
     4f0:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     4f2:	33 83       	std	Z+3, r19	; 0x03
     4f4:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     4f6:	12 96       	adiw	r26, 0x02	; 2
     4f8:	2d 91       	ld	r18, X+
     4fa:	3c 91       	ld	r19, X
     4fc:	13 97       	sbiw	r26, 0x03	; 3
     4fe:	63 ea       	ldi	r22, 0xA3	; 163
     500:	70 e0       	ldi	r23, 0x00	; 0
     502:	01 c0       	rjmp	.+2      	; 0x506 <pvPortMalloc+0xe2>
     504:	bd 01       	movw	r22, r26
     506:	eb 01       	movw	r28, r22
     508:	a8 81       	ld	r26, Y
     50a:	b9 81       	ldd	r27, Y+1	; 0x01
     50c:	12 96       	adiw	r26, 0x02	; 2
     50e:	8d 91       	ld	r24, X+
     510:	9c 91       	ld	r25, X
     512:	13 97       	sbiw	r26, 0x03	; 3
     514:	82 17       	cp	r24, r18
     516:	93 07       	cpc	r25, r19
     518:	a8 f3       	brcs	.-22     	; 0x504 <pvPortMalloc+0xe0>
     51a:	ea 01       	movw	r28, r20
     51c:	b9 83       	std	Y+1, r27	; 0x01
     51e:	a8 83       	st	Y, r26
     520:	db 01       	movw	r26, r22
     522:	11 96       	adiw	r26, 0x01	; 1
     524:	5c 93       	st	X, r21
     526:	4e 93       	st	-X, r20
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     528:	80 91 60 00 	lds	r24, 0x0060
     52c:	90 91 61 00 	lds	r25, 0x0061
     530:	22 81       	ldd	r18, Z+2	; 0x02
     532:	33 81       	ldd	r19, Z+3	; 0x03
     534:	82 1b       	sub	r24, r18
     536:	93 0b       	sbc	r25, r19
     538:	90 93 61 00 	sts	0x0061, r25
     53c:	80 93 60 00 	sts	0x0060, r24
     540:	08 c0       	rjmp	.+16     	; 0x552 <pvPortMalloc+0x12e>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     542:	00 e0       	ldi	r16, 0x00	; 0
     544:	10 e0       	ldi	r17, 0x00	; 0
     546:	05 c0       	rjmp	.+10     	; 0x552 <pvPortMalloc+0x12e>
     548:	00 e0       	ldi	r16, 0x00	; 0
     54a:	10 e0       	ldi	r17, 0x00	; 0
     54c:	02 c0       	rjmp	.+4      	; 0x552 <pvPortMalloc+0x12e>
     54e:	00 e0       	ldi	r16, 0x00	; 0
     550:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     552:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     556:	80 2f       	mov	r24, r16
     558:	91 2f       	mov	r25, r17
     55a:	df 91       	pop	r29
     55c:	cf 91       	pop	r28
     55e:	1f 91       	pop	r17
     560:	0f 91       	pop	r16
     562:	08 95       	ret

00000564 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     564:	0f 93       	push	r16
     566:	1f 93       	push	r17
     568:	cf 93       	push	r28
     56a:	df 93       	push	r29
     56c:	ec 01       	movw	r28, r24
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     56e:	00 97       	sbiw	r24, 0x00	; 0
     570:	39 f1       	breq	.+78     	; 0x5c0 <vPortFree+0x5c>
		before it. */
		puc -= heapSTRUCT_SIZE;

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
     572:	8c 01       	movw	r16, r24
     574:	04 50       	subi	r16, 0x04	; 4
     576:	10 40       	sbci	r17, 0x00	; 0

		vTaskSuspendAll();
     578:	0e 94 1c 12 	call	0x2438	; 0x2438 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     57c:	f8 01       	movw	r30, r16
     57e:	22 81       	ldd	r18, Z+2	; 0x02
     580:	33 81       	ldd	r19, Z+3	; 0x03
     582:	a3 ea       	ldi	r26, 0xA3	; 163
     584:	b0 e0       	ldi	r27, 0x00	; 0
     586:	01 c0       	rjmp	.+2      	; 0x58a <vPortFree+0x26>
     588:	df 01       	movw	r26, r30
     58a:	ed 91       	ld	r30, X+
     58c:	fc 91       	ld	r31, X
     58e:	11 97       	sbiw	r26, 0x01	; 1
     590:	82 81       	ldd	r24, Z+2	; 0x02
     592:	93 81       	ldd	r25, Z+3	; 0x03
     594:	82 17       	cp	r24, r18
     596:	93 07       	cpc	r25, r19
     598:	b8 f3       	brcs	.-18     	; 0x588 <vPortFree+0x24>
     59a:	24 97       	sbiw	r28, 0x04	; 4
     59c:	f9 83       	std	Y+1, r31	; 0x01
     59e:	e8 83       	st	Y, r30
     5a0:	0d 93       	st	X+, r16
     5a2:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     5a4:	80 91 60 00 	lds	r24, 0x0060
     5a8:	90 91 61 00 	lds	r25, 0x0061
     5ac:	2a 81       	ldd	r18, Y+2	; 0x02
     5ae:	3b 81       	ldd	r19, Y+3	; 0x03
     5b0:	82 0f       	add	r24, r18
     5b2:	93 1f       	adc	r25, r19
     5b4:	90 93 61 00 	sts	0x0061, r25
     5b8:	80 93 60 00 	sts	0x0060, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     5bc:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskResumeAll>
	}
}
     5c0:	df 91       	pop	r29
     5c2:	cf 91       	pop	r28
     5c4:	1f 91       	pop	r17
     5c6:	0f 91       	pop	r16
     5c8:	08 95       	ret

000005ca <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
     5ca:	80 91 60 00 	lds	r24, 0x0060
     5ce:	90 91 61 00 	lds	r25, 0x0061
     5d2:	08 95       	ret

000005d4 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* This just exists to keep the linker quiet. */
}
     5d4:	08 95       	ret

000005d6 <keypad_init>:



void keypad_init()
{
	DDRC = 0x0f;
     5d6:	8f e0       	ldi	r24, 0x0F	; 15
     5d8:	84 bb       	out	0x14, r24	; 20
	PORTC = 0xf0;
     5da:	80 ef       	ldi	r24, 0xF0	; 240
     5dc:	85 bb       	out	0x15, r24	; 21
	//floating point
	SFIOR &=(~(1<<PUD));
     5de:	80 b7       	in	r24, 0x30	; 48
     5e0:	8b 7f       	andi	r24, 0xFB	; 251
     5e2:	80 bf       	out	0x30, r24	; 48
}
     5e4:	08 95       	ret

000005e6 <check>:

char check()
{
     5e6:	af 92       	push	r10
     5e8:	bf 92       	push	r11
     5ea:	cf 92       	push	r12
     5ec:	df 92       	push	r13
     5ee:	ef 92       	push	r14
     5f0:	ff 92       	push	r15
     5f2:	0f 93       	push	r16
     5f4:	1f 93       	push	r17
     5f6:	cf 93       	push	r28
     5f8:	df 93       	push	r29
     5fa:	cd b7       	in	r28, 0x3d	; 61
     5fc:	de b7       	in	r29, 0x3e	; 62
     5fe:	60 97       	sbiw	r28, 0x10	; 16
     600:	0f b6       	in	r0, 0x3f	; 63
     602:	f8 94       	cli
     604:	de bf       	out	0x3e, r29	; 62
     606:	0f be       	out	0x3f, r0	; 63
     608:	cd bf       	out	0x3d, r28	; 61
	char ret =0;
	char flag=0;
	
	char buttonss[4][4]  = {{'7','4','1','o'},{'8','5','2','0'},{'9','6','3','='},{'//','*','-','+'}};
     60a:	de 01       	movw	r26, r28
     60c:	11 96       	adiw	r26, 0x01	; 1
     60e:	e2 e6       	ldi	r30, 0x62	; 98
     610:	f0 e0       	ldi	r31, 0x00	; 0
     612:	80 e1       	ldi	r24, 0x10	; 16
     614:	01 90       	ld	r0, Z+
     616:	0d 92       	st	X+, r0
     618:	81 50       	subi	r24, 0x01	; 1
     61a:	e1 f7       	brne	.-8      	; 0x614 <check+0x2e>
     61c:	ee 24       	eor	r14, r14
     61e:	ff 24       	eor	r15, r15
}

char check()
{
	char ret =0;
	char flag=0;
     620:	10 e0       	ldi	r17, 0x00	; 0
	SFIOR &=(~(1<<PUD));
}

char check()
{
	char ret =0;
     622:	00 e0       	ldi	r16, 0x00	; 0
	char row,col;
	
	for(char r=0;r<4;r++)
	{
		PORTC |=0x0f;
		PORTC &= (~(1<<r));
     624:	e1 e0       	ldi	r30, 0x01	; 1
     626:	f0 e0       	ldi	r31, 0x00	; 0
     628:	aa 24       	eor	r10, r10
     62a:	bb 24       	eor	r11, r11
     62c:	68 94       	set
     62e:	a2 f8       	bld	r10, 2
		{
			if(((PINC& (1<<(c+4)))>>(c+4))==0)
			{
				row=c;
				col=r;
				flag=1;
     630:	61 e0       	ldi	r22, 0x01	; 1
	
	char row,col;
	
	for(char r=0;r<4;r++)
	{
		PORTC |=0x0f;
     632:	85 b3       	in	r24, 0x15	; 21
     634:	8f 60       	ori	r24, 0x0F	; 15
     636:	85 bb       	out	0x15, r24	; 21
		PORTC &= (~(1<<r));
     638:	25 b3       	in	r18, 0x15	; 21
     63a:	cf 01       	movw	r24, r30
     63c:	0e 2c       	mov	r0, r14
     63e:	02 c0       	rjmp	.+4      	; 0x644 <check+0x5e>
     640:	88 0f       	add	r24, r24
     642:	99 1f       	adc	r25, r25
     644:	0a 94       	dec	r0
     646:	e2 f7       	brpl	.-8      	; 0x640 <check+0x5a>
     648:	80 95       	com	r24
     64a:	82 23       	and	r24, r18
     64c:	85 bb       	out	0x15, r24	; 21
     64e:	95 01       	movw	r18, r10
		
		for(char c=0;c<4;c++)
		{
			if(((PINC& (1<<(c+4)))>>(c+4))==0)
     650:	ae 2d       	mov	r26, r14
	PORTC = 0xf0;
	//floating point
	SFIOR &=(~(1<<PUD));
}

char check()
     652:	72 2f       	mov	r23, r18
     654:	74 50       	subi	r23, 0x04	; 4
		PORTC |=0x0f;
		PORTC &= (~(1<<r));
		
		for(char c=0;c<4;c++)
		{
			if(((PINC& (1<<(c+4)))>>(c+4))==0)
     656:	83 b3       	in	r24, 0x13	; 19
     658:	af 01       	movw	r20, r30
     65a:	02 2e       	mov	r0, r18
     65c:	02 c0       	rjmp	.+4      	; 0x662 <check+0x7c>
     65e:	44 0f       	add	r20, r20
     660:	55 1f       	adc	r21, r21
     662:	0a 94       	dec	r0
     664:	e2 f7       	brpl	.-8      	; 0x65e <check+0x78>
     666:	90 e0       	ldi	r25, 0x00	; 0
     668:	84 23       	and	r24, r20
     66a:	95 23       	and	r25, r21
     66c:	02 2e       	mov	r0, r18
     66e:	02 c0       	rjmp	.+4      	; 0x674 <check+0x8e>
     670:	95 95       	asr	r25
     672:	87 95       	ror	r24
     674:	0a 94       	dec	r0
     676:	e2 f7       	brpl	.-8      	; 0x670 <check+0x8a>
     678:	00 97       	sbiw	r24, 0x00	; 0
     67a:	21 f4       	brne	.+8      	; 0x684 <check+0x9e>
     67c:	ca 2e       	mov	r12, r26
     67e:	d7 2e       	mov	r13, r23
			{
				row=c;
				col=r;
				flag=1;
     680:	16 2f       	mov	r17, r22
				ret=1;
     682:	06 2f       	mov	r16, r22
		PORTC |=0x0f;
		PORTC &= (~(1<<r));
		
		for(char c=0;c<4;c++)
		{
			if(((PINC& (1<<(c+4)))>>(c+4))==0)
     684:	2f 5f       	subi	r18, 0xFF	; 255
     686:	3f 4f       	sbci	r19, 0xFF	; 255
	for(char r=0;r<4;r++)
	{
		PORTC |=0x0f;
		PORTC &= (~(1<<r));
		
		for(char c=0;c<4;c++)
     688:	28 30       	cpi	r18, 0x08	; 8
     68a:	31 05       	cpc	r19, r1
     68c:	11 f7       	brne	.-60     	; 0x652 <check+0x6c>
				flag=1;
				ret=1;
			}
			
		}
		if(flag == 1 )
     68e:	11 30       	cpi	r17, 0x01	; 1
     690:	39 f0       	breq	.+14     	; 0x6a0 <check+0xba>
     692:	08 94       	sec
     694:	e1 1c       	adc	r14, r1
     696:	f1 1c       	adc	r15, r1
	
	char buttonss[4][4]  = {{'7','4','1','o'},{'8','5','2','0'},{'9','6','3','='},{'//','*','-','+'}};
	
	char row,col;
	
	for(char r=0;r<4;r++)
     698:	84 e0       	ldi	r24, 0x04	; 4
     69a:	e8 16       	cp	r14, r24
     69c:	f1 04       	cpc	r15, r1
     69e:	49 f6       	brne	.-110    	; 0x632 <check+0x4c>
		{
			break;
		}
	}
	
	if(flag==1)
     6a0:	11 30       	cpi	r17, 0x01	; 1
     6a2:	59 f4       	brne	.+22     	; 0x6ba <check+0xd4>
	{
		ret = buttonss[row][col];
     6a4:	ed 2d       	mov	r30, r13
     6a6:	f0 e0       	ldi	r31, 0x00	; 0
     6a8:	ee 0f       	add	r30, r30
     6aa:	ff 1f       	adc	r31, r31
     6ac:	ee 0f       	add	r30, r30
     6ae:	ff 1f       	adc	r31, r31
     6b0:	ec 0d       	add	r30, r12
     6b2:	f1 1d       	adc	r31, r1
     6b4:	ec 0f       	add	r30, r28
     6b6:	fd 1f       	adc	r31, r29
     6b8:	01 81       	ldd	r16, Z+1	; 0x01
	
	
	
	
	return ret;
     6ba:	80 2f       	mov	r24, r16
     6bc:	60 96       	adiw	r28, 0x10	; 16
     6be:	0f b6       	in	r0, 0x3f	; 63
     6c0:	f8 94       	cli
     6c2:	de bf       	out	0x3e, r29	; 62
     6c4:	0f be       	out	0x3f, r0	; 63
     6c6:	cd bf       	out	0x3d, r28	; 61
     6c8:	df 91       	pop	r29
     6ca:	cf 91       	pop	r28
     6cc:	1f 91       	pop	r17
     6ce:	0f 91       	pop	r16
     6d0:	ff 90       	pop	r15
     6d2:	ef 90       	pop	r14
     6d4:	df 90       	pop	r13
     6d6:	cf 90       	pop	r12
     6d8:	bf 90       	pop	r11
     6da:	af 90       	pop	r10
     6dc:	08 95       	ret

000006de <sendFallingEdge>:
	LCD_vsendCommand(address);
	
}
static void sendFallingEdge()
{
	PORTA |=(1<<EN);
     6de:	db 9a       	sbi	0x1b, 3	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6e0:	8f e9       	ldi	r24, 0x9F	; 159
     6e2:	9f e0       	ldi	r25, 0x0F	; 15
     6e4:	01 97       	sbiw	r24, 0x01	; 1
     6e6:	f1 f7       	brne	.-4      	; 0x6e4 <sendFallingEdge+0x6>
     6e8:	00 c0       	rjmp	.+0      	; 0x6ea <sendFallingEdge+0xc>
     6ea:	00 00       	nop
	_delay_ms(2);
	PORTA &=(~(1<<EN));
     6ec:	db 98       	cbi	0x1b, 3	; 27
     6ee:	8f e9       	ldi	r24, 0x9F	; 159
     6f0:	9f e0       	ldi	r25, 0x0F	; 15
     6f2:	01 97       	sbiw	r24, 0x01	; 1
     6f4:	f1 f7       	brne	.-4      	; 0x6f2 <sendFallingEdge+0x14>
     6f6:	00 c0       	rjmp	.+0      	; 0x6f8 <sendFallingEdge+0x1a>
     6f8:	00 00       	nop
	_delay_ms(2);
}
     6fa:	08 95       	ret

000006fc <LCD_vsendCommand>:
}
#endif

#if defined (LCD_4bit)
void LCD_vsendCommand(char cmd) // run command on LCD
{
     6fc:	cf 93       	push	r28
     6fe:	c8 2f       	mov	r28, r24
	PORTA&= (~(1<<RS));// make RS regiter to zero to make it command
     700:	d9 98       	cbi	0x1b, 1	; 27
	
	PORTA&=0x0f;
     702:	8b b3       	in	r24, 0x1b	; 27
     704:	8f 70       	andi	r24, 0x0F	; 15
     706:	8b bb       	out	0x1b, r24	; 27
	
	PORTA |= (0xf0 & cmd);
     708:	8b b3       	in	r24, 0x1b	; 27
     70a:	9c 2f       	mov	r25, r28
     70c:	90 7f       	andi	r25, 0xF0	; 240
     70e:	89 2b       	or	r24, r25
     710:	8b bb       	out	0x1b, r24	; 27
	sendFallingEdge(); // run the command
     712:	0e 94 6f 03 	call	0x6de	; 0x6de <sendFallingEdge>
	
	PORTA&=0x0f;
     716:	8b b3       	in	r24, 0x1b	; 27
     718:	8f 70       	andi	r24, 0x0F	; 15
     71a:	8b bb       	out	0x1b, r24	; 27
	PORTA |= ((0x0f &cmd)<<4);
     71c:	8b b3       	in	r24, 0x1b	; 27
     71e:	c2 95       	swap	r28
     720:	c0 7f       	andi	r28, 0xF0	; 240
     722:	c8 2b       	or	r28, r24
     724:	cb bb       	out	0x1b, r28	; 27
	sendFallingEdge();// run the command
     726:	0e 94 6f 03 	call	0x6de	; 0x6de <sendFallingEdge>
	
	
}
     72a:	cf 91       	pop	r28
     72c:	08 95       	ret

0000072e <LCD_VINIT>:
void LCD_VINIT()
{
	DDRA |= 0xf0;
     72e:	8a b3       	in	r24, 0x1a	; 26
     730:	80 6f       	ori	r24, 0xF0	; 240
     732:	8a bb       	out	0x1a, r24	; 26
	DDRA |=0x0e;
     734:	8a b3       	in	r24, 0x1a	; 26
     736:	8e 60       	ori	r24, 0x0E	; 14
     738:	8a bb       	out	0x1a, r24	; 26
	PORTA &=(~(1<<RW));
     73a:	da 98       	cbi	0x1b, 2	; 27
	
	//4bit mode all 8 bits used for data
	LCD_vsendCommand(0x33);
     73c:	83 e3       	ldi	r24, 0x33	; 51
     73e:	0e 94 7e 03 	call	0x6fc	; 0x6fc <LCD_vsendCommand>
	LCD_vsendCommand(0x32);
     742:	82 e3       	ldi	r24, 0x32	; 50
     744:	0e 94 7e 03 	call	0x6fc	; 0x6fc <LCD_vsendCommand>
	LCD_vsendCommand(0x28); // 2 lines 4 bit mode
     748:	88 e2       	ldi	r24, 0x28	; 40
     74a:	0e 94 7e 03 	call	0x6fc	; 0x6fc <LCD_vsendCommand>
	
	LCD_vsendCommand(CLEAR_SCREEN);//clear screen
     74e:	81 e0       	ldi	r24, 0x01	; 1
     750:	0e 94 7e 03 	call	0x6fc	; 0x6fc <LCD_vsendCommand>
	LCD_vsendCommand(CURSOR_ON);//Turn on cursor
     754:	8e e0       	ldi	r24, 0x0E	; 14
     756:	0e 94 7e 03 	call	0x6fc	; 0x6fc <LCD_vsendCommand>
     75a:	8f e3       	ldi	r24, 0x3F	; 63
     75c:	9c e9       	ldi	r25, 0x9C	; 156
     75e:	01 97       	sbiw	r24, 0x01	; 1
     760:	f1 f7       	brne	.-4      	; 0x75e <LCD_VINIT+0x30>
     762:	00 c0       	rjmp	.+0      	; 0x764 <LCD_VINIT+0x36>
     764:	00 00       	nop
	_delay_ms(20);
	
}
     766:	08 95       	ret

00000768 <LCD_vsendData>:
void LCD_vsendData(char data) // run command on LCD
{
     768:	cf 93       	push	r28
     76a:	c8 2f       	mov	r28, r24
	PORTA|= (1<<RS); // make RS regiter to zero to make it command
     76c:	d9 9a       	sbi	0x1b, 1	; 27
	
	PORTA&=0x0f;
     76e:	8b b3       	in	r24, 0x1b	; 27
     770:	8f 70       	andi	r24, 0x0F	; 15
     772:	8b bb       	out	0x1b, r24	; 27
	
	PORTA |= (0xf0 & data);
     774:	8b b3       	in	r24, 0x1b	; 27
     776:	9c 2f       	mov	r25, r28
     778:	90 7f       	andi	r25, 0xF0	; 240
     77a:	89 2b       	or	r24, r25
     77c:	8b bb       	out	0x1b, r24	; 27
	sendFallingEdge(); // run the command
     77e:	0e 94 6f 03 	call	0x6de	; 0x6de <sendFallingEdge>
	
	PORTA&=0x0f;
     782:	8b b3       	in	r24, 0x1b	; 27
     784:	8f 70       	andi	r24, 0x0F	; 15
     786:	8b bb       	out	0x1b, r24	; 27
	PORTA |= ((0x0f &data)<<4);
     788:	8b b3       	in	r24, 0x1b	; 27
     78a:	c2 95       	swap	r28
     78c:	c0 7f       	andi	r28, 0xF0	; 240
     78e:	c8 2b       	or	r28, r24
     790:	cb bb       	out	0x1b, r28	; 27
	sendFallingEdge();// run the command
     792:	0e 94 6f 03 	call	0x6de	; 0x6de <sendFallingEdge>
	
	
}
     796:	cf 91       	pop	r28
     798:	08 95       	ret

0000079a <clear_screen>:
#endif
void clear_screen()
{
	LCD_vsendCommand(CLEAR_SCREEN);//clear screen
     79a:	81 e0       	ldi	r24, 0x01	; 1
     79c:	0e 94 7e 03 	call	0x6fc	; 0x6fc <LCD_vsendCommand>
}
     7a0:	08 95       	ret

000007a2 <LCD_VGOTO>:
void LCD_VGOTO(char row,char col)
{
	char address;
	if (row==0)
     7a2:	88 23       	and	r24, r24
     7a4:	11 f4       	brne	.+4      	; 0x7aa <LCD_VGOTO+0x8>
	{
		address=0x80;
     7a6:	80 e8       	ldi	r24, 0x80	; 128
     7a8:	01 c0       	rjmp	.+2      	; 0x7ac <LCD_VGOTO+0xa>
	}
	else
	{
		address=0xC0;
     7aa:	80 ec       	ldi	r24, 0xC0	; 192
	}
	
	address +=col;
	
	LCD_vsendCommand(address);
     7ac:	86 0f       	add	r24, r22
     7ae:	0e 94 7e 03 	call	0x6fc	; 0x6fc <LCD_vsendCommand>
	
}
     7b2:	08 95       	ret

000007b4 <LCD_VsnedString>:
	_delay_ms(2);
	PORTA &=(~(1<<EN));
	_delay_ms(2);
}
void LCD_VsnedString(char str[])
{
     7b4:	0f 93       	push	r16
     7b6:	1f 93       	push	r17
     7b8:	cf 93       	push	r28
     7ba:	8c 01       	movw	r16, r24
	char i=0;
	while(str[i] != '\0')
     7bc:	fc 01       	movw	r30, r24
     7be:	80 81       	ld	r24, Z
     7c0:	88 23       	and	r24, r24
     7c2:	51 f0       	breq	.+20     	; 0x7d8 <LCD_VsnedString+0x24>
	PORTA &=(~(1<<EN));
	_delay_ms(2);
}
void LCD_VsnedString(char str[])
{
	char i=0;
     7c4:	c0 e0       	ldi	r28, 0x00	; 0
	while(str[i] != '\0')
	{
		LCD_vsendData(str[i]);
     7c6:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
		i++;
     7ca:	cf 5f       	subi	r28, 0xFF	; 255
	_delay_ms(2);
}
void LCD_VsnedString(char str[])
{
	char i=0;
	while(str[i] != '\0')
     7cc:	f8 01       	movw	r30, r16
     7ce:	ec 0f       	add	r30, r28
     7d0:	f1 1d       	adc	r31, r1
     7d2:	80 81       	ld	r24, Z
     7d4:	88 23       	and	r24, r24
     7d6:	b9 f7       	brne	.-18     	; 0x7c6 <LCD_VsnedString+0x12>
	{
		LCD_vsendData(str[i]);
		i++;
	}
	
}
     7d8:	cf 91       	pop	r28
     7da:	1f 91       	pop	r17
     7dc:	0f 91       	pop	r16
     7de:	08 95       	ret

000007e0 <writeSetpassword>:

void writeSetpassword()
{
	LCD_vsendData('S');
     7e0:	83 e5       	ldi	r24, 0x53	; 83
     7e2:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('e');
     7e6:	85 e6       	ldi	r24, 0x65	; 101
     7e8:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('t');
     7ec:	84 e7       	ldi	r24, 0x74	; 116
     7ee:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData(' ');
     7f2:	80 e2       	ldi	r24, 0x20	; 32
     7f4:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('P');
     7f8:	80 e5       	ldi	r24, 0x50	; 80
     7fa:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('a');
     7fe:	81 e6       	ldi	r24, 0x61	; 97
     800:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('s');
     804:	83 e7       	ldi	r24, 0x73	; 115
     806:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('s');
     80a:	83 e7       	ldi	r24, 0x73	; 115
     80c:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('w');
     810:	87 e7       	ldi	r24, 0x77	; 119
     812:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('o');
     816:	8f e6       	ldi	r24, 0x6F	; 111
     818:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('r');
     81c:	82 e7       	ldi	r24, 0x72	; 114
     81e:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('d');
     822:	84 e6       	ldi	r24, 0x64	; 100
     824:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	
}
     828:	08 95       	ret

0000082a <writeloginscreen>:

void writeloginscreen()
{
	
	LCD_vsendData('L');
     82a:	8c e4       	ldi	r24, 0x4C	; 76
     82c:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('o');
     830:	8f e6       	ldi	r24, 0x6F	; 111
     832:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('g');
     836:	87 e6       	ldi	r24, 0x67	; 103
     838:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('i');
     83c:	89 e6       	ldi	r24, 0x69	; 105
     83e:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('n');
     842:	8e e6       	ldi	r24, 0x6E	; 110
     844:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData(':');
     848:	8a e3       	ldi	r24, 0x3A	; 58
     84a:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_VGOTO(1,0);
     84e:	81 e0       	ldi	r24, 0x01	; 1
     850:	60 e0       	ldi	r22, 0x00	; 0
     852:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <LCD_VGOTO>
	LCD_vsendData('1');
     856:	81 e3       	ldi	r24, 0x31	; 49
     858:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('.');
     85c:	8e e2       	ldi	r24, 0x2E	; 46
     85e:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('A');
     862:	81 e4       	ldi	r24, 0x41	; 65
     864:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('d');
     868:	84 e6       	ldi	r24, 0x64	; 100
     86a:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('m');
     86e:	8d e6       	ldi	r24, 0x6D	; 109
     870:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('i');
     874:	89 e6       	ldi	r24, 0x69	; 105
     876:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('n');
     87a:	8e e6       	ldi	r24, 0x6E	; 110
     87c:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData(' ');
     880:	80 e2       	ldi	r24, 0x20	; 32
     882:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('2');
     886:	82 e3       	ldi	r24, 0x32	; 50
     888:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('.');
     88c:	8e e2       	ldi	r24, 0x2E	; 46
     88e:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('G');
     892:	87 e4       	ldi	r24, 0x47	; 71
     894:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('u');
     898:	85 e7       	ldi	r24, 0x75	; 117
     89a:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('e');
     89e:	85 e6       	ldi	r24, 0x65	; 101
     8a0:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('s');
     8a4:	83 e7       	ldi	r24, 0x73	; 115
     8a6:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('t');
     8aa:	84 e7       	ldi	r24, 0x74	; 116
     8ac:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
}
     8b0:	08 95       	ret

000008b2 <writewrongpassword>:

void writewrongpassword()
{
	LCD_vsendData('W');
     8b2:	87 e5       	ldi	r24, 0x57	; 87
     8b4:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('r');
     8b8:	82 e7       	ldi	r24, 0x72	; 114
     8ba:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('o');
     8be:	8f e6       	ldi	r24, 0x6F	; 111
     8c0:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('n');
     8c4:	8e e6       	ldi	r24, 0x6E	; 110
     8c6:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('g');
     8ca:	87 e6       	ldi	r24, 0x67	; 103
     8cc:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData(' ');
     8d0:	80 e2       	ldi	r24, 0x20	; 32
     8d2:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('P');
     8d6:	80 e5       	ldi	r24, 0x50	; 80
     8d8:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('a');
     8dc:	81 e6       	ldi	r24, 0x61	; 97
     8de:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('s');
     8e2:	83 e7       	ldi	r24, 0x73	; 115
     8e4:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('s');
     8e8:	83 e7       	ldi	r24, 0x73	; 115
     8ea:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('w');
     8ee:	87 e7       	ldi	r24, 0x77	; 119
     8f0:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('o');
     8f4:	8f e6       	ldi	r24, 0x6F	; 111
     8f6:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('r');
     8fa:	82 e7       	ldi	r24, 0x72	; 114
     8fc:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('d');
     900:	84 e6       	ldi	r24, 0x64	; 100
     902:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	
	
	
}
     906:	08 95       	ret

00000908 <writeadminscreen>:

void writeadminscreen()
{
	
	LCD_vsendData('R');
     908:	82 e5       	ldi	r24, 0x52	; 82
     90a:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('o');
     90e:	8f e6       	ldi	r24, 0x6F	; 111
     910:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('o');
     914:	8f e6       	ldi	r24, 0x6F	; 111
     916:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('m');
     91a:	8d e6       	ldi	r24, 0x6D	; 109
     91c:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('s');
     920:	83 e7       	ldi	r24, 0x73	; 115
     922:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData(':');
     926:	8a e3       	ldi	r24, 0x3A	; 58
     928:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('1');
     92c:	81 e3       	ldi	r24, 0x31	; 49
     92e:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData(' ');
     932:	80 e2       	ldi	r24, 0x20	; 32
     934:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('2');
     938:	82 e3       	ldi	r24, 0x32	; 50
     93a:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData(' ');
     93e:	80 e2       	ldi	r24, 0x20	; 32
     940:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('3');
     944:	83 e3       	ldi	r24, 0x33	; 51
     946:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	
	LCD_VGOTO(1,0);
     94a:	81 e0       	ldi	r24, 0x01	; 1
     94c:	60 e0       	ldi	r22, 0x00	; 0
     94e:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <LCD_VGOTO>
	LCD_vsendData('4');
     952:	84 e3       	ldi	r24, 0x34	; 52
     954:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('.');
     958:	8e e2       	ldi	r24, 0x2E	; 46
     95a:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('T');
     95e:	84 e5       	ldi	r24, 0x54	; 84
     960:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('V');
     964:	86 e5       	ldi	r24, 0x56	; 86
     966:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData(' ');
     96a:	80 e2       	ldi	r24, 0x20	; 32
     96c:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('5');
     970:	85 e3       	ldi	r24, 0x35	; 53
     972:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('.');
     976:	8e e2       	ldi	r24, 0x2E	; 46
     978:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('A');
     97c:	81 e4       	ldi	r24, 0x41	; 65
     97e:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('c');
     982:	83 e6       	ldi	r24, 0x63	; 99
     984:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	
	
	//LCD_vsendData('W');
	
	
}
     988:	08 95       	ret

0000098a <writeguestscreen>:

void writeguestscreen()
{
	
	LCD_vsendData('R');
     98a:	82 e5       	ldi	r24, 0x52	; 82
     98c:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('o');
     990:	8f e6       	ldi	r24, 0x6F	; 111
     992:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('o');
     996:	8f e6       	ldi	r24, 0x6F	; 111
     998:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('m');
     99c:	8d e6       	ldi	r24, 0x6D	; 109
     99e:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('s');
     9a2:	83 e7       	ldi	r24, 0x73	; 115
     9a4:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData(':');
     9a8:	8a e3       	ldi	r24, 0x3A	; 58
     9aa:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('1');
     9ae:	81 e3       	ldi	r24, 0x31	; 49
     9b0:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData(' ');
     9b4:	80 e2       	ldi	r24, 0x20	; 32
     9b6:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('2');
     9ba:	82 e3       	ldi	r24, 0x32	; 50
     9bc:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData(' ');
     9c0:	80 e2       	ldi	r24, 0x20	; 32
     9c2:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	LCD_vsendData('3');
     9c6:	83 e3       	ldi	r24, 0x33	; 51
     9c8:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
	
	
	
     9cc:	08 95       	ret

000009ce <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     9ce:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9d0:	03 96       	adiw	r24, 0x03	; 3
     9d2:	92 83       	std	Z+2, r25	; 0x02
     9d4:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     9d6:	2f ef       	ldi	r18, 0xFF	; 255
     9d8:	3f ef       	ldi	r19, 0xFF	; 255
     9da:	34 83       	std	Z+4, r19	; 0x04
     9dc:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9de:	96 83       	std	Z+6, r25	; 0x06
     9e0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9e2:	90 87       	std	Z+8, r25	; 0x08
     9e4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     9e6:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     9e8:	08 95       	ret

000009ea <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     9ea:	fc 01       	movw	r30, r24
     9ec:	11 86       	std	Z+9, r1	; 0x09
     9ee:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     9f0:	08 95       	ret

000009f2 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     9f2:	cf 93       	push	r28
     9f4:	df 93       	push	r29
     9f6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     9f8:	dc 01       	movw	r26, r24
     9fa:	11 96       	adiw	r26, 0x01	; 1
     9fc:	cd 91       	ld	r28, X+
     9fe:	dc 91       	ld	r29, X
     a00:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     a02:	d3 83       	std	Z+3, r29	; 0x03
     a04:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     a06:	2c 81       	ldd	r18, Y+4	; 0x04
     a08:	3d 81       	ldd	r19, Y+5	; 0x05
     a0a:	35 83       	std	Z+5, r19	; 0x05
     a0c:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     a0e:	ac 81       	ldd	r26, Y+4	; 0x04
     a10:	bd 81       	ldd	r27, Y+5	; 0x05
     a12:	13 96       	adiw	r26, 0x03	; 3
     a14:	7c 93       	st	X, r23
     a16:	6e 93       	st	-X, r22
     a18:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     a1a:	7d 83       	std	Y+5, r23	; 0x05
     a1c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a1e:	91 87       	std	Z+9, r25	; 0x09
     a20:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     a22:	fc 01       	movw	r30, r24
     a24:	20 81       	ld	r18, Z
     a26:	2f 5f       	subi	r18, 0xFF	; 255
     a28:	20 83       	st	Z, r18
}
     a2a:	df 91       	pop	r29
     a2c:	cf 91       	pop	r28
     a2e:	08 95       	ret

00000a30 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     a30:	cf 93       	push	r28
     a32:	df 93       	push	r29
     a34:	ac 01       	movw	r20, r24
     a36:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     a38:	28 81       	ld	r18, Y
     a3a:	39 81       	ldd	r19, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     a3c:	8f ef       	ldi	r24, 0xFF	; 255
     a3e:	2f 3f       	cpi	r18, 0xFF	; 255
     a40:	38 07       	cpc	r19, r24
     a42:	21 f4       	brne	.+8      	; 0xa4c <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     a44:	fa 01       	movw	r30, r20
     a46:	a7 81       	ldd	r26, Z+7	; 0x07
     a48:	b0 85       	ldd	r27, Z+8	; 0x08
     a4a:	0d c0       	rjmp	.+26     	; 0xa66 <vListInsert+0x36>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a4c:	da 01       	movw	r26, r20
     a4e:	13 96       	adiw	r26, 0x03	; 3
     a50:	01 c0       	rjmp	.+2      	; 0xa54 <vListInsert+0x24>
     a52:	df 01       	movw	r26, r30
     a54:	12 96       	adiw	r26, 0x02	; 2
     a56:	ed 91       	ld	r30, X+
     a58:	fc 91       	ld	r31, X
     a5a:	13 97       	sbiw	r26, 0x03	; 3
     a5c:	80 81       	ld	r24, Z
     a5e:	91 81       	ldd	r25, Z+1	; 0x01
     a60:	28 17       	cp	r18, r24
     a62:	39 07       	cpc	r19, r25
     a64:	b0 f7       	brcc	.-20     	; 0xa52 <vListInsert+0x22>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     a66:	12 96       	adiw	r26, 0x02	; 2
     a68:	ed 91       	ld	r30, X+
     a6a:	fc 91       	ld	r31, X
     a6c:	13 97       	sbiw	r26, 0x03	; 3
     a6e:	fb 83       	std	Y+3, r31	; 0x03
     a70:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     a72:	d5 83       	std	Z+5, r29	; 0x05
     a74:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     a76:	bd 83       	std	Y+5, r27	; 0x05
     a78:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     a7a:	13 96       	adiw	r26, 0x03	; 3
     a7c:	dc 93       	st	X, r29
     a7e:	ce 93       	st	-X, r28
     a80:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a82:	59 87       	std	Y+9, r21	; 0x09
     a84:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     a86:	fa 01       	movw	r30, r20
     a88:	80 81       	ld	r24, Z
     a8a:	8f 5f       	subi	r24, 0xFF	; 255
     a8c:	80 83       	st	Z, r24
}
     a8e:	df 91       	pop	r29
     a90:	cf 91       	pop	r28
     a92:	08 95       	ret

00000a94 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     a94:	cf 93       	push	r28
     a96:	df 93       	push	r29
     a98:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     a9a:	c0 85       	ldd	r28, Z+8	; 0x08
     a9c:	d1 85       	ldd	r29, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a9e:	a2 81       	ldd	r26, Z+2	; 0x02
     aa0:	b3 81       	ldd	r27, Z+3	; 0x03
     aa2:	84 81       	ldd	r24, Z+4	; 0x04
     aa4:	95 81       	ldd	r25, Z+5	; 0x05
     aa6:	15 96       	adiw	r26, 0x05	; 5
     aa8:	9c 93       	st	X, r25
     aaa:	8e 93       	st	-X, r24
     aac:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     aae:	a4 81       	ldd	r26, Z+4	; 0x04
     ab0:	b5 81       	ldd	r27, Z+5	; 0x05
     ab2:	82 81       	ldd	r24, Z+2	; 0x02
     ab4:	93 81       	ldd	r25, Z+3	; 0x03
     ab6:	13 96       	adiw	r26, 0x03	; 3
     ab8:	9c 93       	st	X, r25
     aba:	8e 93       	st	-X, r24
     abc:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     abe:	a9 81       	ldd	r26, Y+1	; 0x01
     ac0:	ba 81       	ldd	r27, Y+2	; 0x02
     ac2:	ae 17       	cp	r26, r30
     ac4:	bf 07       	cpc	r27, r31
     ac6:	31 f4       	brne	.+12     	; 0xad4 <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     ac8:	14 96       	adiw	r26, 0x04	; 4
     aca:	8d 91       	ld	r24, X+
     acc:	9c 91       	ld	r25, X
     ace:	15 97       	sbiw	r26, 0x05	; 5
     ad0:	9a 83       	std	Y+2, r25	; 0x02
     ad2:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     ad4:	11 86       	std	Z+9, r1	; 0x09
     ad6:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     ad8:	88 81       	ld	r24, Y
     ada:	81 50       	subi	r24, 0x01	; 1
     adc:	88 83       	st	Y, r24

	return pxList->uxNumberOfItems;
}
     ade:	df 91       	pop	r29
     ae0:	cf 91       	pop	r28
     ae2:	08 95       	ret

00000ae4 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     ae4:	21 e1       	ldi	r18, 0x11	; 17
     ae6:	fc 01       	movw	r30, r24
     ae8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     aea:	31 97       	sbiw	r30, 0x01	; 1
     aec:	32 e2       	ldi	r19, 0x22	; 34
     aee:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     af0:	fc 01       	movw	r30, r24
     af2:	32 97       	sbiw	r30, 0x02	; 2
     af4:	a3 e3       	ldi	r26, 0x33	; 51
     af6:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     af8:	fc 01       	movw	r30, r24
     afa:	33 97       	sbiw	r30, 0x03	; 3
     afc:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     afe:	fc 01       	movw	r30, r24
     b00:	34 97       	sbiw	r30, 0x04	; 4
     b02:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     b04:	fc 01       	movw	r30, r24
     b06:	35 97       	sbiw	r30, 0x05	; 5
     b08:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     b0a:	fc 01       	movw	r30, r24
     b0c:	36 97       	sbiw	r30, 0x06	; 6
     b0e:	60 e8       	ldi	r22, 0x80	; 128
     b10:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     b12:	fc 01       	movw	r30, r24
     b14:	37 97       	sbiw	r30, 0x07	; 7
     b16:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     b18:	fc 01       	movw	r30, r24
     b1a:	38 97       	sbiw	r30, 0x08	; 8
     b1c:	62 e0       	ldi	r22, 0x02	; 2
     b1e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     b20:	fc 01       	movw	r30, r24
     b22:	39 97       	sbiw	r30, 0x09	; 9
     b24:	63 e0       	ldi	r22, 0x03	; 3
     b26:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     b28:	fc 01       	movw	r30, r24
     b2a:	3a 97       	sbiw	r30, 0x0a	; 10
     b2c:	64 e0       	ldi	r22, 0x04	; 4
     b2e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     b30:	fc 01       	movw	r30, r24
     b32:	3b 97       	sbiw	r30, 0x0b	; 11
     b34:	65 e0       	ldi	r22, 0x05	; 5
     b36:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     b38:	fc 01       	movw	r30, r24
     b3a:	3c 97       	sbiw	r30, 0x0c	; 12
     b3c:	66 e0       	ldi	r22, 0x06	; 6
     b3e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     b40:	fc 01       	movw	r30, r24
     b42:	3d 97       	sbiw	r30, 0x0d	; 13
     b44:	67 e0       	ldi	r22, 0x07	; 7
     b46:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     b48:	fc 01       	movw	r30, r24
     b4a:	3e 97       	sbiw	r30, 0x0e	; 14
     b4c:	68 e0       	ldi	r22, 0x08	; 8
     b4e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     b50:	fc 01       	movw	r30, r24
     b52:	3f 97       	sbiw	r30, 0x0f	; 15
     b54:	69 e0       	ldi	r22, 0x09	; 9
     b56:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     b58:	fc 01       	movw	r30, r24
     b5a:	70 97       	sbiw	r30, 0x10	; 16
     b5c:	60 e1       	ldi	r22, 0x10	; 16
     b5e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     b60:	fc 01       	movw	r30, r24
     b62:	71 97       	sbiw	r30, 0x11	; 17
     b64:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     b66:	fc 01       	movw	r30, r24
     b68:	72 97       	sbiw	r30, 0x12	; 18
     b6a:	22 e1       	ldi	r18, 0x12	; 18
     b6c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     b6e:	fc 01       	movw	r30, r24
     b70:	73 97       	sbiw	r30, 0x13	; 19
     b72:	23 e1       	ldi	r18, 0x13	; 19
     b74:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     b76:	fc 01       	movw	r30, r24
     b78:	74 97       	sbiw	r30, 0x14	; 20
     b7a:	24 e1       	ldi	r18, 0x14	; 20
     b7c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     b7e:	fc 01       	movw	r30, r24
     b80:	75 97       	sbiw	r30, 0x15	; 21
     b82:	25 e1       	ldi	r18, 0x15	; 21
     b84:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     b86:	fc 01       	movw	r30, r24
     b88:	76 97       	sbiw	r30, 0x16	; 22
     b8a:	26 e1       	ldi	r18, 0x16	; 22
     b8c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     b8e:	fc 01       	movw	r30, r24
     b90:	77 97       	sbiw	r30, 0x17	; 23
     b92:	27 e1       	ldi	r18, 0x17	; 23
     b94:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     b96:	fc 01       	movw	r30, r24
     b98:	78 97       	sbiw	r30, 0x18	; 24
     b9a:	28 e1       	ldi	r18, 0x18	; 24
     b9c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     b9e:	fc 01       	movw	r30, r24
     ba0:	79 97       	sbiw	r30, 0x19	; 25
     ba2:	29 e1       	ldi	r18, 0x19	; 25
     ba4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     ba6:	fc 01       	movw	r30, r24
     ba8:	7a 97       	sbiw	r30, 0x1a	; 26
     baa:	20 e2       	ldi	r18, 0x20	; 32
     bac:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     bae:	fc 01       	movw	r30, r24
     bb0:	7b 97       	sbiw	r30, 0x1b	; 27
     bb2:	21 e2       	ldi	r18, 0x21	; 33
     bb4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     bb6:	fc 01       	movw	r30, r24
     bb8:	7c 97       	sbiw	r30, 0x1c	; 28
     bba:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     bbc:	fc 01       	movw	r30, r24
     bbe:	7d 97       	sbiw	r30, 0x1d	; 29
     bc0:	23 e2       	ldi	r18, 0x23	; 35
     bc2:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     bc4:	fc 01       	movw	r30, r24
     bc6:	7e 97       	sbiw	r30, 0x1e	; 30
     bc8:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     bca:	fc 01       	movw	r30, r24
     bcc:	7f 97       	sbiw	r30, 0x1f	; 31
     bce:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     bd0:	fc 01       	movw	r30, r24
     bd2:	b0 97       	sbiw	r30, 0x20	; 32
     bd4:	26 e2       	ldi	r18, 0x26	; 38
     bd6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     bd8:	fc 01       	movw	r30, r24
     bda:	b1 97       	sbiw	r30, 0x21	; 33
     bdc:	27 e2       	ldi	r18, 0x27	; 39
     bde:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     be0:	fc 01       	movw	r30, r24
     be2:	b2 97       	sbiw	r30, 0x22	; 34
     be4:	28 e2       	ldi	r18, 0x28	; 40
     be6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     be8:	fc 01       	movw	r30, r24
     bea:	b3 97       	sbiw	r30, 0x23	; 35
     bec:	29 e2       	ldi	r18, 0x29	; 41
     bee:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     bf0:	fc 01       	movw	r30, r24
     bf2:	b4 97       	sbiw	r30, 0x24	; 36
     bf4:	20 e3       	ldi	r18, 0x30	; 48
     bf6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     bf8:	fc 01       	movw	r30, r24
     bfa:	b5 97       	sbiw	r30, 0x25	; 37
     bfc:	21 e3       	ldi	r18, 0x31	; 49
     bfe:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     c00:	86 97       	sbiw	r24, 0x26	; 38
}
     c02:	08 95       	ret

00000c04 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     c04:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
     c06:	8c e7       	ldi	r24, 0x7C	; 124
     c08:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     c0a:	8b e0       	ldi	r24, 0x0B	; 11
     c0c:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     c0e:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     c10:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     c12:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     c14:	a0 91 e1 03 	lds	r26, 0x03E1
     c18:	b0 91 e2 03 	lds	r27, 0x03E2
     c1c:	cd 91       	ld	r28, X+
     c1e:	cd bf       	out	0x3d, r28	; 61
     c20:	dd 91       	ld	r29, X+
     c22:	de bf       	out	0x3e, r29	; 62
     c24:	ff 91       	pop	r31
     c26:	ef 91       	pop	r30
     c28:	df 91       	pop	r29
     c2a:	cf 91       	pop	r28
     c2c:	bf 91       	pop	r27
     c2e:	af 91       	pop	r26
     c30:	9f 91       	pop	r25
     c32:	8f 91       	pop	r24
     c34:	7f 91       	pop	r23
     c36:	6f 91       	pop	r22
     c38:	5f 91       	pop	r21
     c3a:	4f 91       	pop	r20
     c3c:	3f 91       	pop	r19
     c3e:	2f 91       	pop	r18
     c40:	1f 91       	pop	r17
     c42:	0f 91       	pop	r16
     c44:	ff 90       	pop	r15
     c46:	ef 90       	pop	r14
     c48:	df 90       	pop	r13
     c4a:	cf 90       	pop	r12
     c4c:	bf 90       	pop	r11
     c4e:	af 90       	pop	r10
     c50:	9f 90       	pop	r9
     c52:	8f 90       	pop	r8
     c54:	7f 90       	pop	r7
     c56:	6f 90       	pop	r6
     c58:	5f 90       	pop	r5
     c5a:	4f 90       	pop	r4
     c5c:	3f 90       	pop	r3
     c5e:	2f 90       	pop	r2
     c60:	1f 90       	pop	r1
     c62:	0f 90       	pop	r0
     c64:	0f be       	out	0x3f, r0	; 63
     c66:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     c68:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     c6a:	81 e0       	ldi	r24, 0x01	; 1
     c6c:	08 95       	ret

00000c6e <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     c6e:	08 95       	ret

00000c70 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     c70:	0f 92       	push	r0
     c72:	0f b6       	in	r0, 0x3f	; 63
     c74:	f8 94       	cli
     c76:	0f 92       	push	r0
     c78:	1f 92       	push	r1
     c7a:	11 24       	eor	r1, r1
     c7c:	2f 92       	push	r2
     c7e:	3f 92       	push	r3
     c80:	4f 92       	push	r4
     c82:	5f 92       	push	r5
     c84:	6f 92       	push	r6
     c86:	7f 92       	push	r7
     c88:	8f 92       	push	r8
     c8a:	9f 92       	push	r9
     c8c:	af 92       	push	r10
     c8e:	bf 92       	push	r11
     c90:	cf 92       	push	r12
     c92:	df 92       	push	r13
     c94:	ef 92       	push	r14
     c96:	ff 92       	push	r15
     c98:	0f 93       	push	r16
     c9a:	1f 93       	push	r17
     c9c:	2f 93       	push	r18
     c9e:	3f 93       	push	r19
     ca0:	4f 93       	push	r20
     ca2:	5f 93       	push	r21
     ca4:	6f 93       	push	r22
     ca6:	7f 93       	push	r23
     ca8:	8f 93       	push	r24
     caa:	9f 93       	push	r25
     cac:	af 93       	push	r26
     cae:	bf 93       	push	r27
     cb0:	cf 93       	push	r28
     cb2:	df 93       	push	r29
     cb4:	ef 93       	push	r30
     cb6:	ff 93       	push	r31
     cb8:	a0 91 e1 03 	lds	r26, 0x03E1
     cbc:	b0 91 e2 03 	lds	r27, 0x03E2
     cc0:	0d b6       	in	r0, 0x3d	; 61
     cc2:	0d 92       	st	X+, r0
     cc4:	0e b6       	in	r0, 0x3e	; 62
     cc6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     cc8:	0e 94 ec 13 	call	0x27d8	; 0x27d8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     ccc:	a0 91 e1 03 	lds	r26, 0x03E1
     cd0:	b0 91 e2 03 	lds	r27, 0x03E2
     cd4:	cd 91       	ld	r28, X+
     cd6:	cd bf       	out	0x3d, r28	; 61
     cd8:	dd 91       	ld	r29, X+
     cda:	de bf       	out	0x3e, r29	; 62
     cdc:	ff 91       	pop	r31
     cde:	ef 91       	pop	r30
     ce0:	df 91       	pop	r29
     ce2:	cf 91       	pop	r28
     ce4:	bf 91       	pop	r27
     ce6:	af 91       	pop	r26
     ce8:	9f 91       	pop	r25
     cea:	8f 91       	pop	r24
     cec:	7f 91       	pop	r23
     cee:	6f 91       	pop	r22
     cf0:	5f 91       	pop	r21
     cf2:	4f 91       	pop	r20
     cf4:	3f 91       	pop	r19
     cf6:	2f 91       	pop	r18
     cf8:	1f 91       	pop	r17
     cfa:	0f 91       	pop	r16
     cfc:	ff 90       	pop	r15
     cfe:	ef 90       	pop	r14
     d00:	df 90       	pop	r13
     d02:	cf 90       	pop	r12
     d04:	bf 90       	pop	r11
     d06:	af 90       	pop	r10
     d08:	9f 90       	pop	r9
     d0a:	8f 90       	pop	r8
     d0c:	7f 90       	pop	r7
     d0e:	6f 90       	pop	r6
     d10:	5f 90       	pop	r5
     d12:	4f 90       	pop	r4
     d14:	3f 90       	pop	r3
     d16:	2f 90       	pop	r2
     d18:	1f 90       	pop	r1
     d1a:	0f 90       	pop	r0
     d1c:	0f be       	out	0x3f, r0	; 63
     d1e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     d20:	08 95       	ret

00000d22 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     d22:	0f 92       	push	r0
     d24:	0f b6       	in	r0, 0x3f	; 63
     d26:	f8 94       	cli
     d28:	0f 92       	push	r0
     d2a:	1f 92       	push	r1
     d2c:	11 24       	eor	r1, r1
     d2e:	2f 92       	push	r2
     d30:	3f 92       	push	r3
     d32:	4f 92       	push	r4
     d34:	5f 92       	push	r5
     d36:	6f 92       	push	r6
     d38:	7f 92       	push	r7
     d3a:	8f 92       	push	r8
     d3c:	9f 92       	push	r9
     d3e:	af 92       	push	r10
     d40:	bf 92       	push	r11
     d42:	cf 92       	push	r12
     d44:	df 92       	push	r13
     d46:	ef 92       	push	r14
     d48:	ff 92       	push	r15
     d4a:	0f 93       	push	r16
     d4c:	1f 93       	push	r17
     d4e:	2f 93       	push	r18
     d50:	3f 93       	push	r19
     d52:	4f 93       	push	r20
     d54:	5f 93       	push	r21
     d56:	6f 93       	push	r22
     d58:	7f 93       	push	r23
     d5a:	8f 93       	push	r24
     d5c:	9f 93       	push	r25
     d5e:	af 93       	push	r26
     d60:	bf 93       	push	r27
     d62:	cf 93       	push	r28
     d64:	df 93       	push	r29
     d66:	ef 93       	push	r30
     d68:	ff 93       	push	r31
     d6a:	a0 91 e1 03 	lds	r26, 0x03E1
     d6e:	b0 91 e2 03 	lds	r27, 0x03E2
     d72:	0d b6       	in	r0, 0x3d	; 61
     d74:	0d 92       	st	X+, r0
     d76:	0e b6       	in	r0, 0x3e	; 62
     d78:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     d7a:	0e 94 3c 12 	call	0x2478	; 0x2478 <xTaskIncrementTick>
     d7e:	88 23       	and	r24, r24
     d80:	11 f0       	breq	.+4      	; 0xd86 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     d82:	0e 94 ec 13 	call	0x27d8	; 0x27d8 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     d86:	a0 91 e1 03 	lds	r26, 0x03E1
     d8a:	b0 91 e2 03 	lds	r27, 0x03E2
     d8e:	cd 91       	ld	r28, X+
     d90:	cd bf       	out	0x3d, r28	; 61
     d92:	dd 91       	ld	r29, X+
     d94:	de bf       	out	0x3e, r29	; 62
     d96:	ff 91       	pop	r31
     d98:	ef 91       	pop	r30
     d9a:	df 91       	pop	r29
     d9c:	cf 91       	pop	r28
     d9e:	bf 91       	pop	r27
     da0:	af 91       	pop	r26
     da2:	9f 91       	pop	r25
     da4:	8f 91       	pop	r24
     da6:	7f 91       	pop	r23
     da8:	6f 91       	pop	r22
     daa:	5f 91       	pop	r21
     dac:	4f 91       	pop	r20
     dae:	3f 91       	pop	r19
     db0:	2f 91       	pop	r18
     db2:	1f 91       	pop	r17
     db4:	0f 91       	pop	r16
     db6:	ff 90       	pop	r15
     db8:	ef 90       	pop	r14
     dba:	df 90       	pop	r13
     dbc:	cf 90       	pop	r12
     dbe:	bf 90       	pop	r11
     dc0:	af 90       	pop	r10
     dc2:	9f 90       	pop	r9
     dc4:	8f 90       	pop	r8
     dc6:	7f 90       	pop	r7
     dc8:	6f 90       	pop	r6
     dca:	5f 90       	pop	r5
     dcc:	4f 90       	pop	r4
     dce:	3f 90       	pop	r3
     dd0:	2f 90       	pop	r2
     dd2:	1f 90       	pop	r1
     dd4:	0f 90       	pop	r0
     dd6:	0f be       	out	0x3f, r0	; 63
     dd8:	0f 90       	pop	r0

	asm volatile ( "ret" );
     dda:	08 95       	ret

00000ddc <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     ddc:	0e 94 91 06 	call	0xd22	; 0xd22 <vPortYieldFromTick>
		asm volatile ( "reti" );
     de0:	18 95       	reti

00000de2 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     de2:	0f b6       	in	r0, 0x3f	; 63
     de4:	f8 94       	cli
     de6:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     de8:	fc 01       	movw	r30, r24
     dea:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     dec:	0f 90       	pop	r0
     dee:	0f be       	out	0x3f, r0	; 63

	taskENTER_CRITICAL();
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
		{
			xReturn = pdTRUE;
     df0:	81 e0       	ldi	r24, 0x01	; 1
     df2:	91 11       	cpse	r25, r1
     df4:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}
     df6:	08 95       	ret

00000df8 <prvCopyDataFromQueue>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     df8:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     dfa:	44 8d       	ldd	r20, Z+28	; 0x1c
     dfc:	44 23       	and	r20, r20
     dfe:	c1 f0       	breq	.+48     	; 0xe30 <prvCopyDataFromQueue+0x38>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     e00:	26 81       	ldd	r18, Z+6	; 0x06
     e02:	37 81       	ldd	r19, Z+7	; 0x07
     e04:	24 0f       	add	r18, r20
     e06:	31 1d       	adc	r19, r1
     e08:	37 83       	std	Z+7, r19	; 0x07
     e0a:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     e0c:	a2 81       	ldd	r26, Z+2	; 0x02
     e0e:	b3 81       	ldd	r27, Z+3	; 0x03
     e10:	2a 17       	cp	r18, r26
     e12:	3b 07       	cpc	r19, r27
     e14:	20 f0       	brcs	.+8      	; 0xe1e <prvCopyDataFromQueue+0x26>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     e16:	20 81       	ld	r18, Z
     e18:	31 81       	ldd	r19, Z+1	; 0x01
     e1a:	37 83       	std	Z+7, r19	; 0x07
     e1c:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     e1e:	36 81       	ldd	r19, Z+6	; 0x06
     e20:	27 81       	ldd	r18, Z+7	; 0x07
     e22:	86 2f       	mov	r24, r22
     e24:	97 2f       	mov	r25, r23
     e26:	63 2f       	mov	r22, r19
     e28:	72 2f       	mov	r23, r18
     e2a:	50 e0       	ldi	r21, 0x00	; 0
     e2c:	0e 94 a1 19 	call	0x3342	; 0x3342 <memcpy>
     e30:	08 95       	ret

00000e32 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     e32:	ef 92       	push	r14
     e34:	ff 92       	push	r15
     e36:	0f 93       	push	r16
     e38:	1f 93       	push	r17
     e3a:	cf 93       	push	r28
     e3c:	8c 01       	movw	r16, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     e3e:	0f b6       	in	r0, 0x3f	; 63
     e40:	f8 94       	cli
     e42:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
     e44:	fc 01       	movw	r30, r24
     e46:	c6 8d       	ldd	r28, Z+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     e48:	1c 16       	cp	r1, r28
     e4a:	cc f4       	brge	.+50     	; 0xe7e <prvUnlockQueue+0x4c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e4c:	81 89       	ldd	r24, Z+17	; 0x11
     e4e:	88 23       	and	r24, r24
     e50:	31 f4       	brne	.+12     	; 0xe5e <prvUnlockQueue+0x2c>
     e52:	15 c0       	rjmp	.+42     	; 0xe7e <prvUnlockQueue+0x4c>
     e54:	f8 01       	movw	r30, r16
     e56:	81 89       	ldd	r24, Z+17	; 0x11
     e58:	88 23       	and	r24, r24
     e5a:	41 f4       	brne	.+16     	; 0xe6c <prvUnlockQueue+0x3a>
     e5c:	10 c0       	rjmp	.+32     	; 0xe7e <prvUnlockQueue+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e5e:	0f 2e       	mov	r0, r31
     e60:	f1 e1       	ldi	r31, 0x11	; 17
     e62:	ef 2e       	mov	r14, r31
     e64:	ff 24       	eor	r15, r15
     e66:	f0 2d       	mov	r31, r0
     e68:	e0 0e       	add	r14, r16
     e6a:	f1 1e       	adc	r15, r17
     e6c:	c7 01       	movw	r24, r14
     e6e:	0e 94 c2 14 	call	0x2984	; 0x2984 <xTaskRemoveFromEventList>
     e72:	88 23       	and	r24, r24
     e74:	11 f0       	breq	.+4      	; 0xe7a <prvUnlockQueue+0x48>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
     e76:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
     e7a:	c1 50       	subi	r28, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     e7c:	59 f7       	brne	.-42     	; 0xe54 <prvUnlockQueue+0x22>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
     e7e:	8f ef       	ldi	r24, 0xFF	; 255
     e80:	f8 01       	movw	r30, r16
     e82:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     e84:	0f 90       	pop	r0
     e86:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     e88:	0f b6       	in	r0, 0x3f	; 63
     e8a:	f8 94       	cli
     e8c:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
     e8e:	f8 01       	movw	r30, r16
     e90:	c5 8d       	ldd	r28, Z+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
     e92:	1c 16       	cp	r1, r28
     e94:	c4 f4       	brge	.+48     	; 0xec6 <prvUnlockQueue+0x94>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     e96:	80 85       	ldd	r24, Z+8	; 0x08
     e98:	88 23       	and	r24, r24
     e9a:	31 f4       	brne	.+12     	; 0xea8 <prvUnlockQueue+0x76>
     e9c:	14 c0       	rjmp	.+40     	; 0xec6 <prvUnlockQueue+0x94>
     e9e:	f8 01       	movw	r30, r16
     ea0:	80 85       	ldd	r24, Z+8	; 0x08
     ea2:	88 23       	and	r24, r24
     ea4:	39 f4       	brne	.+14     	; 0xeb4 <prvUnlockQueue+0x82>
     ea6:	0f c0       	rjmp	.+30     	; 0xec6 <prvUnlockQueue+0x94>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ea8:	ee 24       	eor	r14, r14
     eaa:	ff 24       	eor	r15, r15
     eac:	68 94       	set
     eae:	e3 f8       	bld	r14, 3
     eb0:	e0 0e       	add	r14, r16
     eb2:	f1 1e       	adc	r15, r17
     eb4:	c7 01       	movw	r24, r14
     eb6:	0e 94 c2 14 	call	0x2984	; 0x2984 <xTaskRemoveFromEventList>
     eba:	88 23       	and	r24, r24
     ebc:	11 f0       	breq	.+4      	; 0xec2 <prvUnlockQueue+0x90>
				{
					vTaskMissedYield();
     ebe:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
     ec2:	c1 50       	subi	r28, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
     ec4:	61 f7       	brne	.-40     	; 0xe9e <prvUnlockQueue+0x6c>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
     ec6:	8f ef       	ldi	r24, 0xFF	; 255
     ec8:	f8 01       	movw	r30, r16
     eca:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     ecc:	0f 90       	pop	r0
     ece:	0f be       	out	0x3f, r0	; 63
}
     ed0:	cf 91       	pop	r28
     ed2:	1f 91       	pop	r17
     ed4:	0f 91       	pop	r16
     ed6:	ff 90       	pop	r15
     ed8:	ef 90       	pop	r14
     eda:	08 95       	ret

00000edc <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     edc:	0f 93       	push	r16
     ede:	1f 93       	push	r17
     ee0:	cf 93       	push	r28
     ee2:	df 93       	push	r29
     ee4:	ec 01       	movw	r28, r24
     ee6:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     ee8:	0a 8d       	ldd	r16, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     eea:	4c 8d       	ldd	r20, Y+28	; 0x1c
     eec:	44 23       	and	r20, r20
     eee:	61 f4       	brne	.+24     	; 0xf08 <prvCopyDataToQueue+0x2c>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     ef0:	88 81       	ld	r24, Y
     ef2:	99 81       	ldd	r25, Y+1	; 0x01
     ef4:	00 97       	sbiw	r24, 0x00	; 0
     ef6:	09 f0       	breq	.+2      	; 0xefa <prvCopyDataToQueue+0x1e>
     ef8:	42 c0       	rjmp	.+132    	; 0xf7e <prvCopyDataToQueue+0xa2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     efa:	8a 81       	ldd	r24, Y+2	; 0x02
     efc:	9b 81       	ldd	r25, Y+3	; 0x03
     efe:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     f02:	1b 82       	std	Y+3, r1	; 0x03
     f04:	1a 82       	std	Y+2, r1	; 0x02
     f06:	42 c0       	rjmp	.+132    	; 0xf8c <prvCopyDataToQueue+0xb0>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     f08:	11 23       	and	r17, r17
     f0a:	b9 f4       	brne	.+46     	; 0xf3a <prvCopyDataToQueue+0x5e>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     f0c:	8c 81       	ldd	r24, Y+4	; 0x04
     f0e:	9d 81       	ldd	r25, Y+5	; 0x05
     f10:	50 e0       	ldi	r21, 0x00	; 0
     f12:	0e 94 a1 19 	call	0x3342	; 0x3342 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     f16:	2c 8d       	ldd	r18, Y+28	; 0x1c
     f18:	8c 81       	ldd	r24, Y+4	; 0x04
     f1a:	9d 81       	ldd	r25, Y+5	; 0x05
     f1c:	82 0f       	add	r24, r18
     f1e:	91 1d       	adc	r25, r1
     f20:	9d 83       	std	Y+5, r25	; 0x05
     f22:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     f24:	2a 81       	ldd	r18, Y+2	; 0x02
     f26:	3b 81       	ldd	r19, Y+3	; 0x03
     f28:	82 17       	cp	r24, r18
     f2a:	93 07       	cpc	r25, r19
     f2c:	50 f1       	brcs	.+84     	; 0xf82 <prvCopyDataToQueue+0xa6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     f2e:	88 81       	ld	r24, Y
     f30:	99 81       	ldd	r25, Y+1	; 0x01
     f32:	9d 83       	std	Y+5, r25	; 0x05
     f34:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     f36:	80 e0       	ldi	r24, 0x00	; 0
     f38:	29 c0       	rjmp	.+82     	; 0xf8c <prvCopyDataToQueue+0xb0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     f3a:	8e 81       	ldd	r24, Y+6	; 0x06
     f3c:	9f 81       	ldd	r25, Y+7	; 0x07
     f3e:	50 e0       	ldi	r21, 0x00	; 0
     f40:	0e 94 a1 19 	call	0x3342	; 0x3342 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     f44:	4c 8d       	ldd	r20, Y+28	; 0x1c
     f46:	50 e0       	ldi	r21, 0x00	; 0
     f48:	50 95       	com	r21
     f4a:	41 95       	neg	r20
     f4c:	5f 4f       	sbci	r21, 0xFF	; 255
     f4e:	8e 81       	ldd	r24, Y+6	; 0x06
     f50:	9f 81       	ldd	r25, Y+7	; 0x07
     f52:	84 0f       	add	r24, r20
     f54:	95 1f       	adc	r25, r21
     f56:	9f 83       	std	Y+7, r25	; 0x07
     f58:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     f5a:	28 81       	ld	r18, Y
     f5c:	39 81       	ldd	r19, Y+1	; 0x01
     f5e:	82 17       	cp	r24, r18
     f60:	93 07       	cpc	r25, r19
     f62:	30 f4       	brcc	.+12     	; 0xf70 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     f64:	8a 81       	ldd	r24, Y+2	; 0x02
     f66:	9b 81       	ldd	r25, Y+3	; 0x03
     f68:	84 0f       	add	r24, r20
     f6a:	95 1f       	adc	r25, r21
     f6c:	9f 83       	std	Y+7, r25	; 0x07
     f6e:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     f70:	12 30       	cpi	r17, 0x02	; 2
     f72:	49 f4       	brne	.+18     	; 0xf86 <prvCopyDataToQueue+0xaa>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     f74:	00 23       	and	r16, r16
     f76:	49 f0       	breq	.+18     	; 0xf8a <prvCopyDataToQueue+0xae>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
     f78:	01 50       	subi	r16, 0x01	; 1
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     f7a:	80 e0       	ldi	r24, 0x00	; 0
     f7c:	07 c0       	rjmp	.+14     	; 0xf8c <prvCopyDataToQueue+0xb0>
     f7e:	80 e0       	ldi	r24, 0x00	; 0
     f80:	05 c0       	rjmp	.+10     	; 0xf8c <prvCopyDataToQueue+0xb0>
     f82:	80 e0       	ldi	r24, 0x00	; 0
     f84:	03 c0       	rjmp	.+6      	; 0xf8c <prvCopyDataToQueue+0xb0>
     f86:	80 e0       	ldi	r24, 0x00	; 0
     f88:	01 c0       	rjmp	.+2      	; 0xf8c <prvCopyDataToQueue+0xb0>
     f8a:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
     f8c:	0f 5f       	subi	r16, 0xFF	; 255
     f8e:	0a 8f       	std	Y+26, r16	; 0x1a

	return xReturn;
}
     f90:	df 91       	pop	r29
     f92:	cf 91       	pop	r28
     f94:	1f 91       	pop	r17
     f96:	0f 91       	pop	r16
     f98:	08 95       	ret

00000f9a <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     f9a:	cf 93       	push	r28
     f9c:	df 93       	push	r29
     f9e:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     fa0:	0f b6       	in	r0, 0x3f	; 63
     fa2:	f8 94       	cli
     fa4:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     fa6:	48 81       	ld	r20, Y
     fa8:	59 81       	ldd	r21, Y+1	; 0x01
     faa:	2b 8d       	ldd	r18, Y+27	; 0x1b
     fac:	30 e0       	ldi	r19, 0x00	; 0
     fae:	ec 8d       	ldd	r30, Y+28	; 0x1c
     fb0:	f0 e0       	ldi	r31, 0x00	; 0
     fb2:	2e 9f       	mul	r18, r30
     fb4:	c0 01       	movw	r24, r0
     fb6:	2f 9f       	mul	r18, r31
     fb8:	90 0d       	add	r25, r0
     fba:	3e 9f       	mul	r19, r30
     fbc:	90 0d       	add	r25, r0
     fbe:	11 24       	eor	r1, r1
     fc0:	84 0f       	add	r24, r20
     fc2:	95 1f       	adc	r25, r21
     fc4:	9b 83       	std	Y+3, r25	; 0x03
     fc6:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     fc8:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     fca:	5d 83       	std	Y+5, r21	; 0x05
     fcc:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     fce:	c9 01       	movw	r24, r18
     fd0:	01 97       	sbiw	r24, 0x01	; 1
     fd2:	e8 9f       	mul	r30, r24
     fd4:	90 01       	movw	r18, r0
     fd6:	e9 9f       	mul	r30, r25
     fd8:	30 0d       	add	r19, r0
     fda:	f8 9f       	mul	r31, r24
     fdc:	30 0d       	add	r19, r0
     fde:	11 24       	eor	r1, r1
     fe0:	24 0f       	add	r18, r20
     fe2:	35 1f       	adc	r19, r21
     fe4:	3f 83       	std	Y+7, r19	; 0x07
     fe6:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
     fe8:	8f ef       	ldi	r24, 0xFF	; 255
     fea:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
     fec:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     fee:	66 23       	and	r22, r22
     ff0:	61 f4       	brne	.+24     	; 0x100a <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ff2:	88 85       	ldd	r24, Y+8	; 0x08
     ff4:	88 23       	and	r24, r24
     ff6:	89 f0       	breq	.+34     	; 0x101a <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ff8:	ce 01       	movw	r24, r28
     ffa:	08 96       	adiw	r24, 0x08	; 8
     ffc:	0e 94 c2 14 	call	0x2984	; 0x2984 <xTaskRemoveFromEventList>
    1000:	88 23       	and	r24, r24
    1002:	59 f0       	breq	.+22     	; 0x101a <xQueueGenericReset+0x80>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1004:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
    1008:	08 c0       	rjmp	.+16     	; 0x101a <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    100a:	ce 01       	movw	r24, r28
    100c:	08 96       	adiw	r24, 0x08	; 8
    100e:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1012:	ce 01       	movw	r24, r28
    1014:	41 96       	adiw	r24, 0x11	; 17
    1016:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    101a:	0f 90       	pop	r0
    101c:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    101e:	81 e0       	ldi	r24, 0x01	; 1
    1020:	df 91       	pop	r29
    1022:	cf 91       	pop	r28
    1024:	08 95       	ret

00001026 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1026:	0f 93       	push	r16
    1028:	1f 93       	push	r17
    102a:	cf 93       	push	r28
    102c:	df 93       	push	r29
    102e:	08 2f       	mov	r16, r24
    1030:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1032:	66 23       	and	r22, r22
    1034:	21 f0       	breq	.+8      	; 0x103e <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1036:	68 9f       	mul	r22, r24
    1038:	c0 01       	movw	r24, r0
    103a:	11 24       	eor	r1, r1
    103c:	02 c0       	rjmp	.+4      	; 0x1042 <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    103e:	80 e0       	ldi	r24, 0x00	; 0
    1040:	90 e0       	ldi	r25, 0x00	; 0
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    1042:	4f 96       	adiw	r24, 0x1f	; 31
    1044:	0e 94 12 02 	call	0x424	; 0x424 <pvPortMalloc>
    1048:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    104a:	00 97       	sbiw	r24, 0x00	; 0
    104c:	71 f0       	breq	.+28     	; 0x106a <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    104e:	11 23       	and	r17, r17
    1050:	19 f4       	brne	.+6      	; 0x1058 <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1052:	99 83       	std	Y+1, r25	; 0x01
    1054:	88 83       	st	Y, r24
    1056:	03 c0       	rjmp	.+6      	; 0x105e <xQueueGenericCreate+0x38>

		if( pxNewQueue != NULL )
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
    1058:	4f 96       	adiw	r24, 0x1f	; 31
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    105a:	99 83       	std	Y+1, r25	; 0x01
    105c:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    105e:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1060:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1062:	ce 01       	movw	r24, r28
    1064:	61 e0       	ldi	r22, 0x01	; 1
    1066:	0e 94 cd 07 	call	0xf9a	; 0xf9a <xQueueGenericReset>

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}
    106a:	8c 2f       	mov	r24, r28
    106c:	9d 2f       	mov	r25, r29
    106e:	df 91       	pop	r29
    1070:	cf 91       	pop	r28
    1072:	1f 91       	pop	r17
    1074:	0f 91       	pop	r16
    1076:	08 95       	ret

00001078 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1078:	8f 92       	push	r8
    107a:	9f 92       	push	r9
    107c:	bf 92       	push	r11
    107e:	cf 92       	push	r12
    1080:	df 92       	push	r13
    1082:	ef 92       	push	r14
    1084:	ff 92       	push	r15
    1086:	0f 93       	push	r16
    1088:	1f 93       	push	r17
    108a:	cf 93       	push	r28
    108c:	df 93       	push	r29
    108e:	00 d0       	rcall	.+0      	; 0x1090 <xQueueGenericSend+0x18>
    1090:	00 d0       	rcall	.+0      	; 0x1092 <xQueueGenericSend+0x1a>
    1092:	0f 92       	push	r0
    1094:	cd b7       	in	r28, 0x3d	; 61
    1096:	de b7       	in	r29, 0x3e	; 62
    1098:	8c 01       	movw	r16, r24
    109a:	4b 01       	movw	r8, r22
    109c:	5d 83       	std	Y+5, r21	; 0x05
    109e:	4c 83       	std	Y+4, r20	; 0x04
    10a0:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    10a2:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    10a4:	bb 24       	eor	r11, r11
    10a6:	b3 94       	inc	r11
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    10a8:	cc 24       	eor	r12, r12
    10aa:	dd 24       	eor	r13, r13
    10ac:	68 94       	set
    10ae:	c3 f8       	bld	r12, 3
    10b0:	c8 0e       	add	r12, r24
    10b2:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    10b4:	0f b6       	in	r0, 0x3f	; 63
    10b6:	f8 94       	cli
    10b8:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    10ba:	f8 01       	movw	r30, r16
    10bc:	92 8d       	ldd	r25, Z+26	; 0x1a
    10be:	83 8d       	ldd	r24, Z+27	; 0x1b
    10c0:	98 17       	cp	r25, r24
    10c2:	18 f0       	brcs	.+6      	; 0x10ca <xQueueGenericSend+0x52>
    10c4:	f2 e0       	ldi	r31, 0x02	; 2
    10c6:	ef 16       	cp	r14, r31
    10c8:	d1 f4       	brne	.+52     	; 0x10fe <xQueueGenericSend+0x86>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    10ca:	c8 01       	movw	r24, r16
    10cc:	b4 01       	movw	r22, r8
    10ce:	4e 2d       	mov	r20, r14
    10d0:	0e 94 6e 07 	call	0xedc	; 0xedc <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10d4:	f8 01       	movw	r30, r16
    10d6:	91 89       	ldd	r25, Z+17	; 0x11
    10d8:	99 23       	and	r25, r25
    10da:	49 f0       	breq	.+18     	; 0x10ee <xQueueGenericSend+0x76>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    10dc:	c8 01       	movw	r24, r16
    10de:	41 96       	adiw	r24, 0x11	; 17
    10e0:	0e 94 c2 14 	call	0x2984	; 0x2984 <xTaskRemoveFromEventList>
    10e4:	88 23       	and	r24, r24
    10e6:	39 f0       	breq	.+14     	; 0x10f6 <xQueueGenericSend+0x7e>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    10e8:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
    10ec:	04 c0       	rjmp	.+8      	; 0x10f6 <xQueueGenericSend+0x7e>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    10ee:	88 23       	and	r24, r24
    10f0:	11 f0       	breq	.+4      	; 0x10f6 <xQueueGenericSend+0x7e>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    10f2:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    10f6:	0f 90       	pop	r0
    10f8:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    10fa:	81 e0       	ldi	r24, 0x01	; 1
    10fc:	52 c0       	rjmp	.+164    	; 0x11a2 <xQueueGenericSend+0x12a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    10fe:	8c 81       	ldd	r24, Y+4	; 0x04
    1100:	9d 81       	ldd	r25, Y+5	; 0x05
    1102:	00 97       	sbiw	r24, 0x00	; 0
    1104:	21 f4       	brne	.+8      	; 0x110e <xQueueGenericSend+0x96>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1106:	0f 90       	pop	r0
    1108:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    110a:	80 e0       	ldi	r24, 0x00	; 0
    110c:	4a c0       	rjmp	.+148    	; 0x11a2 <xQueueGenericSend+0x12a>
				}
				else if( xEntryTimeSet == pdFALSE )
    110e:	ff 20       	and	r15, r15
    1110:	29 f4       	brne	.+10     	; 0x111c <xQueueGenericSend+0xa4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1112:	ce 01       	movw	r24, r28
    1114:	01 96       	adiw	r24, 0x01	; 1
    1116:	0e 94 47 15 	call	0x2a8e	; 0x2a8e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    111a:	fb 2c       	mov	r15, r11
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    111c:	0f 90       	pop	r0
    111e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1120:	0e 94 1c 12 	call	0x2438	; 0x2438 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1124:	0f b6       	in	r0, 0x3f	; 63
    1126:	f8 94       	cli
    1128:	0f 92       	push	r0
    112a:	f8 01       	movw	r30, r16
    112c:	85 8d       	ldd	r24, Z+29	; 0x1d
    112e:	8f 3f       	cpi	r24, 0xFF	; 255
    1130:	09 f4       	brne	.+2      	; 0x1134 <xQueueGenericSend+0xbc>
    1132:	15 8e       	std	Z+29, r1	; 0x1d
    1134:	f8 01       	movw	r30, r16
    1136:	86 8d       	ldd	r24, Z+30	; 0x1e
    1138:	8f 3f       	cpi	r24, 0xFF	; 255
    113a:	09 f4       	brne	.+2      	; 0x113e <xQueueGenericSend+0xc6>
    113c:	16 8e       	std	Z+30, r1	; 0x1e
    113e:	0f 90       	pop	r0
    1140:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1142:	ce 01       	movw	r24, r28
    1144:	01 96       	adiw	r24, 0x01	; 1
    1146:	be 01       	movw	r22, r28
    1148:	6c 5f       	subi	r22, 0xFC	; 252
    114a:	7f 4f       	sbci	r23, 0xFF	; 255
    114c:	0e 94 52 15 	call	0x2aa4	; 0x2aa4 <xTaskCheckForTimeOut>
    1150:	88 23       	and	r24, r24
    1152:	09 f5       	brne	.+66     	; 0x1196 <xQueueGenericSend+0x11e>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1154:	0f b6       	in	r0, 0x3f	; 63
    1156:	f8 94       	cli
    1158:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    115a:	f8 01       	movw	r30, r16
    115c:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    115e:	0f 90       	pop	r0
    1160:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1162:	f8 01       	movw	r30, r16
    1164:	83 8d       	ldd	r24, Z+27	; 0x1b
    1166:	98 17       	cp	r25, r24
    1168:	81 f4       	brne	.+32     	; 0x118a <xQueueGenericSend+0x112>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    116a:	6c 81       	ldd	r22, Y+4	; 0x04
    116c:	7d 81       	ldd	r23, Y+5	; 0x05
    116e:	c6 01       	movw	r24, r12
    1170:	0e 94 97 14 	call	0x292e	; 0x292e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1174:	c8 01       	movw	r24, r16
    1176:	0e 94 19 07 	call	0xe32	; 0xe32 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    117a:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskResumeAll>
    117e:	88 23       	and	r24, r24
    1180:	09 f0       	breq	.+2      	; 0x1184 <xQueueGenericSend+0x10c>
    1182:	98 cf       	rjmp	.-208    	; 0x10b4 <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
    1184:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
    1188:	95 cf       	rjmp	.-214    	; 0x10b4 <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    118a:	c8 01       	movw	r24, r16
    118c:	0e 94 19 07 	call	0xe32	; 0xe32 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1190:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskResumeAll>
    1194:	8f cf       	rjmp	.-226    	; 0x10b4 <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1196:	c8 01       	movw	r24, r16
    1198:	0e 94 19 07 	call	0xe32	; 0xe32 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    119c:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    11a0:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    11a2:	0f 90       	pop	r0
    11a4:	0f 90       	pop	r0
    11a6:	0f 90       	pop	r0
    11a8:	0f 90       	pop	r0
    11aa:	0f 90       	pop	r0
    11ac:	df 91       	pop	r29
    11ae:	cf 91       	pop	r28
    11b0:	1f 91       	pop	r17
    11b2:	0f 91       	pop	r16
    11b4:	ff 90       	pop	r15
    11b6:	ef 90       	pop	r14
    11b8:	df 90       	pop	r13
    11ba:	cf 90       	pop	r12
    11bc:	bf 90       	pop	r11
    11be:	9f 90       	pop	r9
    11c0:	8f 90       	pop	r8
    11c2:	08 95       	ret

000011c4 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    11c4:	cf 93       	push	r28
    11c6:	df 93       	push	r29
    11c8:	48 2f       	mov	r20, r24
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    11ca:	81 e0       	ldi	r24, 0x01	; 1
    11cc:	60 e0       	ldi	r22, 0x00	; 0
    11ce:	0e 94 13 08 	call	0x1026	; 0x1026 <xQueueGenericCreate>
    11d2:	ec 01       	movw	r28, r24

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
		if( pxNewQueue != NULL )
    11d4:	00 97       	sbiw	r24, 0x00	; 0
    11d6:	61 f0       	breq	.+24     	; 0x11f0 <xQueueCreateMutex+0x2c>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    11d8:	1b 82       	std	Y+3, r1	; 0x03
    11da:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    11dc:	19 82       	std	Y+1, r1	; 0x01
    11de:	18 82       	st	Y, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
    11e0:	1e 82       	std	Y+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    11e2:	60 e0       	ldi	r22, 0x00	; 0
    11e4:	70 e0       	ldi	r23, 0x00	; 0
    11e6:	40 e0       	ldi	r20, 0x00	; 0
    11e8:	50 e0       	ldi	r21, 0x00	; 0
    11ea:	20 e0       	ldi	r18, 0x00	; 0
    11ec:	0e 94 3c 08 	call	0x1078	; 0x1078 <xQueueGenericSend>

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
		prvInitialiseMutex( pxNewQueue );

		return pxNewQueue;
	}
    11f0:	8c 2f       	mov	r24, r28
    11f2:	9d 2f       	mov	r25, r29
    11f4:	df 91       	pop	r29
    11f6:	cf 91       	pop	r28
    11f8:	08 95       	ret

000011fa <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    11fa:	ef 92       	push	r14
    11fc:	ff 92       	push	r15
    11fe:	0f 93       	push	r16
    1200:	1f 93       	push	r17
    1202:	cf 93       	push	r28
    1204:	8c 01       	movw	r16, r24
    1206:	7a 01       	movw	r14, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1208:	fc 01       	movw	r30, r24
    120a:	92 8d       	ldd	r25, Z+26	; 0x1a
    120c:	83 8d       	ldd	r24, Z+27	; 0x1b
    120e:	98 17       	cp	r25, r24
    1210:	10 f0       	brcs	.+4      	; 0x1216 <xQueueGenericSendFromISR+0x1c>
    1212:	22 30       	cpi	r18, 0x02	; 2
    1214:	f1 f4       	brne	.+60     	; 0x1252 <xQueueGenericSendFromISR+0x58>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1216:	f8 01       	movw	r30, r16
    1218:	c6 8d       	ldd	r28, Z+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    121a:	c8 01       	movw	r24, r16
    121c:	42 2f       	mov	r20, r18
    121e:	0e 94 6e 07 	call	0xedc	; 0xedc <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1222:	cf 3f       	cpi	r28, 0xFF	; 255
    1224:	89 f4       	brne	.+34     	; 0x1248 <xQueueGenericSendFromISR+0x4e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1226:	f8 01       	movw	r30, r16
    1228:	81 89       	ldd	r24, Z+17	; 0x11
    122a:	88 23       	and	r24, r24
    122c:	a1 f0       	breq	.+40     	; 0x1256 <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    122e:	c8 01       	movw	r24, r16
    1230:	41 96       	adiw	r24, 0x11	; 17
    1232:	0e 94 c2 14 	call	0x2984	; 0x2984 <xTaskRemoveFromEventList>
    1236:	88 23       	and	r24, r24
    1238:	81 f0       	breq	.+32     	; 0x125a <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    123a:	e1 14       	cp	r14, r1
    123c:	f1 04       	cpc	r15, r1
    123e:	79 f0       	breq	.+30     	; 0x125e <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1240:	81 e0       	ldi	r24, 0x01	; 1
    1242:	f7 01       	movw	r30, r14
    1244:	80 83       	st	Z, r24
    1246:	0c c0       	rjmp	.+24     	; 0x1260 <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1248:	cf 5f       	subi	r28, 0xFF	; 255
    124a:	f8 01       	movw	r30, r16
    124c:	c6 8f       	std	Z+30, r28	; 0x1e
			}

			xReturn = pdPASS;
    124e:	81 e0       	ldi	r24, 0x01	; 1
    1250:	07 c0       	rjmp	.+14     	; 0x1260 <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1252:	80 e0       	ldi	r24, 0x00	; 0
    1254:	05 c0       	rjmp	.+10     	; 0x1260 <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    1256:	81 e0       	ldi	r24, 0x01	; 1
    1258:	03 c0       	rjmp	.+6      	; 0x1260 <xQueueGenericSendFromISR+0x66>
    125a:	81 e0       	ldi	r24, 0x01	; 1
    125c:	01 c0       	rjmp	.+2      	; 0x1260 <xQueueGenericSendFromISR+0x66>
    125e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1260:	cf 91       	pop	r28
    1262:	1f 91       	pop	r17
    1264:	0f 91       	pop	r16
    1266:	ff 90       	pop	r15
    1268:	ef 90       	pop	r14
    126a:	08 95       	ret

0000126c <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    126c:	cf 93       	push	r28
    126e:	df 93       	push	r29
    1270:	fc 01       	movw	r30, r24
    1272:	eb 01       	movw	r28, r22
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1274:	82 8d       	ldd	r24, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1276:	93 8d       	ldd	r25, Z+27	; 0x1b
    1278:	89 17       	cp	r24, r25
    127a:	b8 f4       	brcc	.+46     	; 0x12aa <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    127c:	96 8d       	ldd	r25, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    127e:	8f 5f       	subi	r24, 0xFF	; 255
    1280:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1282:	9f 3f       	cpi	r25, 0xFF	; 255
    1284:	71 f4       	brne	.+28     	; 0x12a2 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1286:	81 89       	ldd	r24, Z+17	; 0x11
    1288:	88 23       	and	r24, r24
    128a:	89 f0       	breq	.+34     	; 0x12ae <xQueueGiveFromISR+0x42>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    128c:	cf 01       	movw	r24, r30
    128e:	41 96       	adiw	r24, 0x11	; 17
    1290:	0e 94 c2 14 	call	0x2984	; 0x2984 <xTaskRemoveFromEventList>
    1294:	88 23       	and	r24, r24
    1296:	69 f0       	breq	.+26     	; 0x12b2 <xQueueGiveFromISR+0x46>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1298:	20 97       	sbiw	r28, 0x00	; 0
    129a:	69 f0       	breq	.+26     	; 0x12b6 <xQueueGiveFromISR+0x4a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    129c:	81 e0       	ldi	r24, 0x01	; 1
    129e:	88 83       	st	Y, r24
    12a0:	0b c0       	rjmp	.+22     	; 0x12b8 <xQueueGiveFromISR+0x4c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    12a2:	9f 5f       	subi	r25, 0xFF	; 255
    12a4:	96 8f       	std	Z+30, r25	; 0x1e
			}

			xReturn = pdPASS;
    12a6:	81 e0       	ldi	r24, 0x01	; 1
    12a8:	07 c0       	rjmp	.+14     	; 0x12b8 <xQueueGiveFromISR+0x4c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    12aa:	80 e0       	ldi	r24, 0x00	; 0
    12ac:	05 c0       	rjmp	.+10     	; 0x12b8 <xQueueGiveFromISR+0x4c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    12ae:	81 e0       	ldi	r24, 0x01	; 1
    12b0:	03 c0       	rjmp	.+6      	; 0x12b8 <xQueueGiveFromISR+0x4c>
    12b2:	81 e0       	ldi	r24, 0x01	; 1
    12b4:	01 c0       	rjmp	.+2      	; 0x12b8 <xQueueGiveFromISR+0x4c>
    12b6:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    12b8:	df 91       	pop	r29
    12ba:	cf 91       	pop	r28
    12bc:	08 95       	ret

000012be <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    12be:	8f 92       	push	r8
    12c0:	9f 92       	push	r9
    12c2:	af 92       	push	r10
    12c4:	bf 92       	push	r11
    12c6:	cf 92       	push	r12
    12c8:	df 92       	push	r13
    12ca:	ef 92       	push	r14
    12cc:	ff 92       	push	r15
    12ce:	0f 93       	push	r16
    12d0:	1f 93       	push	r17
    12d2:	cf 93       	push	r28
    12d4:	df 93       	push	r29
    12d6:	00 d0       	rcall	.+0      	; 0x12d8 <xQueueGenericReceive+0x1a>
    12d8:	00 d0       	rcall	.+0      	; 0x12da <xQueueGenericReceive+0x1c>
    12da:	0f 92       	push	r0
    12dc:	cd b7       	in	r28, 0x3d	; 61
    12de:	de b7       	in	r29, 0x3e	; 62
    12e0:	7c 01       	movw	r14, r24
    12e2:	4b 01       	movw	r8, r22
    12e4:	5d 83       	std	Y+5, r21	; 0x05
    12e6:	4c 83       	std	Y+4, r20	; 0x04
    12e8:	c2 2e       	mov	r12, r18
BaseType_t xEntryTimeSet = pdFALSE;
    12ea:	00 e0       	ldi	r16, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    12ec:	dd 24       	eor	r13, r13
    12ee:	d3 94       	inc	r13
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    12f0:	0f 2e       	mov	r0, r31
    12f2:	f1 e1       	ldi	r31, 0x11	; 17
    12f4:	af 2e       	mov	r10, r31
    12f6:	bb 24       	eor	r11, r11
    12f8:	f0 2d       	mov	r31, r0
    12fa:	a8 0e       	add	r10, r24
    12fc:	b9 1e       	adc	r11, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    12fe:	0f b6       	in	r0, 0x3f	; 63
    1300:	f8 94       	cli
    1302:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1304:	f7 01       	movw	r30, r14
    1306:	12 8d       	ldd	r17, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1308:	11 23       	and	r17, r17
    130a:	99 f1       	breq	.+102    	; 0x1372 <xQueueGenericReceive+0xb4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    130c:	a6 80       	ldd	r10, Z+6	; 0x06
    130e:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1310:	c7 01       	movw	r24, r14
    1312:	b4 01       	movw	r22, r8
    1314:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1318:	cc 20       	and	r12, r12
    131a:	c9 f4       	brne	.+50     	; 0x134e <xQueueGenericReceive+0x90>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    131c:	11 50       	subi	r17, 0x01	; 1
    131e:	f7 01       	movw	r30, r14
    1320:	12 8f       	std	Z+26, r17	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1322:	80 81       	ld	r24, Z
    1324:	91 81       	ldd	r25, Z+1	; 0x01
    1326:	00 97       	sbiw	r24, 0x00	; 0
    1328:	29 f4       	brne	.+10     	; 0x1334 <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    132a:	0e 94 47 16 	call	0x2c8e	; 0x2c8e <pvTaskIncrementMutexHeldCount>
    132e:	f7 01       	movw	r30, r14
    1330:	93 83       	std	Z+3, r25	; 0x03
    1332:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1334:	f7 01       	movw	r30, r14
    1336:	80 85       	ldd	r24, Z+8	; 0x08
    1338:	88 23       	and	r24, r24
    133a:	b9 f0       	breq	.+46     	; 0x136a <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    133c:	c7 01       	movw	r24, r14
    133e:	08 96       	adiw	r24, 0x08	; 8
    1340:	0e 94 c2 14 	call	0x2984	; 0x2984 <xTaskRemoveFromEventList>
    1344:	88 23       	and	r24, r24
    1346:	89 f0       	breq	.+34     	; 0x136a <xQueueGenericReceive+0xac>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1348:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
    134c:	0e c0       	rjmp	.+28     	; 0x136a <xQueueGenericReceive+0xac>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    134e:	f7 01       	movw	r30, r14
    1350:	b7 82       	std	Z+7, r11	; 0x07
    1352:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1354:	81 89       	ldd	r24, Z+17	; 0x11
    1356:	88 23       	and	r24, r24
    1358:	41 f0       	breq	.+16     	; 0x136a <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    135a:	c7 01       	movw	r24, r14
    135c:	41 96       	adiw	r24, 0x11	; 17
    135e:	0e 94 c2 14 	call	0x2984	; 0x2984 <xTaskRemoveFromEventList>
    1362:	88 23       	and	r24, r24
    1364:	11 f0       	breq	.+4      	; 0x136a <xQueueGenericReceive+0xac>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1366:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    136a:	0f 90       	pop	r0
    136c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    136e:	81 e0       	ldi	r24, 0x01	; 1
    1370:	61 c0       	rjmp	.+194    	; 0x1434 <xQueueGenericReceive+0x176>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1372:	8c 81       	ldd	r24, Y+4	; 0x04
    1374:	9d 81       	ldd	r25, Y+5	; 0x05
    1376:	00 97       	sbiw	r24, 0x00	; 0
    1378:	21 f4       	brne	.+8      	; 0x1382 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    137a:	0f 90       	pop	r0
    137c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    137e:	80 e0       	ldi	r24, 0x00	; 0
    1380:	59 c0       	rjmp	.+178    	; 0x1434 <xQueueGenericReceive+0x176>
				}
				else if( xEntryTimeSet == pdFALSE )
    1382:	00 23       	and	r16, r16
    1384:	29 f4       	brne	.+10     	; 0x1390 <xQueueGenericReceive+0xd2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1386:	ce 01       	movw	r24, r28
    1388:	01 96       	adiw	r24, 0x01	; 1
    138a:	0e 94 47 15 	call	0x2a8e	; 0x2a8e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    138e:	0d 2d       	mov	r16, r13
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1390:	0f 90       	pop	r0
    1392:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1394:	0e 94 1c 12 	call	0x2438	; 0x2438 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1398:	0f b6       	in	r0, 0x3f	; 63
    139a:	f8 94       	cli
    139c:	0f 92       	push	r0
    139e:	f7 01       	movw	r30, r14
    13a0:	85 8d       	ldd	r24, Z+29	; 0x1d
    13a2:	8f 3f       	cpi	r24, 0xFF	; 255
    13a4:	09 f4       	brne	.+2      	; 0x13a8 <xQueueGenericReceive+0xea>
    13a6:	15 8e       	std	Z+29, r1	; 0x1d
    13a8:	f7 01       	movw	r30, r14
    13aa:	86 8d       	ldd	r24, Z+30	; 0x1e
    13ac:	8f 3f       	cpi	r24, 0xFF	; 255
    13ae:	09 f4       	brne	.+2      	; 0x13b2 <xQueueGenericReceive+0xf4>
    13b0:	16 8e       	std	Z+30, r1	; 0x1e
    13b2:	0f 90       	pop	r0
    13b4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    13b6:	ce 01       	movw	r24, r28
    13b8:	01 96       	adiw	r24, 0x01	; 1
    13ba:	be 01       	movw	r22, r28
    13bc:	6c 5f       	subi	r22, 0xFC	; 252
    13be:	7f 4f       	sbci	r23, 0xFF	; 255
    13c0:	0e 94 52 15 	call	0x2aa4	; 0x2aa4 <xTaskCheckForTimeOut>
    13c4:	88 23       	and	r24, r24
    13c6:	51 f5       	brne	.+84     	; 0x141c <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    13c8:	c7 01       	movw	r24, r14
    13ca:	0e 94 f1 06 	call	0xde2	; 0xde2 <prvIsQueueEmpty>
    13ce:	88 23       	and	r24, r24
    13d0:	f9 f0       	breq	.+62     	; 0x1410 <xQueueGenericReceive+0x152>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    13d2:	f7 01       	movw	r30, r14
    13d4:	80 81       	ld	r24, Z
    13d6:	91 81       	ldd	r25, Z+1	; 0x01
    13d8:	00 97       	sbiw	r24, 0x00	; 0
    13da:	51 f4       	brne	.+20     	; 0x13f0 <xQueueGenericReceive+0x132>
					{
						taskENTER_CRITICAL();
    13dc:	0f b6       	in	r0, 0x3f	; 63
    13de:	f8 94       	cli
    13e0:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    13e2:	f7 01       	movw	r30, r14
    13e4:	82 81       	ldd	r24, Z+2	; 0x02
    13e6:	93 81       	ldd	r25, Z+3	; 0x03
    13e8:	0e 94 90 15 	call	0x2b20	; 0x2b20 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    13ec:	0f 90       	pop	r0
    13ee:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    13f0:	6c 81       	ldd	r22, Y+4	; 0x04
    13f2:	7d 81       	ldd	r23, Y+5	; 0x05
    13f4:	c5 01       	movw	r24, r10
    13f6:	0e 94 97 14 	call	0x292e	; 0x292e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    13fa:	c7 01       	movw	r24, r14
    13fc:	0e 94 19 07 	call	0xe32	; 0xe32 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1400:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskResumeAll>
    1404:	88 23       	and	r24, r24
    1406:	09 f0       	breq	.+2      	; 0x140a <xQueueGenericReceive+0x14c>
    1408:	7a cf       	rjmp	.-268    	; 0x12fe <xQueueGenericReceive+0x40>
				{
					portYIELD_WITHIN_API();
    140a:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
    140e:	77 cf       	rjmp	.-274    	; 0x12fe <xQueueGenericReceive+0x40>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1410:	c7 01       	movw	r24, r14
    1412:	0e 94 19 07 	call	0xe32	; 0xe32 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1416:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskResumeAll>
    141a:	71 cf       	rjmp	.-286    	; 0x12fe <xQueueGenericReceive+0x40>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    141c:	c7 01       	movw	r24, r14
    141e:	0e 94 19 07 	call	0xe32	; 0xe32 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1422:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1426:	c7 01       	movw	r24, r14
    1428:	0e 94 f1 06 	call	0xde2	; 0xde2 <prvIsQueueEmpty>
    142c:	88 23       	and	r24, r24
    142e:	09 f4       	brne	.+2      	; 0x1432 <xQueueGenericReceive+0x174>
    1430:	66 cf       	rjmp	.-308    	; 0x12fe <xQueueGenericReceive+0x40>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1432:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    1434:	0f 90       	pop	r0
    1436:	0f 90       	pop	r0
    1438:	0f 90       	pop	r0
    143a:	0f 90       	pop	r0
    143c:	0f 90       	pop	r0
    143e:	df 91       	pop	r29
    1440:	cf 91       	pop	r28
    1442:	1f 91       	pop	r17
    1444:	0f 91       	pop	r16
    1446:	ff 90       	pop	r15
    1448:	ef 90       	pop	r14
    144a:	df 90       	pop	r13
    144c:	cf 90       	pop	r12
    144e:	bf 90       	pop	r11
    1450:	af 90       	pop	r10
    1452:	9f 90       	pop	r9
    1454:	8f 90       	pop	r8
    1456:	08 95       	ret

00001458 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1458:	ef 92       	push	r14
    145a:	ff 92       	push	r15
    145c:	0f 93       	push	r16
    145e:	1f 93       	push	r17
    1460:	cf 93       	push	r28
    1462:	df 93       	push	r29
    1464:	8c 01       	movw	r16, r24
    1466:	7a 01       	movw	r14, r20
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1468:	fc 01       	movw	r30, r24
    146a:	c2 8d       	ldd	r28, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    146c:	cc 23       	and	r28, r28
    146e:	e9 f0       	breq	.+58     	; 0x14aa <xQueueReceiveFromISR+0x52>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1470:	d5 8d       	ldd	r29, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1472:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1476:	c1 50       	subi	r28, 0x01	; 1
    1478:	f8 01       	movw	r30, r16
    147a:	c2 8f       	std	Z+26, r28	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    147c:	df 3f       	cpi	r29, 0xFF	; 255
    147e:	81 f4       	brne	.+32     	; 0x14a0 <xQueueReceiveFromISR+0x48>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1480:	80 85       	ldd	r24, Z+8	; 0x08
    1482:	88 23       	and	r24, r24
    1484:	a1 f0       	breq	.+40     	; 0x14ae <xQueueReceiveFromISR+0x56>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1486:	c8 01       	movw	r24, r16
    1488:	08 96       	adiw	r24, 0x08	; 8
    148a:	0e 94 c2 14 	call	0x2984	; 0x2984 <xTaskRemoveFromEventList>
    148e:	88 23       	and	r24, r24
    1490:	81 f0       	breq	.+32     	; 0x14b2 <xQueueReceiveFromISR+0x5a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1492:	e1 14       	cp	r14, r1
    1494:	f1 04       	cpc	r15, r1
    1496:	79 f0       	breq	.+30     	; 0x14b6 <xQueueReceiveFromISR+0x5e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1498:	81 e0       	ldi	r24, 0x01	; 1
    149a:	f7 01       	movw	r30, r14
    149c:	80 83       	st	Z, r24
    149e:	0c c0       	rjmp	.+24     	; 0x14b8 <xQueueReceiveFromISR+0x60>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    14a0:	df 5f       	subi	r29, 0xFF	; 255
    14a2:	f8 01       	movw	r30, r16
    14a4:	d5 8f       	std	Z+29, r29	; 0x1d
			}

			xReturn = pdPASS;
    14a6:	81 e0       	ldi	r24, 0x01	; 1
    14a8:	07 c0       	rjmp	.+14     	; 0x14b8 <xQueueReceiveFromISR+0x60>
		}
		else
		{
			xReturn = pdFAIL;
    14aa:	80 e0       	ldi	r24, 0x00	; 0
    14ac:	05 c0       	rjmp	.+10     	; 0x14b8 <xQueueReceiveFromISR+0x60>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
			}

			xReturn = pdPASS;
    14ae:	81 e0       	ldi	r24, 0x01	; 1
    14b0:	03 c0       	rjmp	.+6      	; 0x14b8 <xQueueReceiveFromISR+0x60>
    14b2:	81 e0       	ldi	r24, 0x01	; 1
    14b4:	01 c0       	rjmp	.+2      	; 0x14b8 <xQueueReceiveFromISR+0x60>
    14b6:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    14b8:	df 91       	pop	r29
    14ba:	cf 91       	pop	r28
    14bc:	1f 91       	pop	r17
    14be:	0f 91       	pop	r16
    14c0:	ff 90       	pop	r15
    14c2:	ef 90       	pop	r14
    14c4:	08 95       	ret

000014c6 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    14c6:	0f 93       	push	r16
    14c8:	1f 93       	push	r17
    14ca:	cf 93       	push	r28
    14cc:	df 93       	push	r29
    14ce:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    14d0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    14d2:	88 23       	and	r24, r24
    14d4:	49 f0       	breq	.+18     	; 0x14e8 <xQueuePeekFromISR+0x22>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    14d6:	0e 81       	ldd	r16, Y+6	; 0x06
    14d8:	1f 81       	ldd	r17, Y+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    14da:	ce 01       	movw	r24, r28
    14dc:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    14e0:	1f 83       	std	Y+7, r17	; 0x07
    14e2:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    14e4:	81 e0       	ldi	r24, 0x01	; 1
    14e6:	01 c0       	rjmp	.+2      	; 0x14ea <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    14e8:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    14ea:	df 91       	pop	r29
    14ec:	cf 91       	pop	r28
    14ee:	1f 91       	pop	r17
    14f0:	0f 91       	pop	r16
    14f2:	08 95       	ret

000014f4 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    14f4:	0f b6       	in	r0, 0x3f	; 63
    14f6:	f8 94       	cli
    14f8:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    14fa:	fc 01       	movw	r30, r24
    14fc:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    14fe:	0f 90       	pop	r0
    1500:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1502:	08 95       	ret

00001504 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    1504:	fc 01       	movw	r30, r24
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1506:	0f b6       	in	r0, 0x3f	; 63
    1508:	f8 94       	cli
    150a:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    150c:	92 8d       	ldd	r25, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    150e:	0f 90       	pop	r0
    1510:	0f be       	out	0x3f, r0	; 63
	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1512:	83 8d       	ldd	r24, Z+27	; 0x1b
	}
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1514:	89 1b       	sub	r24, r25
    1516:	08 95       	ret

00001518 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1518:	fc 01       	movw	r30, r24
    151a:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    151c:	08 95       	ret

0000151e <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    151e:	fc 01       	movw	r30, r24
    1520:	92 8d       	ldd	r25, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    1522:	81 e0       	ldi	r24, 0x01	; 1
    1524:	91 11       	cpse	r25, r1
    1526:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1528:	08 95       	ret

0000152a <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    152a:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    152c:	22 8d       	ldd	r18, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    152e:	81 e0       	ldi	r24, 0x01	; 1
    1530:	93 8d       	ldd	r25, Z+27	; 0x1b
    1532:	29 13       	cpse	r18, r25
    1534:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1536:	08 95       	ret

00001538 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    1538:	dc 01       	movw	r26, r24

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
    153a:	80 91 51 04 	lds	r24, 0x0451
    153e:	90 91 52 04 	lds	r25, 0x0452
    1542:	00 97       	sbiw	r24, 0x00	; 0
    1544:	51 f0       	breq	.+20     	; 0x155a <vQueueAddToRegistry+0x22>
    1546:	e5 e5       	ldi	r30, 0x55	; 85
    1548:	f4 e0       	ldi	r31, 0x04	; 4
    154a:	21 e0       	ldi	r18, 0x01	; 1
    154c:	30 e0       	ldi	r19, 0x00	; 0
    154e:	a9 01       	movw	r20, r18
    1550:	80 81       	ld	r24, Z
    1552:	91 81       	ldd	r25, Z+1	; 0x01
    1554:	00 97       	sbiw	r24, 0x00	; 0
    1556:	79 f4       	brne	.+30     	; 0x1576 <vQueueAddToRegistry+0x3e>
    1558:	02 c0       	rjmp	.+4      	; 0x155e <vQueueAddToRegistry+0x26>
    155a:	40 e0       	ldi	r20, 0x00	; 0
    155c:	50 e0       	ldi	r21, 0x00	; 0
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
    155e:	fa 01       	movw	r30, r20
    1560:	ee 0f       	add	r30, r30
    1562:	ff 1f       	adc	r31, r31
    1564:	ee 0f       	add	r30, r30
    1566:	ff 1f       	adc	r31, r31
    1568:	ef 5a       	subi	r30, 0xAF	; 175
    156a:	fb 4f       	sbci	r31, 0xFB	; 251
    156c:	71 83       	std	Z+1, r23	; 0x01
    156e:	60 83       	st	Z, r22
				xQueueRegistry[ ux ].xHandle = xQueue;
    1570:	b3 83       	std	Z+3, r27	; 0x03
    1572:	a2 83       	std	Z+2, r26	; 0x02

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
    1574:	08 95       	ret
    1576:	2f 5f       	subi	r18, 0xFF	; 255
    1578:	3f 4f       	sbci	r19, 0xFF	; 255
    157a:	34 96       	adiw	r30, 0x04	; 4
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    157c:	28 30       	cpi	r18, 0x08	; 8
    157e:	31 05       	cpc	r19, r1
    1580:	31 f7       	brne	.-52     	; 0x154e <vQueueAddToRegistry+0x16>
    1582:	08 95       	ret

00001584 <pcQueueGetName>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    1584:	ac 01       	movw	r20, r24

		/* Note there is nothing here to protect against another task adding or
		removing entries from the registry while it is being searched. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
    1586:	80 91 53 04 	lds	r24, 0x0453
    158a:	90 91 54 04 	lds	r25, 0x0454
    158e:	84 17       	cp	r24, r20
    1590:	95 07       	cpc	r25, r21
    1592:	59 f0       	breq	.+22     	; 0x15aa <pcQueueGetName+0x26>
    1594:	e7 e5       	ldi	r30, 0x57	; 87
    1596:	f4 e0       	ldi	r31, 0x04	; 4
    1598:	21 e0       	ldi	r18, 0x01	; 1
    159a:	30 e0       	ldi	r19, 0x00	; 0
    159c:	b9 01       	movw	r22, r18
    159e:	80 81       	ld	r24, Z
    15a0:	91 81       	ldd	r25, Z+1	; 0x01
    15a2:	84 17       	cp	r24, r20
    15a4:	95 07       	cpc	r25, r21
    15a6:	69 f4       	brne	.+26     	; 0x15c2 <pcQueueGetName+0x3e>
    15a8:	02 c0       	rjmp	.+4      	; 0x15ae <pcQueueGetName+0x2a>
    15aa:	60 e0       	ldi	r22, 0x00	; 0
    15ac:	70 e0       	ldi	r23, 0x00	; 0
			{
				pcReturn = xQueueRegistry[ ux ].pcQueueName;
    15ae:	fb 01       	movw	r30, r22
    15b0:	ee 0f       	add	r30, r30
    15b2:	ff 1f       	adc	r31, r31
    15b4:	ee 0f       	add	r30, r30
    15b6:	ff 1f       	adc	r31, r31
    15b8:	ef 5a       	subi	r30, 0xAF	; 175
    15ba:	fb 4f       	sbci	r31, 0xFB	; 251
    15bc:	80 81       	ld	r24, Z
    15be:	91 81       	ldd	r25, Z+1	; 0x01
				break;
    15c0:	08 95       	ret
    15c2:	2f 5f       	subi	r18, 0xFF	; 255
    15c4:	3f 4f       	sbci	r19, 0xFF	; 255
    15c6:	34 96       	adiw	r30, 0x04	; 4
	UBaseType_t ux;
	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */

		/* Note there is nothing here to protect against another task adding or
		removing entries from the registry while it is being searched. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    15c8:	28 30       	cpi	r18, 0x08	; 8
    15ca:	31 05       	cpc	r19, r1
    15cc:	39 f7       	brne	.-50     	; 0x159c <pcQueueGetName+0x18>
#if ( configQUEUE_REGISTRY_SIZE > 0 )

	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
	UBaseType_t ux;
	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    15ce:	80 e0       	ldi	r24, 0x00	; 0
    15d0:	90 e0       	ldi	r25, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}

		return pcReturn;
	}
    15d2:	08 95       	ret

000015d4 <vQueueUnregisterQueue>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueUnregisterQueue( QueueHandle_t xQueue )
	{
    15d4:	ac 01       	movw	r20, r24

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
    15d6:	80 91 53 04 	lds	r24, 0x0453
    15da:	90 91 54 04 	lds	r25, 0x0454
    15de:	84 17       	cp	r24, r20
    15e0:	95 07       	cpc	r25, r21
    15e2:	59 f0       	breq	.+22     	; 0x15fa <vQueueUnregisterQueue+0x26>
    15e4:	e7 e5       	ldi	r30, 0x57	; 87
    15e6:	f4 e0       	ldi	r31, 0x04	; 4
    15e8:	21 e0       	ldi	r18, 0x01	; 1
    15ea:	30 e0       	ldi	r19, 0x00	; 0
    15ec:	b9 01       	movw	r22, r18
    15ee:	80 81       	ld	r24, Z
    15f0:	91 81       	ldd	r25, Z+1	; 0x01
    15f2:	84 17       	cp	r24, r20
    15f4:	95 07       	cpc	r25, r21
    15f6:	79 f4       	brne	.+30     	; 0x1616 <vQueueUnregisterQueue+0x42>
    15f8:	02 c0       	rjmp	.+4      	; 0x15fe <vQueueUnregisterQueue+0x2a>
    15fa:	60 e0       	ldi	r22, 0x00	; 0
    15fc:	70 e0       	ldi	r23, 0x00	; 0
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
    15fe:	fb 01       	movw	r30, r22
    1600:	ee 0f       	add	r30, r30
    1602:	ff 1f       	adc	r31, r31
    1604:	ee 0f       	add	r30, r30
    1606:	ff 1f       	adc	r31, r31
    1608:	ef 5a       	subi	r30, 0xAF	; 175
    160a:	fb 4f       	sbci	r31, 0xFB	; 251
    160c:	11 82       	std	Z+1, r1	; 0x01
    160e:	10 82       	st	Z, r1

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
    1610:	13 82       	std	Z+3, r1	; 0x03
    1612:	12 82       	std	Z+2, r1	; 0x02
				break;
    1614:	08 95       	ret
    1616:	2f 5f       	subi	r18, 0xFF	; 255
    1618:	3f 4f       	sbci	r19, 0xFF	; 255
    161a:	34 96       	adiw	r30, 0x04	; 4
	{
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    161c:	28 30       	cpi	r18, 0x08	; 8
    161e:	31 05       	cpc	r19, r1
    1620:	29 f7       	brne	.-54     	; 0x15ec <vQueueUnregisterQueue+0x18>
    1622:	08 95       	ret

00001624 <vQueueDelete>:
	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    1624:	cf 93       	push	r28
    1626:	df 93       	push	r29
    1628:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );
	traceQUEUE_DELETE( pxQueue );

	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
    162a:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <vQueueUnregisterQueue>

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    162e:	ce 01       	movw	r24, r28
    1630:	0e 94 b2 02 	call	0x564	; 0x564 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    1634:	df 91       	pop	r29
    1636:	cf 91       	pop	r28
    1638:	08 95       	ret

0000163a <guestpage>:
	}
	
}
void guestpage(void *ptr)
{
	PORTD &= (~(1<<7));
    163a:	97 98       	cbi	0x12, 7	; 18
	PORTD &= (~(1<<6));
    163c:	96 98       	cbi	0x12, 6	; 18
	PORTD &= (~(1<<5));
    163e:	95 98       	cbi	0x12, 5	; 18
	PORTD &= (~(1<<4));
    1640:	94 98       	cbi	0x12, 4	; 18
	
	PORTD |= (1<<5);
    1642:	95 9a       	sbi	0x12, 5	; 18
	
	loginstat =2;
    1644:	82 e0       	ldi	r24, 0x02	; 2
    1646:	80 93 d0 03 	sts	0x03D0, r24
	clear_screen();
    164a:	0e 94 cd 03 	call	0x79a	; 0x79a <clear_screen>
	writeguestscreen();
    164e:	0e 94 c5 04 	call	0x98a	; 0x98a <writeguestscreen>
			xTaskCreate(loginsreen,"checkpass",50,NULL,1,loginsreenhandel);
			vTaskDelete(guestpagehandel);
		}
		else
		{
			PORTD ^=(1<<3);
    1652:	c8 e0       	ldi	r28, 0x08	; 8
		
		
		if(flagdisconect == 1)
		{
			
			xTaskCreate(loginsreen,"checkpass",50,NULL,1,loginsreenhandel);
    1654:	0f 2e       	mov	r0, r31
    1656:	ff e6       	ldi	r31, 0x6F	; 111
    1658:	cf 2e       	mov	r12, r31
    165a:	fb e0       	ldi	r31, 0x0B	; 11
    165c:	df 2e       	mov	r13, r31
    165e:	f0 2d       	mov	r31, r0
    1660:	0f 2e       	mov	r0, r31
    1662:	f2 e7       	ldi	r31, 0x72	; 114
    1664:	af 2e       	mov	r10, r31
    1666:	f0 e0       	ldi	r31, 0x00	; 0
    1668:	bf 2e       	mov	r11, r31
    166a:	f0 2d       	mov	r31, r0
	char input;
	
	while(1)
	{
		
		input= check();
    166c:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <check>
		
		if(input != 0 )
    1670:	88 23       	and	r24, r24
    1672:	81 f0       	breq	.+32     	; 0x1694 <guestpage+0x5a>
    1674:	2f ef       	ldi	r18, 0xFF	; 255
    1676:	32 e5       	ldi	r19, 0x52	; 82
    1678:	47 e0       	ldi	r20, 0x07	; 7
    167a:	21 50       	subi	r18, 0x01	; 1
    167c:	30 40       	sbci	r19, 0x00	; 0
    167e:	40 40       	sbci	r20, 0x00	; 0
    1680:	e1 f7       	brne	.-8      	; 0x167a <guestpage+0x40>
    1682:	00 c0       	rjmp	.+0      	; 0x1684 <guestpage+0x4a>
    1684:	00 00       	nop
		{
			_delay_ms(300);
			if(input=='1' || input=='2' || input=='3')
    1686:	98 2f       	mov	r25, r24
    1688:	91 53       	subi	r25, 0x31	; 49
    168a:	93 30       	cpi	r25, 0x03	; 3
    168c:	18 f4       	brcc	.+6      	; 0x1694 <guestpage+0x5a>
			{
				SPI_MasterTransmit(input);
    168e:	90 e0       	ldi	r25, 0x00	; 0
    1690:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <SPI_MasterTransmit>
			}
		}
		
		
		if(flagdisconect == 1)
    1694:	80 91 cb 03 	lds	r24, 0x03CB
    1698:	81 30       	cpi	r24, 0x01	; 1
    169a:	a1 f4       	brne	.+40     	; 0x16c4 <guestpage+0x8a>
		{
			
			xTaskCreate(loginsreen,"checkpass",50,NULL,1,loginsreenhandel);
    169c:	e0 90 d9 03 	lds	r14, 0x03D9
    16a0:	f0 90 da 03 	lds	r15, 0x03DA
    16a4:	c6 01       	movw	r24, r12
    16a6:	b5 01       	movw	r22, r10
    16a8:	42 e3       	ldi	r20, 0x32	; 50
    16aa:	50 e0       	ldi	r21, 0x00	; 0
    16ac:	20 e0       	ldi	r18, 0x00	; 0
    16ae:	30 e0       	ldi	r19, 0x00	; 0
    16b0:	01 e0       	ldi	r16, 0x01	; 1
    16b2:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <xTaskCreate>
			vTaskDelete(guestpagehandel);
    16b6:	80 91 d1 03 	lds	r24, 0x03D1
    16ba:	90 91 d2 03 	lds	r25, 0x03D2
    16be:	0e 94 75 10 	call	0x20ea	; 0x20ea <vTaskDelete>
    16c2:	d4 cf       	rjmp	.-88     	; 0x166c <guestpage+0x32>
		}
		else
		{
			PORTD ^=(1<<3);
    16c4:	82 b3       	in	r24, 0x12	; 18
    16c6:	8c 27       	eor	r24, r28
    16c8:	82 bb       	out	0x12, r24	; 18
    16ca:	8f ef       	ldi	r24, 0xFF	; 255
    16cc:	91 ee       	ldi	r25, 0xE1	; 225
    16ce:	a4 e0       	ldi	r26, 0x04	; 4
    16d0:	81 50       	subi	r24, 0x01	; 1
    16d2:	90 40       	sbci	r25, 0x00	; 0
    16d4:	a0 40       	sbci	r26, 0x00	; 0
    16d6:	e1 f7       	brne	.-8      	; 0x16d0 <guestpage+0x96>
    16d8:	00 c0       	rjmp	.+0      	; 0x16da <guestpage+0xa0>
    16da:	00 00       	nop
    16dc:	c7 cf       	rjmp	.-114    	; 0x166c <guestpage+0x32>

000016de <loginsreen>:
		
	}
}
void loginsreen(void *ptr)
{
	write_eeprom(5,'0');	
    16de:	85 e0       	ldi	r24, 0x05	; 5
    16e0:	90 e0       	ldi	r25, 0x00	; 0
    16e2:	60 e3       	ldi	r22, 0x30	; 48
    16e4:	70 e0       	ldi	r23, 0x00	; 0
    16e6:	0e 94 54 00 	call	0xa8	; 0xa8 <write_eeprom>
	char input;
	clear_screen();
    16ea:	0e 94 cd 03 	call	0x79a	; 0x79a <clear_screen>
	loginstat =0;
    16ee:	10 92 d0 03 	sts	0x03D0, r1
	timecount=0;
    16f2:	80 e0       	ldi	r24, 0x00	; 0
    16f4:	90 e0       	ldi	r25, 0x00	; 0
    16f6:	dc 01       	movw	r26, r24
    16f8:	80 93 cc 03 	sts	0x03CC, r24
    16fc:	90 93 cd 03 	sts	0x03CD, r25
    1700:	a0 93 ce 03 	sts	0x03CE, r26
    1704:	b0 93 cf 03 	sts	0x03CF, r27
	flagdisconect =0;
    1708:	10 92 cb 03 	sts	0x03CB, r1
	
	PORTD &= (~(1<<7));
    170c:	97 98       	cbi	0x12, 7	; 18
	PORTD &= (~(1<<6));
    170e:	96 98       	cbi	0x12, 6	; 18
	PORTD &= (~(1<<5));
    1710:	95 98       	cbi	0x12, 5	; 18
	PORTD &= (~(1<<4));
    1712:	94 98       	cbi	0x12, 4	; 18
	PORTD |= (1<<7);
    1714:	97 9a       	sbi	0x12, 7	; 18
	writeloginscreen();
    1716:	0e 94 15 04 	call	0x82a	; 0x82a <writeloginscreen>
				xTaskCreate(checkpassowrd,"checkpass",100,NULL,1,checkpassowrdhandel);
				vTaskDelete(loginsreenhandel);
			}
			if(input == '2')
			{
				xTaskCreate(guestpage,"checkpass",100,NULL,1,guestpagehandel);
    171a:	0f 2e       	mov	r0, r31
    171c:	fd e1       	ldi	r31, 0x1D	; 29
    171e:	cf 2e       	mov	r12, r31
    1720:	fb e0       	ldi	r31, 0x0B	; 11
    1722:	df 2e       	mov	r13, r31
    1724:	f0 2d       	mov	r31, r0
    1726:	c2 e7       	ldi	r28, 0x72	; 114
    1728:	d0 e0       	ldi	r29, 0x00	; 0
		if(input != 0 )
		{
			_delay_ms(300);
			if(input == '1')
			{
				xTaskCreate(checkpassowrd,"checkpass",100,NULL,1,checkpassowrdhandel);
    172a:	0f 2e       	mov	r0, r31
    172c:	f0 e2       	ldi	r31, 0x20	; 32
    172e:	af 2e       	mov	r10, r31
    1730:	fc e0       	ldi	r31, 0x0C	; 12
    1732:	bf 2e       	mov	r11, r31
    1734:	f0 2d       	mov	r31, r0
	PORTD |= (1<<7);
	writeloginscreen();
	
	while(1)
	{
		input= check();
    1736:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <check>
		
		if(input != 0 )
    173a:	88 23       	and	r24, r24
    173c:	e1 f3       	breq	.-8      	; 0x1736 <loginsreen+0x58>
    173e:	2f ef       	ldi	r18, 0xFF	; 255
    1740:	32 e5       	ldi	r19, 0x52	; 82
    1742:	47 e0       	ldi	r20, 0x07	; 7
    1744:	21 50       	subi	r18, 0x01	; 1
    1746:	30 40       	sbci	r19, 0x00	; 0
    1748:	40 40       	sbci	r20, 0x00	; 0
    174a:	e1 f7       	brne	.-8      	; 0x1744 <loginsreen+0x66>
    174c:	00 c0       	rjmp	.+0      	; 0x174e <loginsreen+0x70>
    174e:	00 00       	nop
		{
			_delay_ms(300);
			if(input == '1')
    1750:	81 33       	cpi	r24, 0x31	; 49
    1752:	a1 f4       	brne	.+40     	; 0x177c <loginsreen+0x9e>
			{
				xTaskCreate(checkpassowrd,"checkpass",100,NULL,1,checkpassowrdhandel);
    1754:	e0 90 d7 03 	lds	r14, 0x03D7
    1758:	f0 90 d8 03 	lds	r15, 0x03D8
    175c:	c5 01       	movw	r24, r10
    175e:	be 01       	movw	r22, r28
    1760:	44 e6       	ldi	r20, 0x64	; 100
    1762:	50 e0       	ldi	r21, 0x00	; 0
    1764:	20 e0       	ldi	r18, 0x00	; 0
    1766:	30 e0       	ldi	r19, 0x00	; 0
    1768:	01 e0       	ldi	r16, 0x01	; 1
    176a:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <xTaskCreate>
				vTaskDelete(loginsreenhandel);
    176e:	80 91 d9 03 	lds	r24, 0x03D9
    1772:	90 91 da 03 	lds	r25, 0x03DA
    1776:	0e 94 75 10 	call	0x20ea	; 0x20ea <vTaskDelete>
    177a:	dd cf       	rjmp	.-70     	; 0x1736 <loginsreen+0x58>
			}
			if(input == '2')
    177c:	82 33       	cpi	r24, 0x32	; 50
    177e:	d9 f6       	brne	.-74     	; 0x1736 <loginsreen+0x58>
			{
				xTaskCreate(guestpage,"checkpass",100,NULL,1,guestpagehandel);
    1780:	e0 90 d1 03 	lds	r14, 0x03D1
    1784:	f0 90 d2 03 	lds	r15, 0x03D2
    1788:	c6 01       	movw	r24, r12
    178a:	be 01       	movw	r22, r28
    178c:	44 e6       	ldi	r20, 0x64	; 100
    178e:	50 e0       	ldi	r21, 0x00	; 0
    1790:	20 e0       	ldi	r18, 0x00	; 0
    1792:	30 e0       	ldi	r19, 0x00	; 0
    1794:	01 e0       	ldi	r16, 0x01	; 1
    1796:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <xTaskCreate>
				vTaskDelete(loginsreenhandel);
    179a:	80 91 d9 03 	lds	r24, 0x03D9
    179e:	90 91 da 03 	lds	r25, 0x03DA
    17a2:	0e 94 75 10 	call	0x20ea	; 0x20ea <vTaskDelete>
    17a6:	c7 cf       	rjmp	.-114    	; 0x1736 <loginsreen+0x58>

000017a8 <block>:
}


void block(void *ptr)
{
	PORTD &= (~(1<<7));
    17a8:	97 98       	cbi	0x12, 7	; 18
	PORTD &= (~(1<<6));
    17aa:	96 98       	cbi	0x12, 6	; 18
	PORTD &= (~(1<<5));
    17ac:	95 98       	cbi	0x12, 5	; 18
	PORTD &= (~(1<<4));
    17ae:	94 98       	cbi	0x12, 4	; 18
	PORTD |= (1<<4);
    17b0:	94 9a       	sbi	0x12, 4	; 18
	
	clear_screen();
    17b2:	0e 94 cd 03 	call	0x79a	; 0x79a <clear_screen>
	LCD_VsnedString("blocked");
    17b6:	8c e7       	ldi	r24, 0x7C	; 124
    17b8:	90 e0       	ldi	r25, 0x00	; 0
    17ba:	0e 94 da 03 	call	0x7b4	; 0x7b4 <LCD_VsnedString>
	write_eeprom(5,'1');
    17be:	85 e0       	ldi	r24, 0x05	; 5
    17c0:	90 e0       	ldi	r25, 0x00	; 0
    17c2:	61 e3       	ldi	r22, 0x31	; 49
    17c4:	70 e0       	ldi	r23, 0x00	; 0
    17c6:	0e 94 54 00 	call	0xa8	; 0xa8 <write_eeprom>
	loginstat=3;
    17ca:	83 e0       	ldi	r24, 0x03	; 3
    17cc:	80 93 d0 03 	sts	0x03D0, r24
	while(1)
	{
		if(flagdisconect ==1)
		{
			xTaskCreate(loginsreen,"checkpass",50,NULL,1,loginsreenhandel);
    17d0:	0f 2e       	mov	r0, r31
    17d2:	ff e6       	ldi	r31, 0x6F	; 111
    17d4:	cf 2e       	mov	r12, r31
    17d6:	fb e0       	ldi	r31, 0x0B	; 11
    17d8:	df 2e       	mov	r13, r31
    17da:	f0 2d       	mov	r31, r0
    17dc:	0f 2e       	mov	r0, r31
    17de:	f2 e7       	ldi	r31, 0x72	; 114
    17e0:	af 2e       	mov	r10, r31
    17e2:	f0 e0       	ldi	r31, 0x00	; 0
    17e4:	bf 2e       	mov	r11, r31
    17e6:	f0 2d       	mov	r31, r0
			write_eeprom(5,'0');
			
		}
		else
		{
			PORTD ^=(1<<3);
    17e8:	c8 e0       	ldi	r28, 0x08	; 8
	LCD_VsnedString("blocked");
	write_eeprom(5,'1');
	loginstat=3;
	while(1)
	{
		if(flagdisconect ==1)
    17ea:	80 91 cb 03 	lds	r24, 0x03CB
    17ee:	81 30       	cpi	r24, 0x01	; 1
    17f0:	d1 f4       	brne	.+52     	; 0x1826 <block+0x7e>
		{
			xTaskCreate(loginsreen,"checkpass",50,NULL,1,loginsreenhandel);
    17f2:	e0 90 d9 03 	lds	r14, 0x03D9
    17f6:	f0 90 da 03 	lds	r15, 0x03DA
    17fa:	c6 01       	movw	r24, r12
    17fc:	b5 01       	movw	r22, r10
    17fe:	42 e3       	ldi	r20, 0x32	; 50
    1800:	50 e0       	ldi	r21, 0x00	; 0
    1802:	20 e0       	ldi	r18, 0x00	; 0
    1804:	30 e0       	ldi	r19, 0x00	; 0
    1806:	01 e0       	ldi	r16, 0x01	; 1
    1808:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <xTaskCreate>
			vTaskDelete(blockhandel);
    180c:	80 91 d3 03 	lds	r24, 0x03D3
    1810:	90 91 d4 03 	lds	r25, 0x03D4
    1814:	0e 94 75 10 	call	0x20ea	; 0x20ea <vTaskDelete>
			
			
			write_eeprom(5,'0');
    1818:	85 e0       	ldi	r24, 0x05	; 5
    181a:	90 e0       	ldi	r25, 0x00	; 0
    181c:	60 e3       	ldi	r22, 0x30	; 48
    181e:	70 e0       	ldi	r23, 0x00	; 0
    1820:	0e 94 54 00 	call	0xa8	; 0xa8 <write_eeprom>
    1824:	e2 cf       	rjmp	.-60     	; 0x17ea <block+0x42>
			
		}
		else
		{
			PORTD ^=(1<<3);
    1826:	82 b3       	in	r24, 0x12	; 18
    1828:	8c 27       	eor	r24, r28
    182a:	82 bb       	out	0x12, r24	; 18
    182c:	8f ef       	ldi	r24, 0xFF	; 255
    182e:	99 e6       	ldi	r25, 0x69	; 105
    1830:	a8 e1       	ldi	r26, 0x18	; 24
    1832:	81 50       	subi	r24, 0x01	; 1
    1834:	90 40       	sbci	r25, 0x00	; 0
    1836:	a0 40       	sbci	r26, 0x00	; 0
    1838:	e1 f7       	brne	.-8      	; 0x1832 <block+0x8a>
    183a:	00 c0       	rjmp	.+0      	; 0x183c <block+0x94>
    183c:	00 00       	nop
    183e:	d5 cf       	rjmp	.-86     	; 0x17ea <block+0x42>

00001840 <checkpassowrd>:
	}
	
	
}
void checkpassowrd(void *ptr)
{
    1840:	cf 93       	push	r28
    1842:	df 93       	push	r29
    1844:	00 d0       	rcall	.+0      	; 0x1846 <checkpassowrd+0x6>
    1846:	0f 92       	push	r0
    1848:	cd b7       	in	r28, 0x3d	; 61
    184a:	de b7       	in	r29, 0x3e	; 62
	char col=0;
	clear_screen();
    184c:	0e 94 cd 03 	call	0x79a	; 0x79a <clear_screen>
	char wrongpasswordcount=0;

	
	char pass_exists = read_eeprom(0);
    1850:	80 e0       	ldi	r24, 0x00	; 0
    1852:	90 e0       	ldi	r25, 0x00	; 0
    1854:	0e 94 5f 00 	call	0xbe	; 0xbe <read_eeprom>
    1858:	89 83       	std	Y+1, r24	; 0x01
	
	if(pass_exists !='0')
    185a:	80 33       	cpi	r24, 0x30	; 48
    185c:	19 f0       	breq	.+6      	; 0x1864 <checkpassowrd+0x24>
	{
		writeSetpassword();
    185e:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <writeSetpassword>
    1862:	04 c0       	rjmp	.+8      	; 0x186c <checkpassowrd+0x2c>
	}
	else
	{
		LCD_VsnedString("Password:");
    1864:	84 e8       	ldi	r24, 0x84	; 132
    1866:	90 e0       	ldi	r25, 0x00	; 0
    1868:	0e 94 da 03 	call	0x7b4	; 0x7b4 <LCD_VsnedString>
	}
	
	LCD_VGOTO(1,col);
    186c:	81 e0       	ldi	r24, 0x01	; 1
    186e:	90 e0       	ldi	r25, 0x00	; 0
    1870:	60 e0       	ldi	r22, 0x00	; 0
    1872:	70 e0       	ldi	r23, 0x00	; 0
    1874:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <LCD_VGOTO>
	PORTD |= (1<<7);
    1878:	97 9a       	sbi	0x12, 7	; 18
}
void checkpassowrd(void *ptr)
{
	char col=0;
	clear_screen();
	char wrongpasswordcount=0;
    187a:	cc 24       	eor	r12, r12
	
	
}
void checkpassowrd(void *ptr)
{
	char col=0;
    187c:	dd 24       	eor	r13, r13
					pass[0]= read_eeprom(1);
					pass[1]= read_eeprom(2);
					pass[2]= read_eeprom(3);
					pass[3]= read_eeprom(4);
					
					if(passin[0]==pass[0]&&passin[1]==pass[1]&& passin[2]==pass[2]&&passin[3]==pass[3])
    187e:	0f 2e       	mov	r0, r31
    1880:	f1 e7       	ldi	r31, 0x71	; 113
    1882:	af 2e       	mov	r10, r31
    1884:	f4 e0       	ldi	r31, 0x04	; 4
    1886:	bf 2e       	mov	r11, r31
    1888:	f0 2d       	mov	r31, r0
						LCD_VGOTO(1,0);
						col=-1;
						wrongpasswordcount++;
						if(wrongpasswordcount ==3)
						{
							xTaskCreate(block,"checkpass",100,NULL,1,loginsreenhandel);
    188a:	0f 2e       	mov	r0, r31
    188c:	f2 e7       	ldi	r31, 0x72	; 114
    188e:	8f 2e       	mov	r8, r31
    1890:	f0 e0       	ldi	r31, 0x00	; 0
    1892:	9f 2e       	mov	r9, r31
    1894:	f0 2d       	mov	r31, r0
					pass[2]= read_eeprom(3);
					pass[3]= read_eeprom(4);
					
					if(passin[0]==pass[0]&&passin[1]==pass[1]&& passin[2]==pass[2]&&passin[3]==pass[3])
					{
						xTaskCreate(adminpage,"checkpass",100,NULL,1,adminpagehandel);
    1896:	0f 2e       	mov	r0, r31
    1898:	f6 e3       	ldi	r31, 0x36	; 54
    189a:	6f 2e       	mov	r6, r31
    189c:	fd e0       	ldi	r31, 0x0D	; 13
    189e:	7f 2e       	mov	r7, r31
    18a0:	f0 2d       	mov	r31, r0
			{
				if(pass_exists !='0')
				{
					write_eeprom(0 , '0');
					write_eeprom(1 , passin[0]);
					write_eeprom(2 , passin[1]);
    18a2:	25 01       	movw	r4, r10
    18a4:	08 94       	sec
    18a6:	41 1c       	adc	r4, r1
    18a8:	51 1c       	adc	r5, r1
					write_eeprom(3 , passin[2]);
    18aa:	22 24       	eor	r2, r2
    18ac:	33 24       	eor	r3, r3
    18ae:	68 94       	set
    18b0:	21 f8       	bld	r2, 1
    18b2:	2a 0c       	add	r2, r10
    18b4:	3b 1c       	adc	r3, r11
					write_eeprom(4 , passin[3]);
    18b6:	c5 01       	movw	r24, r10
    18b8:	03 96       	adiw	r24, 0x03	; 3
    18ba:	9b 83       	std	Y+3, r25	; 0x03
    18bc:	8a 83       	std	Y+2, r24	; 0x02
	
	char input;
	char index= 0;
	while(1)
	{
		input= check();
    18be:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <check>
    18c2:	18 2f       	mov	r17, r24
		
		if(input != 0 )
    18c4:	88 23       	and	r24, r24
    18c6:	d9 f3       	breq	.-10     	; 0x18be <checkpassowrd+0x7e>
    18c8:	8f ef       	ldi	r24, 0xFF	; 255
    18ca:	92 e5       	ldi	r25, 0x52	; 82
    18cc:	a7 e0       	ldi	r26, 0x07	; 7
    18ce:	81 50       	subi	r24, 0x01	; 1
    18d0:	90 40       	sbci	r25, 0x00	; 0
    18d2:	a0 40       	sbci	r26, 0x00	; 0
    18d4:	e1 f7       	brne	.-8      	; 0x18ce <checkpassowrd+0x8e>
    18d6:	00 c0       	rjmp	.+0      	; 0x18d8 <checkpassowrd+0x98>
    18d8:	00 00       	nop
		{
			_delay_ms(300);
			LCD_vsendData(input);
    18da:	81 2f       	mov	r24, r17
    18dc:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
    18e0:	8f ef       	ldi	r24, 0xFF	; 255
    18e2:	91 ee       	ldi	r25, 0xE1	; 225
    18e4:	a4 e0       	ldi	r26, 0x04	; 4
    18e6:	81 50       	subi	r24, 0x01	; 1
    18e8:	90 40       	sbci	r25, 0x00	; 0
    18ea:	a0 40       	sbci	r26, 0x00	; 0
    18ec:	e1 f7       	brne	.-8      	; 0x18e6 <checkpassowrd+0xa6>
    18ee:	00 c0       	rjmp	.+0      	; 0x18f0 <checkpassowrd+0xb0>
    18f0:	00 00       	nop
			_delay_ms(200);
			LCD_VGOTO(1,col);
    18f2:	ed 2c       	mov	r14, r13
    18f4:	ff 24       	eor	r15, r15
    18f6:	81 e0       	ldi	r24, 0x01	; 1
    18f8:	90 e0       	ldi	r25, 0x00	; 0
    18fa:	b7 01       	movw	r22, r14
    18fc:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <LCD_VGOTO>
			LCD_vsendData('*');
    1900:	8a e2       	ldi	r24, 0x2A	; 42
    1902:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
			passin[col] = input;
    1906:	f7 01       	movw	r30, r14
    1908:	ef 58       	subi	r30, 0x8F	; 143
    190a:	fb 4f       	sbci	r31, 0xFB	; 251
    190c:	10 83       	st	Z, r17
			
			if(col == 3)
    190e:	93 e0       	ldi	r25, 0x03	; 3
    1910:	d9 16       	cp	r13, r25
    1912:	09 f0       	breq	.+2      	; 0x1916 <checkpassowrd+0xd6>
    1914:	a9 c0       	rjmp	.+338    	; 0x1a68 <checkpassowrd+0x228>
			{
				if(pass_exists !='0')
    1916:	a9 81       	ldd	r26, Y+1	; 0x01
    1918:	a0 33       	cpi	r26, 0x30	; 48
    191a:	b9 f1       	breq	.+110    	; 0x198a <checkpassowrd+0x14a>
				{
					write_eeprom(0 , '0');
    191c:	80 e0       	ldi	r24, 0x00	; 0
    191e:	90 e0       	ldi	r25, 0x00	; 0
    1920:	60 e3       	ldi	r22, 0x30	; 48
    1922:	70 e0       	ldi	r23, 0x00	; 0
    1924:	0e 94 54 00 	call	0xa8	; 0xa8 <write_eeprom>
					write_eeprom(1 , passin[0]);
    1928:	f5 01       	movw	r30, r10
    192a:	60 81       	ld	r22, Z
    192c:	81 e0       	ldi	r24, 0x01	; 1
    192e:	90 e0       	ldi	r25, 0x00	; 0
    1930:	70 e0       	ldi	r23, 0x00	; 0
    1932:	0e 94 54 00 	call	0xa8	; 0xa8 <write_eeprom>
					write_eeprom(2 , passin[1]);
    1936:	d2 01       	movw	r26, r4
    1938:	6c 91       	ld	r22, X
    193a:	82 e0       	ldi	r24, 0x02	; 2
    193c:	90 e0       	ldi	r25, 0x00	; 0
    193e:	70 e0       	ldi	r23, 0x00	; 0
    1940:	0e 94 54 00 	call	0xa8	; 0xa8 <write_eeprom>
					write_eeprom(3 , passin[2]);
    1944:	f1 01       	movw	r30, r2
    1946:	60 81       	ld	r22, Z
    1948:	83 e0       	ldi	r24, 0x03	; 3
    194a:	90 e0       	ldi	r25, 0x00	; 0
    194c:	70 e0       	ldi	r23, 0x00	; 0
    194e:	0e 94 54 00 	call	0xa8	; 0xa8 <write_eeprom>
					write_eeprom(4 , passin[3]);
    1952:	aa 81       	ldd	r26, Y+2	; 0x02
    1954:	bb 81       	ldd	r27, Y+3	; 0x03
    1956:	6c 91       	ld	r22, X
    1958:	84 e0       	ldi	r24, 0x04	; 4
    195a:	90 e0       	ldi	r25, 0x00	; 0
    195c:	70 e0       	ldi	r23, 0x00	; 0
    195e:	0e 94 54 00 	call	0xa8	; 0xa8 <write_eeprom>
					
					
					xTaskCreate(adminpage,"checkpass",100,NULL,1,adminpagehandel);
    1962:	e0 90 d5 03 	lds	r14, 0x03D5
    1966:	f0 90 d6 03 	lds	r15, 0x03D6
    196a:	c3 01       	movw	r24, r6
    196c:	b4 01       	movw	r22, r8
    196e:	44 e6       	ldi	r20, 0x64	; 100
    1970:	50 e0       	ldi	r21, 0x00	; 0
    1972:	20 e0       	ldi	r18, 0x00	; 0
    1974:	30 e0       	ldi	r19, 0x00	; 0
    1976:	01 e0       	ldi	r16, 0x01	; 1
    1978:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <xTaskCreate>
					vTaskDelete(checkpassowrdhandel);
    197c:	80 91 d7 03 	lds	r24, 0x03D7
    1980:	90 91 d8 03 	lds	r25, 0x03D8
    1984:	0e 94 75 10 	call	0x20ea	; 0x20ea <vTaskDelete>
    1988:	6f c0       	rjmp	.+222    	; 0x1a68 <checkpassowrd+0x228>
					
				}
				else
				{
					char pass[4];
					pass[0]= read_eeprom(1);
    198a:	81 e0       	ldi	r24, 0x01	; 1
    198c:	90 e0       	ldi	r25, 0x00	; 0
    198e:	0e 94 5f 00 	call	0xbe	; 0xbe <read_eeprom>
    1992:	08 2f       	mov	r16, r24
					pass[1]= read_eeprom(2);
    1994:	82 e0       	ldi	r24, 0x02	; 2
    1996:	90 e0       	ldi	r25, 0x00	; 0
    1998:	0e 94 5f 00 	call	0xbe	; 0xbe <read_eeprom>
    199c:	18 2f       	mov	r17, r24
					pass[2]= read_eeprom(3);
    199e:	83 e0       	ldi	r24, 0x03	; 3
    19a0:	90 e0       	ldi	r25, 0x00	; 0
    19a2:	0e 94 5f 00 	call	0xbe	; 0xbe <read_eeprom>
    19a6:	e8 2e       	mov	r14, r24
					pass[3]= read_eeprom(4);
    19a8:	84 e0       	ldi	r24, 0x04	; 4
    19aa:	90 e0       	ldi	r25, 0x00	; 0
    19ac:	0e 94 5f 00 	call	0xbe	; 0xbe <read_eeprom>
					
					if(passin[0]==pass[0]&&passin[1]==pass[1]&& passin[2]==pass[2]&&passin[3]==pass[3])
    19b0:	f5 01       	movw	r30, r10
    19b2:	90 81       	ld	r25, Z
    19b4:	90 17       	cp	r25, r16
    19b6:	11 f5       	brne	.+68     	; 0x19fc <checkpassowrd+0x1bc>
    19b8:	a2 e7       	ldi	r26, 0x72	; 114
    19ba:	b4 e0       	ldi	r27, 0x04	; 4
    19bc:	9c 91       	ld	r25, X
    19be:	91 17       	cp	r25, r17
    19c0:	e9 f4       	brne	.+58     	; 0x19fc <checkpassowrd+0x1bc>
    19c2:	e3 e7       	ldi	r30, 0x73	; 115
    19c4:	f4 e0       	ldi	r31, 0x04	; 4
    19c6:	90 81       	ld	r25, Z
    19c8:	9e 15       	cp	r25, r14
    19ca:	c1 f4       	brne	.+48     	; 0x19fc <checkpassowrd+0x1bc>
    19cc:	12 96       	adiw	r26, 0x02	; 2
    19ce:	9c 91       	ld	r25, X
    19d0:	98 17       	cp	r25, r24
    19d2:	a1 f4       	brne	.+40     	; 0x19fc <checkpassowrd+0x1bc>
					{
						xTaskCreate(adminpage,"checkpass",100,NULL,1,adminpagehandel);
    19d4:	e0 90 d5 03 	lds	r14, 0x03D5
    19d8:	f0 90 d6 03 	lds	r15, 0x03D6
    19dc:	c3 01       	movw	r24, r6
    19de:	b4 01       	movw	r22, r8
    19e0:	44 e6       	ldi	r20, 0x64	; 100
    19e2:	50 e0       	ldi	r21, 0x00	; 0
    19e4:	20 e0       	ldi	r18, 0x00	; 0
    19e6:	30 e0       	ldi	r19, 0x00	; 0
    19e8:	01 e0       	ldi	r16, 0x01	; 1
    19ea:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <xTaskCreate>
						vTaskDelete(checkpassowrdhandel);
    19ee:	80 91 d7 03 	lds	r24, 0x03D7
    19f2:	90 91 d8 03 	lds	r25, 0x03D8
    19f6:	0e 94 75 10 	call	0x20ea	; 0x20ea <vTaskDelete>
    19fa:	36 c0       	rjmp	.+108    	; 0x1a68 <checkpassowrd+0x228>
					}
					else
					{
						clear_screen();
    19fc:	0e 94 cd 03 	call	0x79a	; 0x79a <clear_screen>
						writewrongpassword();
    1a00:	0e 94 59 04 	call	0x8b2	; 0x8b2 <writewrongpassword>
    1a04:	8f ef       	ldi	r24, 0xFF	; 255
    1a06:	99 e6       	ldi	r25, 0x69	; 105
    1a08:	a8 e1       	ldi	r26, 0x18	; 24
    1a0a:	81 50       	subi	r24, 0x01	; 1
    1a0c:	90 40       	sbci	r25, 0x00	; 0
    1a0e:	a0 40       	sbci	r26, 0x00	; 0
    1a10:	e1 f7       	brne	.-8      	; 0x1a0a <checkpassowrd+0x1ca>
    1a12:	00 c0       	rjmp	.+0      	; 0x1a14 <checkpassowrd+0x1d4>
    1a14:	00 00       	nop
						_delay_ms(1000);
						clear_screen();
    1a16:	0e 94 cd 03 	call	0x79a	; 0x79a <clear_screen>
						LCD_VsnedString("Password:");
    1a1a:	84 e8       	ldi	r24, 0x84	; 132
    1a1c:	90 e0       	ldi	r25, 0x00	; 0
    1a1e:	0e 94 da 03 	call	0x7b4	; 0x7b4 <LCD_VsnedString>
						LCD_VGOTO(1,0);
    1a22:	81 e0       	ldi	r24, 0x01	; 1
    1a24:	90 e0       	ldi	r25, 0x00	; 0
    1a26:	60 e0       	ldi	r22, 0x00	; 0
    1a28:	70 e0       	ldi	r23, 0x00	; 0
    1a2a:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <LCD_VGOTO>
						col=-1;
						wrongpasswordcount++;
    1a2e:	c3 94       	inc	r12
						if(wrongpasswordcount ==3)
    1a30:	93 e0       	ldi	r25, 0x03	; 3
    1a32:	c9 16       	cp	r12, r25
    1a34:	b9 f4       	brne	.+46     	; 0x1a64 <checkpassowrd+0x224>
						{
							xTaskCreate(block,"checkpass",100,NULL,1,loginsreenhandel);
    1a36:	e0 90 d9 03 	lds	r14, 0x03D9
    1a3a:	f0 90 da 03 	lds	r15, 0x03DA
    1a3e:	84 ed       	ldi	r24, 0xD4	; 212
    1a40:	9b e0       	ldi	r25, 0x0B	; 11
    1a42:	b4 01       	movw	r22, r8
    1a44:	44 e6       	ldi	r20, 0x64	; 100
    1a46:	50 e0       	ldi	r21, 0x00	; 0
    1a48:	20 e0       	ldi	r18, 0x00	; 0
    1a4a:	30 e0       	ldi	r19, 0x00	; 0
    1a4c:	01 e0       	ldi	r16, 0x01	; 1
    1a4e:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <xTaskCreate>
							vTaskDelete(checkpassowrdhandel);
    1a52:	80 91 d7 03 	lds	r24, 0x03D7
    1a56:	90 91 d8 03 	lds	r25, 0x03D8
    1a5a:	0e 94 75 10 	call	0x20ea	; 0x20ea <vTaskDelete>
						writewrongpassword();
						_delay_ms(1000);
						clear_screen();
						LCD_VsnedString("Password:");
						LCD_VGOTO(1,0);
						col=-1;
    1a5e:	dd 24       	eor	r13, r13
    1a60:	da 94       	dec	r13
    1a62:	02 c0       	rjmp	.+4      	; 0x1a68 <checkpassowrd+0x228>
    1a64:	dd 24       	eor	r13, r13
    1a66:	da 94       	dec	r13
				}
				
			}
			
			
			col++;
    1a68:	d3 94       	inc	r13
    1a6a:	29 cf       	rjmp	.-430    	; 0x18be <checkpassowrd+0x7e>

00001a6c <adminpage>:
		
		
	}
}
void adminpage(void *ptr)
{
    1a6c:	cf 93       	push	r28
    1a6e:	df 93       	push	r29
    1a70:	00 d0       	rcall	.+0      	; 0x1a72 <adminpage+0x6>
    1a72:	cd b7       	in	r28, 0x3d	; 61
    1a74:	de b7       	in	r29, 0x3e	; 62
	loginstat =1;
    1a76:	81 e0       	ldi	r24, 0x01	; 1
    1a78:	80 93 d0 03 	sts	0x03D0, r24
	PORTD &= (~(1<<7));
    1a7c:	97 98       	cbi	0x12, 7	; 18
	PORTD &= (~(1<<6));
    1a7e:	96 98       	cbi	0x12, 6	; 18
	PORTD &= (~(1<<5));
    1a80:	95 98       	cbi	0x12, 5	; 18
	PORTD &= (~(1<<4));
    1a82:	94 98       	cbi	0x12, 4	; 18
	PORTD |= (1<<6);
    1a84:	96 9a       	sbi	0x12, 6	; 18
	
	clear_screen();
    1a86:	0e 94 cd 03 	call	0x79a	; 0x79a <clear_screen>
	writeadminscreen();
    1a8a:	0e 94 84 04 	call	0x908	; 0x908 <writeadminscreen>
	char input;
	
	char temp[2];
	
	int ftemp=0;
    1a8e:	aa 24       	eor	r10, r10
    1a90:	bb 24       	eor	r11, r11
					SPI_MasterTransmit(input);
					if(input=='5')
					{
						ftemp =2;
						clear_screen();
						LCD_VsnedString("Temp");
    1a92:	0f 2e       	mov	r0, r31
    1a94:	fe e8       	ldi	r31, 0x8E	; 142
    1a96:	2f 2e       	mov	r2, r31
    1a98:	f0 e0       	ldi	r31, 0x00	; 0
    1a9a:	3f 2e       	mov	r3, r31
    1a9c:	f0 2d       	mov	r31, r0
				if(input=='1' || input=='2' || input=='3' || input=='4'||input=='5')
				{
					SPI_MasterTransmit(input);
					if(input=='5')
					{
						ftemp =2;
    1a9e:	88 24       	eor	r8, r8
    1aa0:	99 24       	eor	r9, r9
    1aa2:	68 94       	set
    1aa4:	81 f8       	bld	r8, 1
			xTaskCreate(loginsreen,"checkpass",50,NULL,1,loginsreenhandel);
			vTaskDelete(adminpagehandel);
		}
		else
		{
			PORTD ^=(1<<3);
    1aa6:	dd 24       	eor	r13, r13
    1aa8:	68 94       	set
    1aaa:	d3 f8       	bld	r13, 3
		if(flagdisconect == 1)
		{
			
			PORTD |=(1<<4);
			
			xTaskCreate(loginsreen,"checkpass",50,NULL,1,loginsreenhandel);
    1aac:	0f 2e       	mov	r0, r31
    1aae:	ff e6       	ldi	r31, 0x6F	; 111
    1ab0:	6f 2e       	mov	r6, r31
    1ab2:	fb e0       	ldi	r31, 0x0B	; 11
    1ab4:	7f 2e       	mov	r7, r31
    1ab6:	f0 2d       	mov	r31, r0
    1ab8:	0f 2e       	mov	r0, r31
    1aba:	f2 e7       	ldi	r31, 0x72	; 114
    1abc:	4f 2e       	mov	r4, r31
    1abe:	f0 e0       	ldi	r31, 0x00	; 0
    1ac0:	5f 2e       	mov	r5, r31
    1ac2:	f0 2d       	mov	r31, r0
	while(1)
	{
		
		//code for sending the instructions here
		
		input= check();
    1ac4:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <check>
    1ac8:	18 2f       	mov	r17, r24
		
		if(input != 0 )
    1aca:	88 23       	and	r24, r24
    1acc:	09 f4       	brne	.+2      	; 0x1ad0 <adminpage+0x64>
    1ace:	51 c0       	rjmp	.+162    	; 0x1b72 <adminpage+0x106>
    1ad0:	8f ef       	ldi	r24, 0xFF	; 255
    1ad2:	92 e5       	ldi	r25, 0x52	; 82
    1ad4:	a7 e0       	ldi	r26, 0x07	; 7
    1ad6:	81 50       	subi	r24, 0x01	; 1
    1ad8:	90 40       	sbci	r25, 0x00	; 0
    1ada:	a0 40       	sbci	r26, 0x00	; 0
    1adc:	e1 f7       	brne	.-8      	; 0x1ad6 <adminpage+0x6a>
    1ade:	00 c0       	rjmp	.+0      	; 0x1ae0 <adminpage+0x74>
    1ae0:	00 00       	nop
		{
			_delay_ms(300);
			
			if(ftemp >0)
    1ae2:	1a 14       	cp	r1, r10
    1ae4:	1b 04       	cpc	r1, r11
    1ae6:	7c f5       	brge	.+94     	; 0x1b46 <adminpage+0xda>
			{
				LCD_vsendData(input);
    1ae8:	81 2f       	mov	r24, r17
    1aea:	0e 94 b4 03 	call	0x768	; 0x768 <LCD_vsendData>
				temp[2-ftemp]=input;
    1aee:	c4 01       	movw	r24, r8
    1af0:	8a 19       	sub	r24, r10
    1af2:	9b 09       	sbc	r25, r11
    1af4:	a1 e0       	ldi	r26, 0x01	; 1
    1af6:	b0 e0       	ldi	r27, 0x00	; 0
    1af8:	ac 0f       	add	r26, r28
    1afa:	bd 1f       	adc	r27, r29
    1afc:	8a 0f       	add	r24, r26
    1afe:	9b 1f       	adc	r25, r27
    1b00:	fc 01       	movw	r30, r24
    1b02:	10 83       	st	Z, r17
				
				if(ftemp == 1)
    1b04:	f1 e0       	ldi	r31, 0x01	; 1
    1b06:	af 16       	cp	r10, r31
    1b08:	b1 04       	cpc	r11, r1
    1b0a:	c9 f4       	brne	.+50     	; 0x1b3e <adminpage+0xd2>
				{
					
					clear_screen();
    1b0c:	0e 94 cd 03 	call	0x79a	; 0x79a <clear_screen>
					LCD_VGOTO(0,0);
    1b10:	80 e0       	ldi	r24, 0x00	; 0
    1b12:	90 e0       	ldi	r25, 0x00	; 0
    1b14:	60 e0       	ldi	r22, 0x00	; 0
    1b16:	70 e0       	ldi	r23, 0x00	; 0
    1b18:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <LCD_VGOTO>
					writeadminscreen();
    1b1c:	0e 94 84 04 	call	0x908	; 0x908 <writeadminscreen>
					temp[0] = temp[0] - '0';
    1b20:	89 81       	ldd	r24, Y+1	; 0x01
    1b22:	80 53       	subi	r24, 0x30	; 48
    1b24:	89 83       	std	Y+1, r24	; 0x01
					temp[1]-= '0';
    1b26:	9a 81       	ldd	r25, Y+2	; 0x02
    1b28:	90 53       	subi	r25, 0x30	; 48
    1b2a:	9a 83       	std	Y+2, r25	; 0x02
					
					char tt = (temp[0]*10)+temp[1];
    1b2c:	88 0f       	add	r24, r24
    1b2e:	28 2f       	mov	r18, r24
    1b30:	22 0f       	add	r18, r18
    1b32:	22 0f       	add	r18, r18
    1b34:	82 0f       	add	r24, r18
					
					SPI_MasterTransmit(tt);
    1b36:	89 0f       	add	r24, r25
    1b38:	90 e0       	ldi	r25, 0x00	; 0
    1b3a:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <SPI_MasterTransmit>
				}
				
				
				ftemp --;
    1b3e:	08 94       	sec
    1b40:	a1 08       	sbc	r10, r1
    1b42:	b1 08       	sbc	r11, r1
    1b44:	16 c0       	rjmp	.+44     	; 0x1b72 <adminpage+0x106>
			}
			else
			{
				if(input=='1' || input=='2' || input=='3' || input=='4'||input=='5')
    1b46:	81 2f       	mov	r24, r17
    1b48:	81 53       	subi	r24, 0x31	; 49
    1b4a:	85 30       	cpi	r24, 0x05	; 5
    1b4c:	90 f4       	brcc	.+36     	; 0x1b72 <adminpage+0x106>
				{
					SPI_MasterTransmit(input);
    1b4e:	81 2f       	mov	r24, r17
    1b50:	90 e0       	ldi	r25, 0x00	; 0
    1b52:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <SPI_MasterTransmit>
					if(input=='5')
    1b56:	15 33       	cpi	r17, 0x35	; 53
    1b58:	61 f4       	brne	.+24     	; 0x1b72 <adminpage+0x106>
					{
						ftemp =2;
						clear_screen();
    1b5a:	0e 94 cd 03 	call	0x79a	; 0x79a <clear_screen>
						LCD_VsnedString("Temp");
    1b5e:	c1 01       	movw	r24, r2
    1b60:	0e 94 da 03 	call	0x7b4	; 0x7b4 <LCD_VsnedString>
						LCD_VGOTO(1,0);
    1b64:	81 e0       	ldi	r24, 0x01	; 1
    1b66:	90 e0       	ldi	r25, 0x00	; 0
    1b68:	60 e0       	ldi	r22, 0x00	; 0
    1b6a:	70 e0       	ldi	r23, 0x00	; 0
    1b6c:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <LCD_VGOTO>
				if(input=='1' || input=='2' || input=='3' || input=='4'||input=='5')
				{
					SPI_MasterTransmit(input);
					if(input=='5')
					{
						ftemp =2;
    1b70:	54 01       	movw	r10, r8
			
		}			
		
		
		
		if(flagdisconect == 1)
    1b72:	80 91 cb 03 	lds	r24, 0x03CB
    1b76:	81 30       	cpi	r24, 0x01	; 1
    1b78:	a9 f4       	brne	.+42     	; 0x1ba4 <adminpage+0x138>
		{
			
			PORTD |=(1<<4);
    1b7a:	94 9a       	sbi	0x12, 4	; 18
			
			xTaskCreate(loginsreen,"checkpass",50,NULL,1,loginsreenhandel);
    1b7c:	e0 90 d9 03 	lds	r14, 0x03D9
    1b80:	f0 90 da 03 	lds	r15, 0x03DA
    1b84:	c3 01       	movw	r24, r6
    1b86:	b2 01       	movw	r22, r4
    1b88:	42 e3       	ldi	r20, 0x32	; 50
    1b8a:	50 e0       	ldi	r21, 0x00	; 0
    1b8c:	20 e0       	ldi	r18, 0x00	; 0
    1b8e:	30 e0       	ldi	r19, 0x00	; 0
    1b90:	01 e0       	ldi	r16, 0x01	; 1
    1b92:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <xTaskCreate>
			vTaskDelete(adminpagehandel);
    1b96:	80 91 d5 03 	lds	r24, 0x03D5
    1b9a:	90 91 d6 03 	lds	r25, 0x03D6
    1b9e:	0e 94 75 10 	call	0x20ea	; 0x20ea <vTaskDelete>
    1ba2:	90 cf       	rjmp	.-224    	; 0x1ac4 <adminpage+0x58>
		}
		else
		{
			PORTD ^=(1<<3);
    1ba4:	82 b3       	in	r24, 0x12	; 18
    1ba6:	8d 25       	eor	r24, r13
    1ba8:	82 bb       	out	0x12, r24	; 18
    1baa:	8f ef       	ldi	r24, 0xFF	; 255
    1bac:	91 ee       	ldi	r25, 0xE1	; 225
    1bae:	a4 e0       	ldi	r26, 0x04	; 4
    1bb0:	81 50       	subi	r24, 0x01	; 1
    1bb2:	90 40       	sbci	r25, 0x00	; 0
    1bb4:	a0 40       	sbci	r26, 0x00	; 0
    1bb6:	e1 f7       	brne	.-8      	; 0x1bb0 <adminpage+0x144>
    1bb8:	00 c0       	rjmp	.+0      	; 0x1bba <adminpage+0x14e>
    1bba:	00 00       	nop
    1bbc:	83 cf       	rjmp	.-250    	; 0x1ac4 <adminpage+0x58>

00001bbe <main>:



int main(void)
{
	sei();
    1bbe:	78 94       	sei
	LCD_VINIT();
    1bc0:	0e 94 97 03 	call	0x72e	; 0x72e <LCD_VINIT>
	keypad_init();
    1bc4:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <keypad_init>
	timer_init();
    1bc8:	0e 94 ae 18 	call	0x315c	; 0x315c <timer_init>
	SPI_MasterInit();
    1bcc:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <SPI_MasterInit>
	
	DDRD |=(1<<7);
    1bd0:	8f 9a       	sbi	0x11, 7	; 17
	DDRD |=(1<<6);
    1bd2:	8e 9a       	sbi	0x11, 6	; 17
	DDRD |=(1<<5);
    1bd4:	8d 9a       	sbi	0x11, 5	; 17
	DDRD |=(1<<4);
    1bd6:	8c 9a       	sbi	0x11, 4	; 17
			loginsreenhandel          // handler 
			);
		}
		else
		{
			xTaskCreate(block,"Abdullah",50,NULL ,1 ,blockhandel);
    1bd8:	0f 2e       	mov	r0, r31
    1bda:	f4 ed       	ldi	r31, 0xD4	; 212
    1bdc:	af 2e       	mov	r10, r31
    1bde:	fb e0       	ldi	r31, 0x0B	; 11
    1be0:	bf 2e       	mov	r11, r31
    1be2:	f0 2d       	mov	r31, r0
    1be4:	c3 e9       	ldi	r28, 0x93	; 147
    1be6:	d0 e0       	ldi	r29, 0x00	; 0
	
    while(1)
    {	
		if(read_eeprom(5)!='1')
		{
			xTaskCreate(
    1be8:	0f 2e       	mov	r0, r31
    1bea:	ff e6       	ldi	r31, 0x6F	; 111
    1bec:	cf 2e       	mov	r12, r31
    1bee:	fb e0       	ldi	r31, 0x0B	; 11
    1bf0:	df 2e       	mov	r13, r31
    1bf2:	f0 2d       	mov	r31, r0
	
	
	
    while(1)
    {	
		if(read_eeprom(5)!='1')
    1bf4:	85 e0       	ldi	r24, 0x05	; 5
    1bf6:	90 e0       	ldi	r25, 0x00	; 0
    1bf8:	0e 94 5f 00 	call	0xbe	; 0xbe <read_eeprom>
    1bfc:	81 33       	cpi	r24, 0x31	; 49
    1bfe:	91 05       	cpc	r25, r1
    1c00:	71 f0       	breq	.+28     	; 0x1c1e <main+0x60>
		{
			xTaskCreate(
    1c02:	e0 90 d9 03 	lds	r14, 0x03D9
    1c06:	f0 90 da 03 	lds	r15, 0x03DA
    1c0a:	c6 01       	movw	r24, r12
    1c0c:	be 01       	movw	r22, r28
    1c0e:	42 e3       	ldi	r20, 0x32	; 50
    1c10:	50 e0       	ldi	r21, 0x00	; 0
    1c12:	20 e0       	ldi	r18, 0x00	; 0
    1c14:	30 e0       	ldi	r19, 0x00	; 0
    1c16:	01 e0       	ldi	r16, 0x01	; 1
    1c18:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <xTaskCreate>
    1c1c:	0d c0       	rjmp	.+26     	; 0x1c38 <main+0x7a>
			loginsreenhandel          // handler 
			);
		}
		else
		{
			xTaskCreate(block,"Abdullah",50,NULL ,1 ,blockhandel);
    1c1e:	e0 90 d3 03 	lds	r14, 0x03D3
    1c22:	f0 90 d4 03 	lds	r15, 0x03D4
    1c26:	c5 01       	movw	r24, r10
    1c28:	be 01       	movw	r22, r28
    1c2a:	42 e3       	ldi	r20, 0x32	; 50
    1c2c:	50 e0       	ldi	r21, 0x00	; 0
    1c2e:	20 e0       	ldi	r18, 0x00	; 0
    1c30:	30 e0       	ldi	r19, 0x00	; 0
    1c32:	01 e0       	ldi	r16, 0x01	; 1
    1c34:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <xTaskCreate>
		}	
		
		
		vTaskStartScheduler();
    1c38:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vTaskStartScheduler>
		
    }
    1c3c:	db cf       	rjmp	.-74     	; 0x1bf4 <main+0x36>

00001c3e <__vector_10>:




ISR(TIMER0_COMP_vect)
{
    1c3e:	1f 92       	push	r1
    1c40:	0f 92       	push	r0
    1c42:	0f b6       	in	r0, 0x3f	; 63
    1c44:	0f 92       	push	r0
    1c46:	11 24       	eor	r1, r1
    1c48:	2f 93       	push	r18
    1c4a:	3f 93       	push	r19
    1c4c:	4f 93       	push	r20
    1c4e:	5f 93       	push	r21
    1c50:	6f 93       	push	r22
    1c52:	7f 93       	push	r23
    1c54:	8f 93       	push	r24
    1c56:	9f 93       	push	r25
    1c58:	af 93       	push	r26
    1c5a:	bf 93       	push	r27
    1c5c:	ef 93       	push	r30
    1c5e:	ff 93       	push	r31
	if(loginstat !=0)
    1c60:	80 91 d0 03 	lds	r24, 0x03D0
    1c64:	88 23       	and	r24, r24
    1c66:	09 f4       	brne	.+2      	; 0x1c6a <__vector_10+0x2c>
    1c68:	5b c0       	rjmp	.+182    	; 0x1d20 <__vector_10+0xe2>
	{
		
		if(loginstat==1 && timecount ==60000)
    1c6a:	81 30       	cpi	r24, 0x01	; 1
    1c6c:	99 f4       	brne	.+38     	; 0x1c94 <__vector_10+0x56>
    1c6e:	60 91 cc 03 	lds	r22, 0x03CC
    1c72:	70 91 cd 03 	lds	r23, 0x03CD
    1c76:	80 91 ce 03 	lds	r24, 0x03CE
    1c7a:	90 91 cf 03 	lds	r25, 0x03CF
    1c7e:	20 e0       	ldi	r18, 0x00	; 0
    1c80:	30 e6       	ldi	r19, 0x60	; 96
    1c82:	4a e6       	ldi	r20, 0x6A	; 106
    1c84:	57 e4       	ldi	r21, 0x47	; 71
    1c86:	0e 94 28 19 	call	0x3250	; 0x3250 <__cmpsf2>
    1c8a:	88 23       	and	r24, r24
    1c8c:	19 f4       	brne	.+6      	; 0x1c94 <__vector_10+0x56>
		{
			flagdisconect = 1;
    1c8e:	81 e0       	ldi	r24, 0x01	; 1
    1c90:	80 93 cb 03 	sts	0x03CB, r24
		}
		if(loginstat==2 && timecount ==30000)
    1c94:	80 91 d0 03 	lds	r24, 0x03D0
    1c98:	82 30       	cpi	r24, 0x02	; 2
    1c9a:	99 f4       	brne	.+38     	; 0x1cc2 <__vector_10+0x84>
    1c9c:	60 91 cc 03 	lds	r22, 0x03CC
    1ca0:	70 91 cd 03 	lds	r23, 0x03CD
    1ca4:	80 91 ce 03 	lds	r24, 0x03CE
    1ca8:	90 91 cf 03 	lds	r25, 0x03CF
    1cac:	20 e0       	ldi	r18, 0x00	; 0
    1cae:	30 e6       	ldi	r19, 0x60	; 96
    1cb0:	4a ee       	ldi	r20, 0xEA	; 234
    1cb2:	56 e4       	ldi	r21, 0x46	; 70
    1cb4:	0e 94 28 19 	call	0x3250	; 0x3250 <__cmpsf2>
    1cb8:	88 23       	and	r24, r24
    1cba:	19 f4       	brne	.+6      	; 0x1cc2 <__vector_10+0x84>
		{
			flagdisconect = 1;
    1cbc:	81 e0       	ldi	r24, 0x01	; 1
    1cbe:	80 93 cb 03 	sts	0x03CB, r24
		}
		
		if(loginstat==3 && timecount ==90000)
    1cc2:	80 91 d0 03 	lds	r24, 0x03D0
    1cc6:	83 30       	cpi	r24, 0x03	; 3
    1cc8:	99 f4       	brne	.+38     	; 0x1cf0 <__vector_10+0xb2>
    1cca:	60 91 cc 03 	lds	r22, 0x03CC
    1cce:	70 91 cd 03 	lds	r23, 0x03CD
    1cd2:	80 91 ce 03 	lds	r24, 0x03CE
    1cd6:	90 91 cf 03 	lds	r25, 0x03CF
    1cda:	20 e0       	ldi	r18, 0x00	; 0
    1cdc:	38 ec       	ldi	r19, 0xC8	; 200
    1cde:	4f ea       	ldi	r20, 0xAF	; 175
    1ce0:	57 e4       	ldi	r21, 0x47	; 71
    1ce2:	0e 94 28 19 	call	0x3250	; 0x3250 <__cmpsf2>
    1ce6:	88 23       	and	r24, r24
    1ce8:	19 f4       	brne	.+6      	; 0x1cf0 <__vector_10+0xb2>
		{
			flagdisconect=1;
    1cea:	81 e0       	ldi	r24, 0x01	; 1
    1cec:	80 93 cb 03 	sts	0x03CB, r24
		}
		
		
		timecount++;
    1cf0:	60 91 cc 03 	lds	r22, 0x03CC
    1cf4:	70 91 cd 03 	lds	r23, 0x03CD
    1cf8:	80 91 ce 03 	lds	r24, 0x03CE
    1cfc:	90 91 cf 03 	lds	r25, 0x03CF
    1d00:	20 e0       	ldi	r18, 0x00	; 0
    1d02:	30 e0       	ldi	r19, 0x00	; 0
    1d04:	40 e8       	ldi	r20, 0x80	; 128
    1d06:	5f e3       	ldi	r21, 0x3F	; 63
    1d08:	0e 94 c4 18 	call	0x3188	; 0x3188 <__addsf3>
    1d0c:	dc 01       	movw	r26, r24
    1d0e:	cb 01       	movw	r24, r22
    1d10:	80 93 cc 03 	sts	0x03CC, r24
    1d14:	90 93 cd 03 	sts	0x03CD, r25
    1d18:	a0 93 ce 03 	sts	0x03CE, r26
    1d1c:	b0 93 cf 03 	sts	0x03CF, r27
	
	
	
	
	
    1d20:	ff 91       	pop	r31
    1d22:	ef 91       	pop	r30
    1d24:	bf 91       	pop	r27
    1d26:	af 91       	pop	r26
    1d28:	9f 91       	pop	r25
    1d2a:	8f 91       	pop	r24
    1d2c:	7f 91       	pop	r23
    1d2e:	6f 91       	pop	r22
    1d30:	5f 91       	pop	r21
    1d32:	4f 91       	pop	r20
    1d34:	3f 91       	pop	r19
    1d36:	2f 91       	pop	r18
    1d38:	0f 90       	pop	r0
    1d3a:	0f be       	out	0x3f, r0	; 63
    1d3c:	0f 90       	pop	r0
    1d3e:	1f 90       	pop	r1
    1d40:	18 95       	reti

00001d42 <SPI_MasterInit>:


void SPI_MasterInit(void)
{
	/*Set clock to fosc/16*/
	SPCR |= (1<<SPR0);
    1d42:	68 9a       	sbi	0x0d, 0	; 13
	SPCR &= (~(1<<SPR1));
    1d44:	69 98       	cbi	0x0d, 1	; 13
	SPCR &= (~(1<<SPI2X));
    1d46:	68 98       	cbi	0x0d, 0	; 13
	
	/*Enable Master mode*/
	SPCR |=(1<<MSTR);
    1d48:	6c 9a       	sbi	0x0d, 4	; 13
	/*At the End,  Enable SPI*/
	SPCR |=(1<<SPE);
    1d4a:	6e 9a       	sbi	0x0d, 6	; 13
	/*Set SS--> Pin 4 / MOSI --> Pin 5 / SCK --> Pin 7 as outputs for master*/
	DDRB |=(1<<SS);
    1d4c:	bc 9a       	sbi	0x17, 4	; 23
	DDRB |=(1<<MOSI);
    1d4e:	bd 9a       	sbi	0x17, 5	; 23
	DDRB |=(1<<SCK);
    1d50:	bf 9a       	sbi	0x17, 7	; 23
	
	/*Set SS Pin to high*/
	PORTB |=(1<<SS);
    1d52:	c4 9a       	sbi	0x18, 4	; 24
}
    1d54:	08 95       	ret

00001d56 <SPI_MasterTransmit>:

void SPI_MasterTransmit(char Data)
{
	/*Clear SS to write to slave*/
	PORTB &=(~(1<<SS));
    1d56:	c4 98       	cbi	0x18, 4	; 24
	/*Put data on bus*/
	SPDR = Data;
    1d58:	8f b9       	out	0x0f, r24	; 15
	/*Wait until the transmission is finished*/
	while(((SPSR&(1<<SPIF))==0))
    1d5a:	77 9b       	sbis	0x0e, 7	; 14
    1d5c:	fe cf       	rjmp	.-4      	; 0x1d5a <SPI_MasterTransmit+0x4>
	{
		
		
	}
	/*Set SS to high*/
	PORTB |=(1<<SS);
    1d5e:	c4 9a       	sbi	0x18, 4	; 24
	
}
    1d60:	08 95       	ret

00001d62 <SPI_SlaveInit>:

void SPI_SlaveInit(void)
{
	/*Enable SPI*/
	SPCR |=(1<<SPE);
    1d62:	6e 9a       	sbi	0x0d, 6	; 13
	/*Set MISO as output*/
	PORTB &=(~(1<<MISO));
    1d64:	c6 98       	cbi	0x18, 6	; 24

}
    1d66:	08 95       	ret

00001d68 <SPI_SlaveReceive>:

char SPI_SlaveReceive(void)
{
	/*Wait until data is received in SPI register*/
	while(((SPSR&(1<<SPIF))==0))
    1d68:	77 9b       	sbis	0x0e, 7	; 14
    1d6a:	fe cf       	rjmp	.-4      	; 0x1d68 <SPI_SlaveReceive>
		
		
	}
	/*The data arrived read it*/
	
	return SPDR;
    1d6c:	8f b1       	in	r24, 0x0f	; 15
    1d6e:	08 95       	ret

00001d70 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    1d70:	fc 01       	movw	r30, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    1d72:	82 85       	ldd	r24, Z+10	; 0x0a
    1d74:	93 85       	ldd	r25, Z+11	; 0x0b
    1d76:	24 e0       	ldi	r18, 0x04	; 4
    1d78:	85 34       	cpi	r24, 0x45	; 69
    1d7a:	92 07       	cpc	r25, r18
    1d7c:	61 f4       	brne	.+24     	; 0x1d96 <prvTaskIsTaskSuspended+0x26>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    1d7e:	24 89       	ldd	r18, Z+20	; 0x14
    1d80:	35 89       	ldd	r19, Z+21	; 0x15
    1d82:	84 e0       	ldi	r24, 0x04	; 4
    1d84:	23 33       	cpi	r18, 0x33	; 51
    1d86:	38 07       	cpc	r19, r24
    1d88:	41 f0       	breq	.+16     	; 0x1d9a <prvTaskIsTaskSuspended+0x2a>

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
	BaseType_t xReturn = pdFALSE;
    1d8a:	81 e0       	ldi	r24, 0x01	; 1
    1d8c:	21 15       	cp	r18, r1
    1d8e:	31 05       	cpc	r19, r1
    1d90:	29 f0       	breq	.+10     	; 0x1d9c <prvTaskIsTaskSuspended+0x2c>
    1d92:	80 e0       	ldi	r24, 0x00	; 0
    1d94:	08 95       	ret
    1d96:	80 e0       	ldi	r24, 0x00	; 0
    1d98:	08 95       	ret
    1d9a:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    1d9c:	08 95       	ret

00001d9e <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1d9e:	e0 91 f1 03 	lds	r30, 0x03F1
    1da2:	f0 91 f2 03 	lds	r31, 0x03F2
    1da6:	80 81       	ld	r24, Z
    1da8:	88 23       	and	r24, r24
    1daa:	39 f4       	brne	.+14     	; 0x1dba <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    1dac:	8f ef       	ldi	r24, 0xFF	; 255
    1dae:	9f ef       	ldi	r25, 0xFF	; 255
    1db0:	90 93 e5 03 	sts	0x03E5, r25
    1db4:	80 93 e4 03 	sts	0x03E4, r24
    1db8:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1dba:	e0 91 f1 03 	lds	r30, 0x03F1
    1dbe:	f0 91 f2 03 	lds	r31, 0x03F2
    1dc2:	05 80       	ldd	r0, Z+5	; 0x05
    1dc4:	f6 81       	ldd	r31, Z+6	; 0x06
    1dc6:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    1dc8:	06 80       	ldd	r0, Z+6	; 0x06
    1dca:	f7 81       	ldd	r31, Z+7	; 0x07
    1dcc:	e0 2d       	mov	r30, r0
    1dce:	82 81       	ldd	r24, Z+2	; 0x02
    1dd0:	93 81       	ldd	r25, Z+3	; 0x03
    1dd2:	90 93 e5 03 	sts	0x03E5, r25
    1dd6:	80 93 e4 03 	sts	0x03E4, r24
    1dda:	08 95       	ret

00001ddc <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    1ddc:	ef 92       	push	r14
    1dde:	ff 92       	push	r15
    1de0:	1f 93       	push	r17
    1de2:	cf 93       	push	r28
    1de4:	df 93       	push	r29
    1de6:	ec 01       	movw	r28, r24
    1de8:	16 2f       	mov	r17, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    1dea:	e0 90 eb 03 	lds	r14, 0x03EB
    1dee:	f0 90 ec 03 	lds	r15, 0x03EC
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1df2:	80 91 e1 03 	lds	r24, 0x03E1
    1df6:	90 91 e2 03 	lds	r25, 0x03E2
    1dfa:	02 96       	adiw	r24, 0x02	; 2
    1dfc:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    1e00:	8f ef       	ldi	r24, 0xFF	; 255
    1e02:	cf 3f       	cpi	r28, 0xFF	; 255
    1e04:	d8 07       	cpc	r29, r24
    1e06:	69 f4       	brne	.+26     	; 0x1e22 <prvAddCurrentTaskToDelayedList+0x46>
    1e08:	11 23       	and	r17, r17
    1e0a:	59 f0       	breq	.+22     	; 0x1e22 <prvAddCurrentTaskToDelayedList+0x46>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1e0c:	60 91 e1 03 	lds	r22, 0x03E1
    1e10:	70 91 e2 03 	lds	r23, 0x03E2
    1e14:	6e 5f       	subi	r22, 0xFE	; 254
    1e16:	7f 4f       	sbci	r23, 0xFF	; 255
    1e18:	85 e4       	ldi	r24, 0x45	; 69
    1e1a:	94 e0       	ldi	r25, 0x04	; 4
    1e1c:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>
    1e20:	2f c0       	rjmp	.+94     	; 0x1e80 <prvAddCurrentTaskToDelayedList+0xa4>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    1e22:	ce 0d       	add	r28, r14
    1e24:	df 1d       	adc	r29, r15

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    1e26:	e0 91 e1 03 	lds	r30, 0x03E1
    1e2a:	f0 91 e2 03 	lds	r31, 0x03E2
    1e2e:	d3 83       	std	Z+3, r29	; 0x03
    1e30:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
    1e32:	ce 15       	cp	r28, r14
    1e34:	df 05       	cpc	r29, r15
    1e36:	68 f4       	brcc	.+26     	; 0x1e52 <prvAddCurrentTaskToDelayedList+0x76>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1e38:	80 91 ef 03 	lds	r24, 0x03EF
    1e3c:	90 91 f0 03 	lds	r25, 0x03F0
    1e40:	60 91 e1 03 	lds	r22, 0x03E1
    1e44:	70 91 e2 03 	lds	r23, 0x03E2
    1e48:	6e 5f       	subi	r22, 0xFE	; 254
    1e4a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e4c:	0e 94 18 05 	call	0xa30	; 0xa30 <vListInsert>
    1e50:	17 c0       	rjmp	.+46     	; 0x1e80 <prvAddCurrentTaskToDelayedList+0xa4>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1e52:	80 91 f1 03 	lds	r24, 0x03F1
    1e56:	90 91 f2 03 	lds	r25, 0x03F2
    1e5a:	60 91 e1 03 	lds	r22, 0x03E1
    1e5e:	70 91 e2 03 	lds	r23, 0x03E2
    1e62:	6e 5f       	subi	r22, 0xFE	; 254
    1e64:	7f 4f       	sbci	r23, 0xFF	; 255
    1e66:	0e 94 18 05 	call	0xa30	; 0xa30 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    1e6a:	80 91 e4 03 	lds	r24, 0x03E4
    1e6e:	90 91 e5 03 	lds	r25, 0x03E5
    1e72:	c8 17       	cp	r28, r24
    1e74:	d9 07       	cpc	r29, r25
    1e76:	20 f4       	brcc	.+8      	; 0x1e80 <prvAddCurrentTaskToDelayedList+0xa4>
				{
					xNextTaskUnblockTime = xTimeToWake;
    1e78:	d0 93 e5 03 	sts	0x03E5, r29
    1e7c:	c0 93 e4 03 	sts	0x03E4, r28

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    1e80:	df 91       	pop	r29
    1e82:	cf 91       	pop	r28
    1e84:	1f 91       	pop	r17
    1e86:	ff 90       	pop	r15
    1e88:	ef 90       	pop	r14
    1e8a:	08 95       	ret

00001e8c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    1e8c:	cf 93       	push	r28
    1e8e:	df 93       	push	r29
    1e90:	ec 01       	movw	r28, r24

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    1e92:	8f 89       	ldd	r24, Y+23	; 0x17
    1e94:	98 8d       	ldd	r25, Y+24	; 0x18
    1e96:	0e 94 b2 02 	call	0x564	; 0x564 <vPortFree>
			vPortFree( pxTCB );
    1e9a:	ce 01       	movw	r24, r28
    1e9c:	0e 94 b2 02 	call	0x564	; 0x564 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    1ea0:	df 91       	pop	r29
    1ea2:	cf 91       	pop	r28
    1ea4:	08 95       	ret

00001ea6 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    1ea6:	2f 92       	push	r2
    1ea8:	3f 92       	push	r3
    1eaa:	4f 92       	push	r4
    1eac:	5f 92       	push	r5
    1eae:	6f 92       	push	r6
    1eb0:	7f 92       	push	r7
    1eb2:	8f 92       	push	r8
    1eb4:	9f 92       	push	r9
    1eb6:	af 92       	push	r10
    1eb8:	bf 92       	push	r11
    1eba:	df 92       	push	r13
    1ebc:	ef 92       	push	r14
    1ebe:	ff 92       	push	r15
    1ec0:	0f 93       	push	r16
    1ec2:	1f 93       	push	r17
    1ec4:	cf 93       	push	r28
    1ec6:	df 93       	push	r29
    1ec8:	3c 01       	movw	r6, r24
    1eca:	5b 01       	movw	r10, r22
    1ecc:	ea 01       	movw	r28, r20
    1ece:	29 01       	movw	r4, r18
    1ed0:	d0 2e       	mov	r13, r16
    1ed2:	47 01       	movw	r8, r14
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1ed4:	ca 01       	movw	r24, r20
    1ed6:	0e 94 12 02 	call	0x424	; 0x424 <pvPortMalloc>
    1eda:	7c 01       	movw	r14, r24

			if( pxStack != NULL )
    1edc:	00 97       	sbiw	r24, 0x00	; 0
    1ede:	09 f4       	brne	.+2      	; 0x1ee2 <xTaskCreate+0x3c>
    1ee0:	ed c0       	rjmp	.+474    	; 0x20bc <xTaskCreate+0x216>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    1ee2:	8a e2       	ldi	r24, 0x2A	; 42
    1ee4:	90 e0       	ldi	r25, 0x00	; 0
    1ee6:	0e 94 12 02 	call	0x424	; 0x424 <pvPortMalloc>
    1eea:	8c 01       	movw	r16, r24

				if( pxNewTCB != NULL )
    1eec:	00 97       	sbiw	r24, 0x00	; 0
    1eee:	81 f0       	breq	.+32     	; 0x1f10 <xTaskCreate+0x6a>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    1ef0:	fc 01       	movw	r30, r24
    1ef2:	f0 8e       	std	Z+24, r15	; 0x18
    1ef4:	e7 8a       	std	Z+23, r14	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    1ef6:	21 97       	sbiw	r28, 0x01	; 1
    1ef8:	17 01       	movw	r2, r14
    1efa:	2c 0e       	add	r2, r28
    1efc:	3d 1e       	adc	r3, r29
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1efe:	f5 01       	movw	r30, r10
    1f00:	80 81       	ld	r24, Z
    1f02:	f8 01       	movw	r30, r16
    1f04:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1f06:	f5 01       	movw	r30, r10
    1f08:	80 81       	ld	r24, Z
    1f0a:	88 23       	and	r24, r24
    1f0c:	31 f4       	brne	.+12     	; 0x1f1a <xTaskCreate+0x74>
    1f0e:	13 c0       	rjmp	.+38     	; 0x1f36 <xTaskCreate+0x90>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    1f10:	c7 01       	movw	r24, r14
    1f12:	0e 94 b2 02 	call	0x564	; 0x564 <vPortFree>
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1f16:	8f ef       	ldi	r24, 0xFF	; 255
    1f18:	d6 c0       	rjmp	.+428    	; 0x20c6 <xTaskCreate+0x220>
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    1f1a:	e8 01       	movw	r28, r16
    1f1c:	6a 96       	adiw	r28, 0x1a	; 26
    1f1e:	d5 01       	movw	r26, r10
    1f20:	11 96       	adiw	r26, 0x01	; 1
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1f22:	81 e0       	ldi	r24, 0x01	; 1
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    1f24:	fd 01       	movw	r30, r26
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1f26:	9d 91       	ld	r25, X+
    1f28:	99 93       	st	Y+, r25

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1f2a:	90 81       	ld	r25, Z
    1f2c:	99 23       	and	r25, r25
    1f2e:	19 f0       	breq	.+6      	; 0x1f36 <xTaskCreate+0x90>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1f30:	8f 5f       	subi	r24, 0xFF	; 255
    1f32:	8a 30       	cpi	r24, 0x0A	; 10
    1f34:	b9 f7       	brne	.-18     	; 0x1f24 <xTaskCreate+0x7e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    1f36:	f8 01       	movw	r30, r16
    1f38:	12 a2       	lds	r17, 0x92
    1f3a:	cd 2d       	mov	r28, r13
    1f3c:	c5 30       	cpi	r28, 0x05	; 5
    1f3e:	08 f0       	brcs	.+2      	; 0x1f42 <xTaskCreate+0x9c>
    1f40:	c4 e0       	ldi	r28, 0x04	; 4
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    1f42:	f8 01       	movw	r30, r16
    1f44:	c6 8b       	std	Z+22, r28	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    1f46:	c3 a3       	lds	r28, 0x53
		pxNewTCB->uxMutexesHeld = 0;
    1f48:	14 a2       	lds	r17, 0x94
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    1f4a:	ee 24       	eor	r14, r14
    1f4c:	ff 24       	eor	r15, r15
    1f4e:	68 94       	set
    1f50:	e1 f8       	bld	r14, 1
    1f52:	e0 0e       	add	r14, r16
    1f54:	f1 1e       	adc	r15, r17
    1f56:	c7 01       	movw	r24, r14
    1f58:	0e 94 f5 04 	call	0x9ea	; 0x9ea <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    1f5c:	c8 01       	movw	r24, r16
    1f5e:	0c 96       	adiw	r24, 0x0c	; 12
    1f60:	0e 94 f5 04 	call	0x9ea	; 0x9ea <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    1f64:	f8 01       	movw	r30, r16
    1f66:	11 87       	std	Z+9, r17	; 0x09
    1f68:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1f6a:	85 e0       	ldi	r24, 0x05	; 5
    1f6c:	90 e0       	ldi	r25, 0x00	; 0
    1f6e:	8c 1b       	sub	r24, r28
    1f70:	91 09       	sbc	r25, r1
    1f72:	95 87       	std	Z+13, r25	; 0x0d
    1f74:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    1f76:	13 8b       	std	Z+19, r17	; 0x13
    1f78:	02 8b       	std	Z+18, r16	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    1f7a:	15 a2       	lds	r17, 0x95
    1f7c:	16 a2       	lds	r17, 0x96
    1f7e:	17 a2       	lds	r17, 0x97
    1f80:	10 a6       	lds	r17, 0xb0
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1f82:	11 a6       	lds	r17, 0xb1
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1f84:	c1 01       	movw	r24, r2
    1f86:	b3 01       	movw	r22, r6
    1f88:	a2 01       	movw	r20, r4
    1f8a:	0e 94 72 05 	call	0xae4	; 0xae4 <pxPortInitialiseStack>
    1f8e:	f8 01       	movw	r30, r16
    1f90:	91 83       	std	Z+1, r25	; 0x01
    1f92:	80 83       	st	Z, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    1f94:	81 14       	cp	r8, r1
    1f96:	91 04       	cpc	r9, r1
    1f98:	19 f0       	breq	.+6      	; 0x1fa0 <xTaskCreate+0xfa>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1f9a:	f4 01       	movw	r30, r8
    1f9c:	11 83       	std	Z+1, r17	; 0x01
    1f9e:	00 83       	st	Z, r16

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    1fa0:	0f b6       	in	r0, 0x3f	; 63
    1fa2:	f8 94       	cli
    1fa4:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    1fa6:	80 91 ed 03 	lds	r24, 0x03ED
    1faa:	8f 5f       	subi	r24, 0xFF	; 255
    1fac:	80 93 ed 03 	sts	0x03ED, r24
		if( pxCurrentTCB == NULL )
    1fb0:	80 91 e1 03 	lds	r24, 0x03E1
    1fb4:	90 91 e2 03 	lds	r25, 0x03E2
    1fb8:	00 97       	sbiw	r24, 0x00	; 0
    1fba:	09 f0       	breq	.+2      	; 0x1fbe <xTaskCreate+0x118>
    1fbc:	3f c0       	rjmp	.+126    	; 0x203c <xTaskCreate+0x196>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    1fbe:	10 93 e2 03 	sts	0x03E2, r17
    1fc2:	00 93 e1 03 	sts	0x03E1, r16

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1fc6:	80 91 ed 03 	lds	r24, 0x03ED
    1fca:	81 30       	cpi	r24, 0x01	; 1
    1fcc:	09 f0       	breq	.+2      	; 0x1fd0 <xTaskCreate+0x12a>
    1fce:	47 c0       	rjmp	.+142    	; 0x205e <xTaskCreate+0x1b8>
    1fd0:	c0 e0       	ldi	r28, 0x00	; 0
    1fd2:	d0 e0       	ldi	r29, 0x00	; 0
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1fd4:	ce 01       	movw	r24, r28
    1fd6:	88 0f       	add	r24, r24
    1fd8:	99 1f       	adc	r25, r25
    1fda:	88 0f       	add	r24, r24
    1fdc:	99 1f       	adc	r25, r25
    1fde:	88 0f       	add	r24, r24
    1fe0:	99 1f       	adc	r25, r25
    1fe2:	8c 0f       	add	r24, r28
    1fe4:	9d 1f       	adc	r25, r29
    1fe6:	8c 50       	subi	r24, 0x0C	; 12
    1fe8:	9c 4f       	sbci	r25, 0xFC	; 252
    1fea:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListInitialise>
    1fee:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1ff0:	c5 30       	cpi	r28, 0x05	; 5
    1ff2:	d1 05       	cpc	r29, r1
    1ff4:	79 f7       	brne	.-34     	; 0x1fd4 <xTaskCreate+0x12e>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    1ff6:	c1 e2       	ldi	r28, 0x21	; 33
    1ff8:	d4 e0       	ldi	r29, 0x04	; 4
    1ffa:	ce 01       	movw	r24, r28
    1ffc:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    2000:	0f 2e       	mov	r0, r31
    2002:	fa e2       	ldi	r31, 0x2A	; 42
    2004:	af 2e       	mov	r10, r31
    2006:	f4 e0       	ldi	r31, 0x04	; 4
    2008:	bf 2e       	mov	r11, r31
    200a:	f0 2d       	mov	r31, r0
    200c:	c5 01       	movw	r24, r10
    200e:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListInitialise>
	vListInitialise( &xPendingReadyList );
    2012:	83 e3       	ldi	r24, 0x33	; 51
    2014:	94 e0       	ldi	r25, 0x04	; 4
    2016:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    201a:	8c e3       	ldi	r24, 0x3C	; 60
    201c:	94 e0       	ldi	r25, 0x04	; 4
    201e:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    2022:	85 e4       	ldi	r24, 0x45	; 69
    2024:	94 e0       	ldi	r25, 0x04	; 4
    2026:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    202a:	d0 93 f2 03 	sts	0x03F2, r29
    202e:	c0 93 f1 03 	sts	0x03F1, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2032:	b0 92 f0 03 	sts	0x03F0, r11
    2036:	a0 92 ef 03 	sts	0x03EF, r10
    203a:	11 c0       	rjmp	.+34     	; 0x205e <xTaskCreate+0x1b8>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    203c:	80 91 e9 03 	lds	r24, 0x03E9
    2040:	88 23       	and	r24, r24
    2042:	69 f4       	brne	.+26     	; 0x205e <xTaskCreate+0x1b8>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    2044:	e0 91 e1 03 	lds	r30, 0x03E1
    2048:	f0 91 e2 03 	lds	r31, 0x03E2
    204c:	96 89       	ldd	r25, Z+22	; 0x16
    204e:	f8 01       	movw	r30, r16
    2050:	86 89       	ldd	r24, Z+22	; 0x16
    2052:	89 17       	cp	r24, r25
    2054:	20 f0       	brcs	.+8      	; 0x205e <xTaskCreate+0x1b8>
				{
					pxCurrentTCB = pxNewTCB;
    2056:	10 93 e2 03 	sts	0x03E2, r17
    205a:	00 93 e1 03 	sts	0x03E1, r16
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    205e:	80 91 f3 03 	lds	r24, 0x03F3
    2062:	8f 5f       	subi	r24, 0xFF	; 255
    2064:	80 93 f3 03 	sts	0x03F3, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    2068:	f8 01       	movw	r30, r16
    206a:	86 89       	ldd	r24, Z+22	; 0x16
    206c:	90 91 ea 03 	lds	r25, 0x03EA
    2070:	98 17       	cp	r25, r24
    2072:	10 f4       	brcc	.+4      	; 0x2078 <xTaskCreate+0x1d2>
    2074:	80 93 ea 03 	sts	0x03EA, r24
    2078:	90 e0       	ldi	r25, 0x00	; 0
    207a:	9c 01       	movw	r18, r24
    207c:	22 0f       	add	r18, r18
    207e:	33 1f       	adc	r19, r19
    2080:	22 0f       	add	r18, r18
    2082:	33 1f       	adc	r19, r19
    2084:	22 0f       	add	r18, r18
    2086:	33 1f       	adc	r19, r19
    2088:	82 0f       	add	r24, r18
    208a:	93 1f       	adc	r25, r19
    208c:	8c 50       	subi	r24, 0x0C	; 12
    208e:	9c 4f       	sbci	r25, 0xFC	; 252
    2090:	b7 01       	movw	r22, r14
    2092:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    2096:	0f 90       	pop	r0
    2098:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    209a:	80 91 e9 03 	lds	r24, 0x03E9
    209e:	88 23       	and	r24, r24
    20a0:	79 f0       	breq	.+30     	; 0x20c0 <xTaskCreate+0x21a>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    20a2:	e0 91 e1 03 	lds	r30, 0x03E1
    20a6:	f0 91 e2 03 	lds	r31, 0x03E2
    20aa:	96 89       	ldd	r25, Z+22	; 0x16
    20ac:	f8 01       	movw	r30, r16
    20ae:	86 89       	ldd	r24, Z+22	; 0x16
    20b0:	98 17       	cp	r25, r24
    20b2:	40 f4       	brcc	.+16     	; 0x20c4 <xTaskCreate+0x21e>
		{
			taskYIELD_IF_USING_PREEMPTION();
    20b4:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    20b8:	81 e0       	ldi	r24, 0x01	; 1
    20ba:	05 c0       	rjmp	.+10     	; 0x20c6 <xTaskCreate+0x220>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    20bc:	8f ef       	ldi	r24, 0xFF	; 255
    20be:	03 c0       	rjmp	.+6      	; 0x20c6 <xTaskCreate+0x220>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    20c0:	81 e0       	ldi	r24, 0x01	; 1
    20c2:	01 c0       	rjmp	.+2      	; 0x20c6 <xTaskCreate+0x220>
    20c4:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
		}

		return xReturn;
	}
    20c6:	df 91       	pop	r29
    20c8:	cf 91       	pop	r28
    20ca:	1f 91       	pop	r17
    20cc:	0f 91       	pop	r16
    20ce:	ff 90       	pop	r15
    20d0:	ef 90       	pop	r14
    20d2:	df 90       	pop	r13
    20d4:	bf 90       	pop	r11
    20d6:	af 90       	pop	r10
    20d8:	9f 90       	pop	r9
    20da:	8f 90       	pop	r8
    20dc:	7f 90       	pop	r7
    20de:	6f 90       	pop	r6
    20e0:	5f 90       	pop	r5
    20e2:	4f 90       	pop	r4
    20e4:	3f 90       	pop	r3
    20e6:	2f 90       	pop	r2
    20e8:	08 95       	ret

000020ea <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    20ea:	0f 93       	push	r16
    20ec:	1f 93       	push	r17
    20ee:	cf 93       	push	r28
    20f0:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    20f2:	0f b6       	in	r0, 0x3f	; 63
    20f4:	f8 94       	cli
    20f6:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    20f8:	00 97       	sbiw	r24, 0x00	; 0
    20fa:	29 f4       	brne	.+10     	; 0x2106 <vTaskDelete+0x1c>
    20fc:	c0 91 e1 03 	lds	r28, 0x03E1
    2100:	d0 91 e2 03 	lds	r29, 0x03E2
    2104:	01 c0       	rjmp	.+2      	; 0x2108 <vTaskDelete+0x1e>
    2106:	ec 01       	movw	r28, r24

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2108:	8e 01       	movw	r16, r28
    210a:	0e 5f       	subi	r16, 0xFE	; 254
    210c:	1f 4f       	sbci	r17, 0xFF	; 255
    210e:	c8 01       	movw	r24, r16
    2110:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2114:	8c 89       	ldd	r24, Y+20	; 0x14
    2116:	9d 89       	ldd	r25, Y+21	; 0x15
    2118:	00 97       	sbiw	r24, 0x00	; 0
    211a:	21 f0       	breq	.+8      	; 0x2124 <vTaskDelete+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    211c:	ce 01       	movw	r24, r28
    211e:	0c 96       	adiw	r24, 0x0c	; 12
    2120:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    2124:	80 91 f3 03 	lds	r24, 0x03F3
    2128:	8f 5f       	subi	r24, 0xFF	; 255
    212a:	80 93 f3 03 	sts	0x03F3, r24

			if( pxTCB == pxCurrentTCB )
    212e:	80 91 e1 03 	lds	r24, 0x03E1
    2132:	90 91 e2 03 	lds	r25, 0x03E2
    2136:	c8 17       	cp	r28, r24
    2138:	d9 07       	cpc	r29, r25
    213a:	59 f4       	brne	.+22     	; 0x2152 <vTaskDelete+0x68>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    213c:	8c e3       	ldi	r24, 0x3C	; 60
    213e:	94 e0       	ldi	r25, 0x04	; 4
    2140:	b8 01       	movw	r22, r16
    2142:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    2146:	80 91 ee 03 	lds	r24, 0x03EE
    214a:	8f 5f       	subi	r24, 0xFF	; 255
    214c:	80 93 ee 03 	sts	0x03EE, r24
    2150:	0a c0       	rjmp	.+20     	; 0x2166 <vTaskDelete+0x7c>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    2152:	80 91 ed 03 	lds	r24, 0x03ED
    2156:	81 50       	subi	r24, 0x01	; 1
    2158:	80 93 ed 03 	sts	0x03ED, r24
				prvDeleteTCB( pxTCB );
    215c:	ce 01       	movw	r24, r28
    215e:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    2162:	0e 94 cf 0e 	call	0x1d9e	; 0x1d9e <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    2166:	0f 90       	pop	r0
    2168:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    216a:	80 91 e9 03 	lds	r24, 0x03E9
    216e:	88 23       	and	r24, r24
    2170:	49 f0       	breq	.+18     	; 0x2184 <vTaskDelete+0x9a>
		{
			if( pxTCB == pxCurrentTCB )
    2172:	80 91 e1 03 	lds	r24, 0x03E1
    2176:	90 91 e2 03 	lds	r25, 0x03E2
    217a:	c8 17       	cp	r28, r24
    217c:	d9 07       	cpc	r29, r25
    217e:	11 f4       	brne	.+4      	; 0x2184 <vTaskDelete+0x9a>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    2180:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    2184:	df 91       	pop	r29
    2186:	cf 91       	pop	r28
    2188:	1f 91       	pop	r17
    218a:	0f 91       	pop	r16
    218c:	08 95       	ret

0000218e <uxTaskPriorityGet>:
	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    218e:	0f b6       	in	r0, 0x3f	; 63
    2190:	f8 94       	cli
    2192:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    2194:	00 97       	sbiw	r24, 0x00	; 0
    2196:	29 f4       	brne	.+10     	; 0x21a2 <uxTaskPriorityGet+0x14>
    2198:	e0 91 e1 03 	lds	r30, 0x03E1
    219c:	f0 91 e2 03 	lds	r31, 0x03E2
    21a0:	01 c0       	rjmp	.+2      	; 0x21a4 <uxTaskPriorityGet+0x16>
    21a2:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    21a4:	0f 90       	pop	r0
    21a6:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    21a8:	86 89       	ldd	r24, Z+22	; 0x16
    21aa:	08 95       	ret

000021ac <uxTaskPriorityGetFromISR>:

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    21ac:	00 97       	sbiw	r24, 0x00	; 0
    21ae:	29 f4       	brne	.+10     	; 0x21ba <uxTaskPriorityGetFromISR+0xe>
    21b0:	e0 91 e1 03 	lds	r30, 0x03E1
    21b4:	f0 91 e2 03 	lds	r31, 0x03E2
    21b8:	01 c0       	rjmp	.+2      	; 0x21bc <uxTaskPriorityGetFromISR+0x10>
    21ba:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
	}
    21bc:	86 89       	ldd	r24, Z+22	; 0x16
    21be:	08 95       	ret

000021c0 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    21c0:	ef 92       	push	r14
    21c2:	ff 92       	push	r15
    21c4:	1f 93       	push	r17
    21c6:	cf 93       	push	r28
    21c8:	df 93       	push	r29
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    21ca:	65 30       	cpi	r22, 0x05	; 5
    21cc:	08 f0       	brcs	.+2      	; 0x21d0 <vTaskPrioritySet+0x10>
    21ce:	64 e0       	ldi	r22, 0x04	; 4
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    21d0:	0f b6       	in	r0, 0x3f	; 63
    21d2:	f8 94       	cli
    21d4:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    21d6:	00 97       	sbiw	r24, 0x00	; 0
    21d8:	29 f4       	brne	.+10     	; 0x21e4 <vTaskPrioritySet+0x24>
    21da:	c0 91 e1 03 	lds	r28, 0x03E1
    21de:	d0 91 e2 03 	lds	r29, 0x03E2
    21e2:	01 c0       	rjmp	.+2      	; 0x21e6 <vTaskPrioritySet+0x26>
    21e4:	ec 01       	movw	r28, r24

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    21e6:	2b a1       	lds	r18, 0x4b
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    21e8:	26 17       	cp	r18, r22
    21ea:	09 f4       	brne	.+2      	; 0x21ee <vTaskPrioritySet+0x2e>
    21ec:	61 c0       	rjmp	.+194    	; 0x22b0 <vTaskPrioritySet+0xf0>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    21ee:	26 17       	cp	r18, r22
    21f0:	88 f4       	brcc	.+34     	; 0x2214 <vTaskPrioritySet+0x54>
				{
					if( pxTCB != pxCurrentTCB )
    21f2:	80 91 e1 03 	lds	r24, 0x03E1
    21f6:	90 91 e2 03 	lds	r25, 0x03E2
    21fa:	c8 17       	cp	r28, r24
    21fc:	d9 07       	cpc	r29, r25
    21fe:	a1 f0       	breq	.+40     	; 0x2228 <vTaskPrioritySet+0x68>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    2200:	e0 91 e1 03 	lds	r30, 0x03E1
    2204:	f0 91 e2 03 	lds	r31, 0x03E2
						{
							xYieldRequired = pdTRUE;
    2208:	11 e0       	ldi	r17, 0x01	; 1
    220a:	86 89       	ldd	r24, Z+22	; 0x16
    220c:	68 17       	cp	r22, r24
    220e:	68 f4       	brcc	.+26     	; 0x222a <vTaskPrioritySet+0x6a>
    2210:	10 e0       	ldi	r17, 0x00	; 0
    2212:	0b c0       	rjmp	.+22     	; 0x222a <vTaskPrioritySet+0x6a>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    2214:	80 91 e1 03 	lds	r24, 0x03E1
    2218:	90 91 e2 03 	lds	r25, 0x03E2
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
						{
							xYieldRequired = pdTRUE;
    221c:	11 e0       	ldi	r17, 0x01	; 1
    221e:	c8 17       	cp	r28, r24
    2220:	d9 07       	cpc	r29, r25
    2222:	19 f0       	breq	.+6      	; 0x222a <vTaskPrioritySet+0x6a>
    2224:	10 e0       	ldi	r17, 0x00	; 0
    2226:	01 c0       	rjmp	.+2      	; 0x222a <vTaskPrioritySet+0x6a>

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    2228:	10 e0       	ldi	r17, 0x00	; 0
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    222a:	8e 89       	ldd	r24, Y+22	; 0x16

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    222c:	28 17       	cp	r18, r24
    222e:	09 f4       	brne	.+2      	; 0x2232 <vTaskPrioritySet+0x72>
					{
						pxTCB->uxPriority = uxNewPriority;
    2230:	6e 8b       	std	Y+22, r22	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    2232:	6b a3       	lds	r22, 0x5b
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    2234:	2c 85       	ldd	r18, Y+12	; 0x0c
    2236:	3d 85       	ldd	r19, Y+13	; 0x0d
    2238:	33 23       	and	r19, r19
    223a:	34 f0       	brlt	.+12     	; 0x2248 <vTaskPrioritySet+0x88>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    223c:	25 e0       	ldi	r18, 0x05	; 5
    223e:	30 e0       	ldi	r19, 0x00	; 0
    2240:	26 1b       	sub	r18, r22
    2242:	31 09       	sbc	r19, r1
    2244:	3d 87       	std	Y+13, r19	; 0x0d
    2246:	2c 87       	std	Y+12, r18	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    2248:	90 e0       	ldi	r25, 0x00	; 0
    224a:	9c 01       	movw	r18, r24
    224c:	22 0f       	add	r18, r18
    224e:	33 1f       	adc	r19, r19
    2250:	22 0f       	add	r18, r18
    2252:	33 1f       	adc	r19, r19
    2254:	22 0f       	add	r18, r18
    2256:	33 1f       	adc	r19, r19
    2258:	82 0f       	add	r24, r18
    225a:	93 1f       	adc	r25, r19
    225c:	8c 50       	subi	r24, 0x0C	; 12
    225e:	9c 4f       	sbci	r25, 0xFC	; 252
    2260:	2a 85       	ldd	r18, Y+10	; 0x0a
    2262:	3b 85       	ldd	r19, Y+11	; 0x0b
    2264:	28 17       	cp	r18, r24
    2266:	39 07       	cpc	r19, r25
    2268:	f9 f4       	brne	.+62     	; 0x22a8 <vTaskPrioritySet+0xe8>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    226a:	ee 24       	eor	r14, r14
    226c:	ff 24       	eor	r15, r15
    226e:	68 94       	set
    2270:	e1 f8       	bld	r14, 1
    2272:	ec 0e       	add	r14, r28
    2274:	fd 1e       	adc	r15, r29
    2276:	c7 01       	movw	r24, r14
    2278:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    227c:	8e 89       	ldd	r24, Y+22	; 0x16
    227e:	90 91 ea 03 	lds	r25, 0x03EA
    2282:	98 17       	cp	r25, r24
    2284:	10 f4       	brcc	.+4      	; 0x228a <vTaskPrioritySet+0xca>
    2286:	80 93 ea 03 	sts	0x03EA, r24
    228a:	90 e0       	ldi	r25, 0x00	; 0
    228c:	9c 01       	movw	r18, r24
    228e:	22 0f       	add	r18, r18
    2290:	33 1f       	adc	r19, r19
    2292:	22 0f       	add	r18, r18
    2294:	33 1f       	adc	r19, r19
    2296:	22 0f       	add	r18, r18
    2298:	33 1f       	adc	r19, r19
    229a:	82 0f       	add	r24, r18
    229c:	93 1f       	adc	r25, r19
    229e:	8c 50       	subi	r24, 0x0C	; 12
    22a0:	9c 4f       	sbci	r25, 0xFC	; 252
    22a2:	b7 01       	movw	r22, r14
    22a4:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    22a8:	11 23       	and	r17, r17
    22aa:	11 f0       	breq	.+4      	; 0x22b0 <vTaskPrioritySet+0xf0>
				{
					taskYIELD_IF_USING_PREEMPTION();
    22ac:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    22b0:	0f 90       	pop	r0
    22b2:	0f be       	out	0x3f, r0	; 63
	}
    22b4:	df 91       	pop	r29
    22b6:	cf 91       	pop	r28
    22b8:	1f 91       	pop	r17
    22ba:	ff 90       	pop	r15
    22bc:	ef 90       	pop	r14
    22be:	08 95       	ret

000022c0 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    22c0:	0f 93       	push	r16
    22c2:	1f 93       	push	r17
    22c4:	cf 93       	push	r28
    22c6:	df 93       	push	r29
    22c8:	ec 01       	movw	r28, r24
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    22ca:	00 97       	sbiw	r24, 0x00	; 0
    22cc:	b9 f1       	breq	.+110    	; 0x233c <vTaskResume+0x7c>
    22ce:	80 91 e1 03 	lds	r24, 0x03E1
    22d2:	90 91 e2 03 	lds	r25, 0x03E2
    22d6:	c8 17       	cp	r28, r24
    22d8:	d9 07       	cpc	r29, r25
    22da:	81 f1       	breq	.+96     	; 0x233c <vTaskResume+0x7c>
		{
			taskENTER_CRITICAL();
    22dc:	0f b6       	in	r0, 0x3f	; 63
    22de:	f8 94       	cli
    22e0:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    22e2:	ce 01       	movw	r24, r28
    22e4:	0e 94 b8 0e 	call	0x1d70	; 0x1d70 <prvTaskIsTaskSuspended>
    22e8:	88 23       	and	r24, r24
    22ea:	31 f1       	breq	.+76     	; 0x2338 <vTaskResume+0x78>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    22ec:	8e 01       	movw	r16, r28
    22ee:	0e 5f       	subi	r16, 0xFE	; 254
    22f0:	1f 4f       	sbci	r17, 0xFF	; 255
    22f2:	c8 01       	movw	r24, r16
    22f4:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    22f8:	8e 89       	ldd	r24, Y+22	; 0x16
    22fa:	90 91 ea 03 	lds	r25, 0x03EA
    22fe:	98 17       	cp	r25, r24
    2300:	10 f4       	brcc	.+4      	; 0x2306 <vTaskResume+0x46>
    2302:	80 93 ea 03 	sts	0x03EA, r24
    2306:	90 e0       	ldi	r25, 0x00	; 0
    2308:	9c 01       	movw	r18, r24
    230a:	22 0f       	add	r18, r18
    230c:	33 1f       	adc	r19, r19
    230e:	22 0f       	add	r18, r18
    2310:	33 1f       	adc	r19, r19
    2312:	22 0f       	add	r18, r18
    2314:	33 1f       	adc	r19, r19
    2316:	82 0f       	add	r24, r18
    2318:	93 1f       	adc	r25, r19
    231a:	8c 50       	subi	r24, 0x0C	; 12
    231c:	9c 4f       	sbci	r25, 0xFC	; 252
    231e:	b8 01       	movw	r22, r16
    2320:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2324:	e0 91 e1 03 	lds	r30, 0x03E1
    2328:	f0 91 e2 03 	lds	r31, 0x03E2
    232c:	9e 89       	ldd	r25, Y+22	; 0x16
    232e:	86 89       	ldd	r24, Z+22	; 0x16
    2330:	98 17       	cp	r25, r24
    2332:	10 f0       	brcs	.+4      	; 0x2338 <vTaskResume+0x78>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    2334:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2338:	0f 90       	pop	r0
    233a:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    233c:	df 91       	pop	r29
    233e:	cf 91       	pop	r28
    2340:	1f 91       	pop	r17
    2342:	0f 91       	pop	r16
    2344:	08 95       	ret

00002346 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    2346:	ef 92       	push	r14
    2348:	ff 92       	push	r15
    234a:	1f 93       	push	r17
    234c:	cf 93       	push	r28
    234e:	df 93       	push	r29
    2350:	ec 01       	movw	r28, r24
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    2352:	0e 94 b8 0e 	call	0x1d70	; 0x1d70 <prvTaskIsTaskSuspended>
    2356:	88 23       	and	r24, r24
    2358:	b9 f1       	breq	.+110    	; 0x23c8 <xTaskResumeFromISR+0x82>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    235a:	80 91 e3 03 	lds	r24, 0x03E3
    235e:	88 23       	and	r24, r24
    2360:	51 f5       	brne	.+84     	; 0x23b6 <xTaskResumeFromISR+0x70>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2362:	e0 91 e1 03 	lds	r30, 0x03E1
    2366:	f0 91 e2 03 	lds	r31, 0x03E2

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
    236a:	11 e0       	ldi	r17, 0x01	; 1
    236c:	9e 89       	ldd	r25, Y+22	; 0x16
    236e:	86 89       	ldd	r24, Z+22	; 0x16
    2370:	98 17       	cp	r25, r24
    2372:	08 f4       	brcc	.+2      	; 0x2376 <xTaskResumeFromISR+0x30>
    2374:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2376:	ee 24       	eor	r14, r14
    2378:	ff 24       	eor	r15, r15
    237a:	68 94       	set
    237c:	e1 f8       	bld	r14, 1
    237e:	ec 0e       	add	r14, r28
    2380:	fd 1e       	adc	r15, r29
    2382:	c7 01       	movw	r24, r14
    2384:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2388:	8e 89       	ldd	r24, Y+22	; 0x16
    238a:	90 91 ea 03 	lds	r25, 0x03EA
    238e:	98 17       	cp	r25, r24
    2390:	10 f4       	brcc	.+4      	; 0x2396 <xTaskResumeFromISR+0x50>
    2392:	80 93 ea 03 	sts	0x03EA, r24
    2396:	90 e0       	ldi	r25, 0x00	; 0
    2398:	9c 01       	movw	r18, r24
    239a:	22 0f       	add	r18, r18
    239c:	33 1f       	adc	r19, r19
    239e:	22 0f       	add	r18, r18
    23a0:	33 1f       	adc	r19, r19
    23a2:	22 0f       	add	r18, r18
    23a4:	33 1f       	adc	r19, r19
    23a6:	82 0f       	add	r24, r18
    23a8:	93 1f       	adc	r25, r19
    23aa:	8c 50       	subi	r24, 0x0C	; 12
    23ac:	9c 4f       	sbci	r25, 0xFC	; 252
    23ae:	b7 01       	movw	r22, r14
    23b0:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>
    23b4:	0a c0       	rjmp	.+20     	; 0x23ca <xTaskResumeFromISR+0x84>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    23b6:	be 01       	movw	r22, r28
    23b8:	64 5f       	subi	r22, 0xF4	; 244
    23ba:	7f 4f       	sbci	r23, 0xFF	; 255
    23bc:	83 e3       	ldi	r24, 0x33	; 51
    23be:	94 e0       	ldi	r25, 0x04	; 4
    23c0:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
    23c4:	10 e0       	ldi	r17, 0x00	; 0
    23c6:	01 c0       	rjmp	.+2      	; 0x23ca <xTaskResumeFromISR+0x84>
    23c8:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
    23ca:	81 2f       	mov	r24, r17
    23cc:	df 91       	pop	r29
    23ce:	cf 91       	pop	r28
    23d0:	1f 91       	pop	r17
    23d2:	ff 90       	pop	r15
    23d4:	ef 90       	pop	r14
    23d6:	08 95       	ret

000023d8 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    23d8:	ef 92       	push	r14
    23da:	ff 92       	push	r15
    23dc:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    23de:	81 e6       	ldi	r24, 0x61	; 97
    23e0:	93 e1       	ldi	r25, 0x13	; 19
    23e2:	6c e9       	ldi	r22, 0x9C	; 156
    23e4:	70 e0       	ldi	r23, 0x00	; 0
    23e6:	48 ec       	ldi	r20, 0xC8	; 200
    23e8:	50 e0       	ldi	r21, 0x00	; 0
    23ea:	20 e0       	ldi	r18, 0x00	; 0
    23ec:	30 e0       	ldi	r19, 0x00	; 0
    23ee:	00 e0       	ldi	r16, 0x00	; 0
    23f0:	0f 2e       	mov	r0, r31
    23f2:	fe e4       	ldi	r31, 0x4E	; 78
    23f4:	ef 2e       	mov	r14, r31
    23f6:	f4 e0       	ldi	r31, 0x04	; 4
    23f8:	ff 2e       	mov	r15, r31
    23fa:	f0 2d       	mov	r31, r0
    23fc:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    2400:	81 30       	cpi	r24, 0x01	; 1
    2402:	81 f4       	brne	.+32     	; 0x2424 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    2404:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    2406:	8f ef       	ldi	r24, 0xFF	; 255
    2408:	9f ef       	ldi	r25, 0xFF	; 255
    240a:	90 93 e5 03 	sts	0x03E5, r25
    240e:	80 93 e4 03 	sts	0x03E4, r24
		xSchedulerRunning = pdTRUE;
    2412:	81 e0       	ldi	r24, 0x01	; 1
    2414:	80 93 e9 03 	sts	0x03E9, r24
		xTickCount = ( TickType_t ) 0U;
    2418:	10 92 ec 03 	sts	0x03EC, r1
    241c:	10 92 eb 03 	sts	0x03EB, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2420:	0e 94 02 06 	call	0xc04	; 0xc04 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    2424:	0f 91       	pop	r16
    2426:	ff 90       	pop	r15
    2428:	ef 90       	pop	r14
    242a:	08 95       	ret

0000242c <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    242c:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    242e:	10 92 e9 03 	sts	0x03E9, r1
	vPortEndScheduler();
    2432:	0e 94 37 06 	call	0xc6e	; 0xc6e <vPortEndScheduler>
}
    2436:	08 95       	ret

00002438 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    2438:	80 91 e3 03 	lds	r24, 0x03E3
    243c:	8f 5f       	subi	r24, 0xFF	; 255
    243e:	80 93 e3 03 	sts	0x03E3, r24
}
    2442:	08 95       	ret

00002444 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    2444:	0f b6       	in	r0, 0x3f	; 63
    2446:	f8 94       	cli
    2448:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    244a:	80 91 eb 03 	lds	r24, 0x03EB
    244e:	90 91 ec 03 	lds	r25, 0x03EC
	}
	portTICK_TYPE_EXIT_CRITICAL();
    2452:	0f 90       	pop	r0
    2454:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    2456:	08 95       	ret

00002458 <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    2458:	80 91 eb 03 	lds	r24, 0x03EB
    245c:	90 91 ec 03 	lds	r25, 0x03EC
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2460:	08 95       	ret

00002462 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    2462:	80 91 ed 03 	lds	r24, 0x03ED
}
    2466:	08 95       	ret

00002468 <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    2468:	00 97       	sbiw	r24, 0x00	; 0
    246a:	21 f4       	brne	.+8      	; 0x2474 <pcTaskGetName+0xc>
    246c:	80 91 e1 03 	lds	r24, 0x03E1
    2470:	90 91 e2 03 	lds	r25, 0x03E2
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    2474:	49 96       	adiw	r24, 0x19	; 25
}
    2476:	08 95       	ret

00002478 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    2478:	cf 92       	push	r12
    247a:	df 92       	push	r13
    247c:	ef 92       	push	r14
    247e:	ff 92       	push	r15
    2480:	0f 93       	push	r16
    2482:	1f 93       	push	r17
    2484:	cf 93       	push	r28
    2486:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2488:	80 91 e3 03 	lds	r24, 0x03E3
    248c:	88 23       	and	r24, r24
    248e:	09 f0       	breq	.+2      	; 0x2492 <xTaskIncrementTick+0x1a>
    2490:	82 c0       	rjmp	.+260    	; 0x2596 <xTaskIncrementTick+0x11e>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    2492:	c0 90 eb 03 	lds	r12, 0x03EB
    2496:	d0 90 ec 03 	lds	r13, 0x03EC
    249a:	08 94       	sec
    249c:	c1 1c       	adc	r12, r1
    249e:	d1 1c       	adc	r13, r1

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    24a0:	d0 92 ec 03 	sts	0x03EC, r13
    24a4:	c0 92 eb 03 	sts	0x03EB, r12

		if( xConstTickCount == ( TickType_t ) 0U )
    24a8:	c1 14       	cp	r12, r1
    24aa:	d1 04       	cpc	r13, r1
    24ac:	b9 f4       	brne	.+46     	; 0x24dc <xTaskIncrementTick+0x64>
		{
			taskSWITCH_DELAYED_LISTS();
    24ae:	80 91 f1 03 	lds	r24, 0x03F1
    24b2:	90 91 f2 03 	lds	r25, 0x03F2
    24b6:	20 91 ef 03 	lds	r18, 0x03EF
    24ba:	30 91 f0 03 	lds	r19, 0x03F0
    24be:	30 93 f2 03 	sts	0x03F2, r19
    24c2:	20 93 f1 03 	sts	0x03F1, r18
    24c6:	90 93 f0 03 	sts	0x03F0, r25
    24ca:	80 93 ef 03 	sts	0x03EF, r24
    24ce:	80 91 e6 03 	lds	r24, 0x03E6
    24d2:	8f 5f       	subi	r24, 0xFF	; 255
    24d4:	80 93 e6 03 	sts	0x03E6, r24
    24d8:	0e 94 cf 0e 	call	0x1d9e	; 0x1d9e <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    24dc:	80 91 e4 03 	lds	r24, 0x03E4
    24e0:	90 91 e5 03 	lds	r25, 0x03E5
    24e4:	c8 16       	cp	r12, r24
    24e6:	d9 06       	cpc	r13, r25
    24e8:	20 f4       	brcc	.+8      	; 0x24f2 <xTaskIncrementTick+0x7a>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    24ea:	ff 24       	eor	r15, r15
    24ec:	5a c0       	rjmp	.+180    	; 0x25a2 <xTaskIncrementTick+0x12a>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    24ee:	fe 2c       	mov	r15, r14
    24f0:	03 c0       	rjmp	.+6      	; 0x24f8 <xTaskIncrementTick+0x80>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    24f2:	ff 24       	eor	r15, r15
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    24f4:	ee 24       	eor	r14, r14
    24f6:	e3 94       	inc	r14
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    24f8:	e0 91 f1 03 	lds	r30, 0x03F1
    24fc:	f0 91 f2 03 	lds	r31, 0x03F2
    2500:	80 81       	ld	r24, Z
    2502:	88 23       	and	r24, r24
    2504:	39 f4       	brne	.+14     	; 0x2514 <xTaskIncrementTick+0x9c>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2506:	8f ef       	ldi	r24, 0xFF	; 255
    2508:	9f ef       	ldi	r25, 0xFF	; 255
    250a:	90 93 e5 03 	sts	0x03E5, r25
    250e:	80 93 e4 03 	sts	0x03E4, r24
					break;
    2512:	47 c0       	rjmp	.+142    	; 0x25a2 <xTaskIncrementTick+0x12a>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2514:	e0 91 f1 03 	lds	r30, 0x03F1
    2518:	f0 91 f2 03 	lds	r31, 0x03F2
    251c:	05 80       	ldd	r0, Z+5	; 0x05
    251e:	f6 81       	ldd	r31, Z+6	; 0x06
    2520:	e0 2d       	mov	r30, r0
    2522:	c6 81       	ldd	r28, Z+6	; 0x06
    2524:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    2526:	8a 81       	ldd	r24, Y+2	; 0x02
    2528:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
    252a:	c8 16       	cp	r12, r24
    252c:	d9 06       	cpc	r13, r25
    252e:	28 f4       	brcc	.+10     	; 0x253a <xTaskIncrementTick+0xc2>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    2530:	90 93 e5 03 	sts	0x03E5, r25
    2534:	80 93 e4 03 	sts	0x03E4, r24
						break;
    2538:	34 c0       	rjmp	.+104    	; 0x25a2 <xTaskIncrementTick+0x12a>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    253a:	8e 01       	movw	r16, r28
    253c:	0e 5f       	subi	r16, 0xFE	; 254
    253e:	1f 4f       	sbci	r17, 0xFF	; 255
    2540:	c8 01       	movw	r24, r16
    2542:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2546:	8c 89       	ldd	r24, Y+20	; 0x14
    2548:	9d 89       	ldd	r25, Y+21	; 0x15
    254a:	00 97       	sbiw	r24, 0x00	; 0
    254c:	21 f0       	breq	.+8      	; 0x2556 <xTaskIncrementTick+0xde>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    254e:	ce 01       	movw	r24, r28
    2550:	0c 96       	adiw	r24, 0x0c	; 12
    2552:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    2556:	8e 89       	ldd	r24, Y+22	; 0x16
    2558:	90 91 ea 03 	lds	r25, 0x03EA
    255c:	98 17       	cp	r25, r24
    255e:	10 f4       	brcc	.+4      	; 0x2564 <xTaskIncrementTick+0xec>
    2560:	80 93 ea 03 	sts	0x03EA, r24
    2564:	90 e0       	ldi	r25, 0x00	; 0
    2566:	9c 01       	movw	r18, r24
    2568:	22 0f       	add	r18, r18
    256a:	33 1f       	adc	r19, r19
    256c:	22 0f       	add	r18, r18
    256e:	33 1f       	adc	r19, r19
    2570:	22 0f       	add	r18, r18
    2572:	33 1f       	adc	r19, r19
    2574:	82 0f       	add	r24, r18
    2576:	93 1f       	adc	r25, r19
    2578:	8c 50       	subi	r24, 0x0C	; 12
    257a:	9c 4f       	sbci	r25, 0xFC	; 252
    257c:	b8 01       	movw	r22, r16
    257e:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2582:	e0 91 e1 03 	lds	r30, 0x03E1
    2586:	f0 91 e2 03 	lds	r31, 0x03E2
    258a:	9e 89       	ldd	r25, Y+22	; 0x16
    258c:	86 89       	ldd	r24, Z+22	; 0x16
    258e:	98 17       	cp	r25, r24
    2590:	08 f0       	brcs	.+2      	; 0x2594 <xTaskIncrementTick+0x11c>
    2592:	ad cf       	rjmp	.-166    	; 0x24ee <xTaskIncrementTick+0x76>
    2594:	b1 cf       	rjmp	.-158    	; 0x24f8 <xTaskIncrementTick+0x80>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    2596:	80 91 e8 03 	lds	r24, 0x03E8
    259a:	8f 5f       	subi	r24, 0xFF	; 255
    259c:	80 93 e8 03 	sts	0x03E8, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    25a0:	ff 24       	eor	r15, r15
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    25a2:	80 91 e7 03 	lds	r24, 0x03E7
    25a6:	88 23       	and	r24, r24
    25a8:	11 f0       	breq	.+4      	; 0x25ae <xTaskIncrementTick+0x136>
		{
			xSwitchRequired = pdTRUE;
    25aa:	ff 24       	eor	r15, r15
    25ac:	f3 94       	inc	r15
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    25ae:	8f 2d       	mov	r24, r15
    25b0:	df 91       	pop	r29
    25b2:	cf 91       	pop	r28
    25b4:	1f 91       	pop	r17
    25b6:	0f 91       	pop	r16
    25b8:	ff 90       	pop	r15
    25ba:	ef 90       	pop	r14
    25bc:	df 90       	pop	r13
    25be:	cf 90       	pop	r12
    25c0:	08 95       	ret

000025c2 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    25c2:	df 92       	push	r13
    25c4:	ef 92       	push	r14
    25c6:	ff 92       	push	r15
    25c8:	0f 93       	push	r16
    25ca:	1f 93       	push	r17
    25cc:	cf 93       	push	r28
    25ce:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    25d0:	0f b6       	in	r0, 0x3f	; 63
    25d2:	f8 94       	cli
    25d4:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    25d6:	80 91 e3 03 	lds	r24, 0x03E3
    25da:	81 50       	subi	r24, 0x01	; 1
    25dc:	80 93 e3 03 	sts	0x03E3, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    25e0:	80 91 e3 03 	lds	r24, 0x03E3
    25e4:	88 23       	and	r24, r24
    25e6:	09 f0       	breq	.+2      	; 0x25ea <xTaskResumeAll+0x28>
    25e8:	5f c0       	rjmp	.+190    	; 0x26a8 <xTaskResumeAll+0xe6>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    25ea:	80 91 ed 03 	lds	r24, 0x03ED
    25ee:	88 23       	and	r24, r24
    25f0:	91 f5       	brne	.+100    	; 0x2656 <xTaskResumeAll+0x94>
    25f2:	5d c0       	rjmp	.+186    	; 0x26ae <xTaskResumeAll+0xec>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    25f4:	e0 91 38 04 	lds	r30, 0x0438
    25f8:	f0 91 39 04 	lds	r31, 0x0439
    25fc:	c6 81       	ldd	r28, Z+6	; 0x06
    25fe:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2600:	ce 01       	movw	r24, r28
    2602:	0c 96       	adiw	r24, 0x0c	; 12
    2604:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2608:	8e 01       	movw	r16, r28
    260a:	0e 5f       	subi	r16, 0xFE	; 254
    260c:	1f 4f       	sbci	r17, 0xFF	; 255
    260e:	c8 01       	movw	r24, r16
    2610:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2614:	8e 89       	ldd	r24, Y+22	; 0x16
    2616:	90 91 ea 03 	lds	r25, 0x03EA
    261a:	98 17       	cp	r25, r24
    261c:	10 f4       	brcc	.+4      	; 0x2622 <xTaskResumeAll+0x60>
    261e:	80 93 ea 03 	sts	0x03EA, r24
    2622:	90 e0       	ldi	r25, 0x00	; 0
    2624:	9c 01       	movw	r18, r24
    2626:	22 0f       	add	r18, r18
    2628:	33 1f       	adc	r19, r19
    262a:	22 0f       	add	r18, r18
    262c:	33 1f       	adc	r19, r19
    262e:	22 0f       	add	r18, r18
    2630:	33 1f       	adc	r19, r19
    2632:	82 0f       	add	r24, r18
    2634:	93 1f       	adc	r25, r19
    2636:	8c 50       	subi	r24, 0x0C	; 12
    2638:	9c 4f       	sbci	r25, 0xFC	; 252
    263a:	b8 01       	movw	r22, r16
    263c:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2640:	e0 91 e1 03 	lds	r30, 0x03E1
    2644:	f0 91 e2 03 	lds	r31, 0x03E2
    2648:	9e 89       	ldd	r25, Y+22	; 0x16
    264a:	86 89       	ldd	r24, Z+22	; 0x16
    264c:	98 17       	cp	r25, r24
    264e:	68 f0       	brcs	.+26     	; 0x266a <xTaskResumeAll+0xa8>
					{
						xYieldPending = pdTRUE;
    2650:	d0 92 e7 03 	sts	0x03E7, r13
    2654:	0a c0       	rjmp	.+20     	; 0x266a <xTaskResumeAll+0xa8>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    2656:	c0 e0       	ldi	r28, 0x00	; 0
    2658:	d0 e0       	ldi	r29, 0x00	; 0
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    265a:	0f 2e       	mov	r0, r31
    265c:	f3 e3       	ldi	r31, 0x33	; 51
    265e:	ef 2e       	mov	r14, r31
    2660:	f4 e0       	ldi	r31, 0x04	; 4
    2662:	ff 2e       	mov	r15, r31
    2664:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    2666:	dd 24       	eor	r13, r13
    2668:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    266a:	f7 01       	movw	r30, r14
    266c:	80 81       	ld	r24, Z
    266e:	88 23       	and	r24, r24
    2670:	09 f6       	brne	.-126    	; 0x25f4 <xTaskResumeAll+0x32>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    2672:	20 97       	sbiw	r28, 0x00	; 0
    2674:	11 f0       	breq	.+4      	; 0x267a <xTaskResumeAll+0xb8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    2676:	0e 94 cf 0e 	call	0x1d9e	; 0x1d9e <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    267a:	c0 91 e8 03 	lds	r28, 0x03E8

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    267e:	cc 23       	and	r28, r28
    2680:	59 f0       	breq	.+22     	; 0x2698 <xTaskResumeAll+0xd6>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
    2682:	01 e0       	ldi	r16, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    2684:	0e 94 3c 12 	call	0x2478	; 0x2478 <xTaskIncrementTick>
    2688:	88 23       	and	r24, r24
    268a:	11 f0       	breq	.+4      	; 0x2690 <xTaskResumeAll+0xce>
							{
								xYieldPending = pdTRUE;
    268c:	00 93 e7 03 	sts	0x03E7, r16
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    2690:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    2692:	c1 f7       	brne	.-16     	; 0x2684 <xTaskResumeAll+0xc2>

						uxPendedTicks = 0;
    2694:	10 92 e8 03 	sts	0x03E8, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    2698:	80 91 e7 03 	lds	r24, 0x03E7
    269c:	88 23       	and	r24, r24
    269e:	31 f0       	breq	.+12     	; 0x26ac <xTaskResumeAll+0xea>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    26a0:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    26a4:	81 e0       	ldi	r24, 0x01	; 1
    26a6:	03 c0       	rjmp	.+6      	; 0x26ae <xTaskResumeAll+0xec>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
    26a8:	80 e0       	ldi	r24, 0x00	; 0
    26aa:	01 c0       	rjmp	.+2      	; 0x26ae <xTaskResumeAll+0xec>
    26ac:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    26ae:	0f 90       	pop	r0
    26b0:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    26b2:	df 91       	pop	r29
    26b4:	cf 91       	pop	r28
    26b6:	1f 91       	pop	r17
    26b8:	0f 91       	pop	r16
    26ba:	ff 90       	pop	r15
    26bc:	ef 90       	pop	r14
    26be:	df 90       	pop	r13
    26c0:	08 95       	ret

000026c2 <prvIdleTask>:
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    26c2:	0c e3       	ldi	r16, 0x3C	; 60
    26c4:	14 e0       	ldi	r17, 0x04	; 4

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    26c6:	0f 2e       	mov	r0, r31
    26c8:	f4 ef       	ldi	r31, 0xF4	; 244
    26ca:	ef 2e       	mov	r14, r31
    26cc:	f3 e0       	ldi	r31, 0x03	; 3
    26ce:	ff 2e       	mov	r15, r31
    26d0:	f0 2d       	mov	r31, r0
    26d2:	24 c0       	rjmp	.+72     	; 0x271c <prvIdleTask+0x5a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    26d4:	0e 94 1c 12 	call	0x2438	; 0x2438 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    26d8:	f8 01       	movw	r30, r16
    26da:	c0 81       	ld	r28, Z
			}
			( void ) xTaskResumeAll();
    26dc:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    26e0:	cc 23       	and	r28, r28
    26e2:	e1 f0       	breq	.+56     	; 0x271c <prvIdleTask+0x5a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    26e4:	0f b6       	in	r0, 0x3f	; 63
    26e6:	f8 94       	cli
    26e8:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    26ea:	e0 91 41 04 	lds	r30, 0x0441
    26ee:	f0 91 42 04 	lds	r31, 0x0442
    26f2:	c6 81       	ldd	r28, Z+6	; 0x06
    26f4:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    26f6:	ce 01       	movw	r24, r28
    26f8:	02 96       	adiw	r24, 0x02	; 2
    26fa:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
					--uxCurrentNumberOfTasks;
    26fe:	80 91 ed 03 	lds	r24, 0x03ED
    2702:	81 50       	subi	r24, 0x01	; 1
    2704:	80 93 ed 03 	sts	0x03ED, r24
					--uxDeletedTasksWaitingCleanUp;
    2708:	80 91 ee 03 	lds	r24, 0x03EE
    270c:	81 50       	subi	r24, 0x01	; 1
    270e:	80 93 ee 03 	sts	0x03EE, r24
				}
				taskEXIT_CRITICAL();
    2712:	0f 90       	pop	r0
    2714:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    2716:	ce 01       	movw	r24, r28
    2718:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    271c:	80 91 ee 03 	lds	r24, 0x03EE
    2720:	88 23       	and	r24, r24
    2722:	c1 f6       	brne	.-80     	; 0x26d4 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    2724:	f7 01       	movw	r30, r14
    2726:	80 81       	ld	r24, Z
    2728:	82 30       	cpi	r24, 0x02	; 2
    272a:	c0 f3       	brcs	.-16     	; 0x271c <prvIdleTask+0x5a>
			{
				taskYIELD();
    272c:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
    2730:	f5 cf       	rjmp	.-22     	; 0x271c <prvIdleTask+0x5a>

00002732 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2732:	cf 93       	push	r28
    2734:	df 93       	push	r29
    2736:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2738:	00 97       	sbiw	r24, 0x00	; 0
    273a:	51 f0       	breq	.+20     	; 0x2750 <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    273c:	0e 94 1c 12 	call	0x2438	; 0x2438 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    2740:	ce 01       	movw	r24, r28
    2742:	60 e0       	ldi	r22, 0x00	; 0
    2744:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2748:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    274c:	88 23       	and	r24, r24
    274e:	11 f4       	brne	.+4      	; 0x2754 <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
    2750:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2754:	df 91       	pop	r29
    2756:	cf 91       	pop	r28
    2758:	08 95       	ret

0000275a <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    275a:	0f 93       	push	r16
    275c:	1f 93       	push	r17
    275e:	cf 93       	push	r28
    2760:	df 93       	push	r29
    2762:	8c 01       	movw	r16, r24
    2764:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    2766:	0e 94 1c 12 	call	0x2438	; 0x2438 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    276a:	80 91 eb 03 	lds	r24, 0x03EB
    276e:	90 91 ec 03 	lds	r25, 0x03EC

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2772:	f8 01       	movw	r30, r16
    2774:	20 81       	ld	r18, Z
    2776:	31 81       	ldd	r19, Z+1	; 0x01
    2778:	c2 0f       	add	r28, r18
    277a:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
    277c:	82 17       	cp	r24, r18
    277e:	93 07       	cpc	r25, r19
    2780:	48 f4       	brcc	.+18     	; 0x2794 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    2782:	c2 17       	cp	r28, r18
    2784:	d3 07       	cpc	r29, r19
    2786:	f8 f4       	brcc	.+62     	; 0x27c6 <vTaskDelayUntil+0x6c>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2788:	d1 83       	std	Z+1, r29	; 0x01
    278a:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    278c:	8c 17       	cp	r24, r28
    278e:	9d 07       	cpc	r25, r29
    2790:	78 f4       	brcc	.+30     	; 0x27b0 <vTaskDelayUntil+0x56>
    2792:	07 c0       	rjmp	.+14     	; 0x27a2 <vTaskDelayUntil+0x48>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    2794:	c2 17       	cp	r28, r18
    2796:	d3 07       	cpc	r29, r19
    2798:	90 f0       	brcs	.+36     	; 0x27be <vTaskDelayUntil+0x64>
    279a:	8c 17       	cp	r24, r28
    279c:	9d 07       	cpc	r25, r29
    279e:	78 f0       	brcs	.+30     	; 0x27be <vTaskDelayUntil+0x64>
    27a0:	12 c0       	rjmp	.+36     	; 0x27c6 <vTaskDelayUntil+0x6c>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    27a2:	9e 01       	movw	r18, r28
    27a4:	28 1b       	sub	r18, r24
    27a6:	39 0b       	sbc	r19, r25
    27a8:	c9 01       	movw	r24, r18
    27aa:	60 e0       	ldi	r22, 0x00	; 0
    27ac:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    27b0:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    27b4:	88 23       	and	r24, r24
    27b6:	59 f4       	brne	.+22     	; 0x27ce <vTaskDelayUntil+0x74>
		{
			portYIELD_WITHIN_API();
    27b8:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
    27bc:	08 c0       	rjmp	.+16     	; 0x27ce <vTaskDelayUntil+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    27be:	f8 01       	movw	r30, r16
    27c0:	d1 83       	std	Z+1, r29	; 0x01
    27c2:	c0 83       	st	Z, r28
    27c4:	ee cf       	rjmp	.-36     	; 0x27a2 <vTaskDelayUntil+0x48>
    27c6:	f8 01       	movw	r30, r16
    27c8:	d1 83       	std	Z+1, r29	; 0x01
    27ca:	c0 83       	st	Z, r28
    27cc:	f1 cf       	rjmp	.-30     	; 0x27b0 <vTaskDelayUntil+0x56>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    27ce:	df 91       	pop	r29
    27d0:	cf 91       	pop	r28
    27d2:	1f 91       	pop	r17
    27d4:	0f 91       	pop	r16
    27d6:	08 95       	ret

000027d8 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    27d8:	80 91 e3 03 	lds	r24, 0x03E3
    27dc:	88 23       	and	r24, r24
    27de:	21 f0       	breq	.+8      	; 0x27e8 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    27e0:	81 e0       	ldi	r24, 0x01	; 1
    27e2:	80 93 e7 03 	sts	0x03E7, r24
    27e6:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    27e8:	10 92 e7 03 	sts	0x03E7, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    27ec:	20 91 ea 03 	lds	r18, 0x03EA
    27f0:	82 2f       	mov	r24, r18
    27f2:	90 e0       	ldi	r25, 0x00	; 0
    27f4:	fc 01       	movw	r30, r24
    27f6:	ee 0f       	add	r30, r30
    27f8:	ff 1f       	adc	r31, r31
    27fa:	ee 0f       	add	r30, r30
    27fc:	ff 1f       	adc	r31, r31
    27fe:	ee 0f       	add	r30, r30
    2800:	ff 1f       	adc	r31, r31
    2802:	e8 0f       	add	r30, r24
    2804:	f9 1f       	adc	r31, r25
    2806:	ec 50       	subi	r30, 0x0C	; 12
    2808:	fc 4f       	sbci	r31, 0xFC	; 252
    280a:	30 81       	ld	r19, Z
    280c:	33 23       	and	r19, r19
    280e:	89 f4       	brne	.+34     	; 0x2832 <vTaskSwitchContext+0x5a>
    2810:	21 50       	subi	r18, 0x01	; 1
    2812:	82 2f       	mov	r24, r18
    2814:	90 e0       	ldi	r25, 0x00	; 0
    2816:	fc 01       	movw	r30, r24
    2818:	ee 0f       	add	r30, r30
    281a:	ff 1f       	adc	r31, r31
    281c:	ee 0f       	add	r30, r30
    281e:	ff 1f       	adc	r31, r31
    2820:	ee 0f       	add	r30, r30
    2822:	ff 1f       	adc	r31, r31
    2824:	e8 0f       	add	r30, r24
    2826:	f9 1f       	adc	r31, r25
    2828:	ec 50       	subi	r30, 0x0C	; 12
    282a:	fc 4f       	sbci	r31, 0xFC	; 252
    282c:	30 81       	ld	r19, Z
    282e:	33 23       	and	r19, r19
    2830:	79 f3       	breq	.-34     	; 0x2810 <vTaskSwitchContext+0x38>
    2832:	dc 01       	movw	r26, r24
    2834:	aa 0f       	add	r26, r26
    2836:	bb 1f       	adc	r27, r27
    2838:	aa 0f       	add	r26, r26
    283a:	bb 1f       	adc	r27, r27
    283c:	aa 0f       	add	r26, r26
    283e:	bb 1f       	adc	r27, r27
    2840:	8a 0f       	add	r24, r26
    2842:	9b 1f       	adc	r25, r27
    2844:	dc 01       	movw	r26, r24
    2846:	ac 50       	subi	r26, 0x0C	; 12
    2848:	bc 4f       	sbci	r27, 0xFC	; 252
    284a:	11 96       	adiw	r26, 0x01	; 1
    284c:	ed 91       	ld	r30, X+
    284e:	fc 91       	ld	r31, X
    2850:	12 97       	sbiw	r26, 0x02	; 2
    2852:	02 80       	ldd	r0, Z+2	; 0x02
    2854:	f3 81       	ldd	r31, Z+3	; 0x03
    2856:	e0 2d       	mov	r30, r0
    2858:	12 96       	adiw	r26, 0x02	; 2
    285a:	fc 93       	st	X, r31
    285c:	ee 93       	st	-X, r30
    285e:	11 97       	sbiw	r26, 0x01	; 1
    2860:	cd 01       	movw	r24, r26
    2862:	03 96       	adiw	r24, 0x03	; 3
    2864:	e8 17       	cp	r30, r24
    2866:	f9 07       	cpc	r31, r25
    2868:	31 f4       	brne	.+12     	; 0x2876 <vTaskSwitchContext+0x9e>
    286a:	82 81       	ldd	r24, Z+2	; 0x02
    286c:	93 81       	ldd	r25, Z+3	; 0x03
    286e:	12 96       	adiw	r26, 0x02	; 2
    2870:	9c 93       	st	X, r25
    2872:	8e 93       	st	-X, r24
    2874:	11 97       	sbiw	r26, 0x01	; 1
    2876:	11 96       	adiw	r26, 0x01	; 1
    2878:	ed 91       	ld	r30, X+
    287a:	fc 91       	ld	r31, X
    287c:	12 97       	sbiw	r26, 0x02	; 2
    287e:	86 81       	ldd	r24, Z+6	; 0x06
    2880:	97 81       	ldd	r25, Z+7	; 0x07
    2882:	90 93 e2 03 	sts	0x03E2, r25
    2886:	80 93 e1 03 	sts	0x03E1, r24
    288a:	20 93 ea 03 	sts	0x03EA, r18
    288e:	08 95       	ret

00002890 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    2890:	0f 93       	push	r16
    2892:	1f 93       	push	r17
    2894:	cf 93       	push	r28
    2896:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    2898:	0f b6       	in	r0, 0x3f	; 63
    289a:	f8 94       	cli
    289c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    289e:	00 97       	sbiw	r24, 0x00	; 0
    28a0:	29 f4       	brne	.+10     	; 0x28ac <vTaskSuspend+0x1c>
    28a2:	00 91 e1 03 	lds	r16, 0x03E1
    28a6:	10 91 e2 03 	lds	r17, 0x03E2
    28aa:	01 c0       	rjmp	.+2      	; 0x28ae <vTaskSuspend+0x1e>
    28ac:	8c 01       	movw	r16, r24

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    28ae:	e8 01       	movw	r28, r16
    28b0:	22 96       	adiw	r28, 0x02	; 2
    28b2:	ce 01       	movw	r24, r28
    28b4:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    28b8:	f8 01       	movw	r30, r16
    28ba:	84 89       	ldd	r24, Z+20	; 0x14
    28bc:	95 89       	ldd	r25, Z+21	; 0x15
    28be:	00 97       	sbiw	r24, 0x00	; 0
    28c0:	21 f0       	breq	.+8      	; 0x28ca <vTaskSuspend+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    28c2:	c8 01       	movw	r24, r16
    28c4:	0c 96       	adiw	r24, 0x0c	; 12
    28c6:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    28ca:	85 e4       	ldi	r24, 0x45	; 69
    28cc:	94 e0       	ldi	r25, 0x04	; 4
    28ce:	be 01       	movw	r22, r28
    28d0:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    28d4:	0f 90       	pop	r0
    28d6:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    28d8:	80 91 e9 03 	lds	r24, 0x03E9
    28dc:	88 23       	and	r24, r24
    28de:	39 f0       	breq	.+14     	; 0x28ee <vTaskSuspend+0x5e>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    28e0:	0f b6       	in	r0, 0x3f	; 63
    28e2:	f8 94       	cli
    28e4:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    28e6:	0e 94 cf 0e 	call	0x1d9e	; 0x1d9e <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    28ea:	0f 90       	pop	r0
    28ec:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    28ee:	80 91 e1 03 	lds	r24, 0x03E1
    28f2:	90 91 e2 03 	lds	r25, 0x03E2
    28f6:	08 17       	cp	r16, r24
    28f8:	19 07       	cpc	r17, r25
    28fa:	a1 f4       	brne	.+40     	; 0x2924 <vTaskSuspend+0x94>
		{
			if( xSchedulerRunning != pdFALSE )
    28fc:	80 91 e9 03 	lds	r24, 0x03E9
    2900:	88 23       	and	r24, r24
    2902:	19 f0       	breq	.+6      	; 0x290a <vTaskSuspend+0x7a>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    2904:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
    2908:	0d c0       	rjmp	.+26     	; 0x2924 <vTaskSuspend+0x94>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    290a:	80 91 ed 03 	lds	r24, 0x03ED
    290e:	90 91 45 04 	lds	r25, 0x0445
    2912:	98 17       	cp	r25, r24
    2914:	29 f4       	brne	.+10     	; 0x2920 <vTaskSuspend+0x90>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    2916:	10 92 e2 03 	sts	0x03E2, r1
    291a:	10 92 e1 03 	sts	0x03E1, r1
    291e:	02 c0       	rjmp	.+4      	; 0x2924 <vTaskSuspend+0x94>
				}
				else
				{
					vTaskSwitchContext();
    2920:	0e 94 ec 13 	call	0x27d8	; 0x27d8 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2924:	df 91       	pop	r29
    2926:	cf 91       	pop	r28
    2928:	1f 91       	pop	r17
    292a:	0f 91       	pop	r16
    292c:	08 95       	ret

0000292e <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    292e:	cf 93       	push	r28
    2930:	df 93       	push	r29
    2932:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2934:	60 91 e1 03 	lds	r22, 0x03E1
    2938:	70 91 e2 03 	lds	r23, 0x03E2
    293c:	64 5f       	subi	r22, 0xF4	; 244
    293e:	7f 4f       	sbci	r23, 0xFF	; 255
    2940:	0e 94 18 05 	call	0xa30	; 0xa30 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2944:	ce 01       	movw	r24, r28
    2946:	61 e0       	ldi	r22, 0x01	; 1
    2948:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <prvAddCurrentTaskToDelayedList>
}
    294c:	df 91       	pop	r29
    294e:	cf 91       	pop	r28
    2950:	08 95       	ret

00002952 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    2952:	cf 93       	push	r28
    2954:	df 93       	push	r29
    2956:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2958:	e0 91 e1 03 	lds	r30, 0x03E1
    295c:	f0 91 e2 03 	lds	r31, 0x03E2
    2960:	70 68       	ori	r23, 0x80	; 128
    2962:	75 87       	std	Z+13, r23	; 0x0d
    2964:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2966:	60 91 e1 03 	lds	r22, 0x03E1
    296a:	70 91 e2 03 	lds	r23, 0x03E2
    296e:	64 5f       	subi	r22, 0xF4	; 244
    2970:	7f 4f       	sbci	r23, 0xFF	; 255
    2972:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2976:	ce 01       	movw	r24, r28
    2978:	61 e0       	ldi	r22, 0x01	; 1
    297a:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <prvAddCurrentTaskToDelayedList>
}
    297e:	df 91       	pop	r29
    2980:	cf 91       	pop	r28
    2982:	08 95       	ret

00002984 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    2984:	0f 93       	push	r16
    2986:	1f 93       	push	r17
    2988:	cf 93       	push	r28
    298a:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    298c:	dc 01       	movw	r26, r24
    298e:	15 96       	adiw	r26, 0x05	; 5
    2990:	ed 91       	ld	r30, X+
    2992:	fc 91       	ld	r31, X
    2994:	16 97       	sbiw	r26, 0x06	; 6
    2996:	06 81       	ldd	r16, Z+6	; 0x06
    2998:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    299a:	e8 01       	movw	r28, r16
    299c:	2c 96       	adiw	r28, 0x0c	; 12
    299e:	ce 01       	movw	r24, r28
    29a0:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    29a4:	80 91 e3 03 	lds	r24, 0x03E3
    29a8:	88 23       	and	r24, r24
    29aa:	e9 f4       	brne	.+58     	; 0x29e6 <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    29ac:	e8 01       	movw	r28, r16
    29ae:	22 96       	adiw	r28, 0x02	; 2
    29b0:	ce 01       	movw	r24, r28
    29b2:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    29b6:	f8 01       	movw	r30, r16
    29b8:	86 89       	ldd	r24, Z+22	; 0x16
    29ba:	90 91 ea 03 	lds	r25, 0x03EA
    29be:	98 17       	cp	r25, r24
    29c0:	10 f4       	brcc	.+4      	; 0x29c6 <xTaskRemoveFromEventList+0x42>
    29c2:	80 93 ea 03 	sts	0x03EA, r24
    29c6:	90 e0       	ldi	r25, 0x00	; 0
    29c8:	9c 01       	movw	r18, r24
    29ca:	22 0f       	add	r18, r18
    29cc:	33 1f       	adc	r19, r19
    29ce:	22 0f       	add	r18, r18
    29d0:	33 1f       	adc	r19, r19
    29d2:	22 0f       	add	r18, r18
    29d4:	33 1f       	adc	r19, r19
    29d6:	82 0f       	add	r24, r18
    29d8:	93 1f       	adc	r25, r19
    29da:	8c 50       	subi	r24, 0x0C	; 12
    29dc:	9c 4f       	sbci	r25, 0xFC	; 252
    29de:	be 01       	movw	r22, r28
    29e0:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>
    29e4:	05 c0       	rjmp	.+10     	; 0x29f0 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    29e6:	83 e3       	ldi	r24, 0x33	; 51
    29e8:	94 e0       	ldi	r25, 0x04	; 4
    29ea:	be 01       	movw	r22, r28
    29ec:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    29f0:	e0 91 e1 03 	lds	r30, 0x03E1
    29f4:	f0 91 e2 03 	lds	r31, 0x03E2
    29f8:	d8 01       	movw	r26, r16
    29fa:	56 96       	adiw	r26, 0x16	; 22
    29fc:	9c 91       	ld	r25, X
    29fe:	56 97       	sbiw	r26, 0x16	; 22
    2a00:	86 89       	ldd	r24, Z+22	; 0x16
    2a02:	89 17       	cp	r24, r25
    2a04:	20 f4       	brcc	.+8      	; 0x2a0e <xTaskRemoveFromEventList+0x8a>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    2a06:	81 e0       	ldi	r24, 0x01	; 1
    2a08:	80 93 e7 03 	sts	0x03E7, r24
    2a0c:	01 c0       	rjmp	.+2      	; 0x2a10 <xTaskRemoveFromEventList+0x8c>
	}
	else
	{
		xReturn = pdFALSE;
    2a0e:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    2a10:	df 91       	pop	r29
    2a12:	cf 91       	pop	r28
    2a14:	1f 91       	pop	r17
    2a16:	0f 91       	pop	r16
    2a18:	08 95       	ret

00002a1a <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    2a1a:	0f 93       	push	r16
    2a1c:	1f 93       	push	r17
    2a1e:	cf 93       	push	r28
    2a20:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2a22:	70 68       	ori	r23, 0x80	; 128
    2a24:	fc 01       	movw	r30, r24
    2a26:	71 83       	std	Z+1, r23	; 0x01
    2a28:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    2a2a:	c6 81       	ldd	r28, Z+6	; 0x06
    2a2c:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    2a2e:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    2a32:	8e 01       	movw	r16, r28
    2a34:	0e 5f       	subi	r16, 0xFE	; 254
    2a36:	1f 4f       	sbci	r17, 0xFF	; 255
    2a38:	c8 01       	movw	r24, r16
    2a3a:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    2a3e:	8e 89       	ldd	r24, Y+22	; 0x16
    2a40:	90 91 ea 03 	lds	r25, 0x03EA
    2a44:	98 17       	cp	r25, r24
    2a46:	10 f4       	brcc	.+4      	; 0x2a4c <xTaskRemoveFromUnorderedEventList+0x32>
    2a48:	80 93 ea 03 	sts	0x03EA, r24
    2a4c:	90 e0       	ldi	r25, 0x00	; 0
    2a4e:	9c 01       	movw	r18, r24
    2a50:	22 0f       	add	r18, r18
    2a52:	33 1f       	adc	r19, r19
    2a54:	22 0f       	add	r18, r18
    2a56:	33 1f       	adc	r19, r19
    2a58:	22 0f       	add	r18, r18
    2a5a:	33 1f       	adc	r19, r19
    2a5c:	82 0f       	add	r24, r18
    2a5e:	93 1f       	adc	r25, r19
    2a60:	8c 50       	subi	r24, 0x0C	; 12
    2a62:	9c 4f       	sbci	r25, 0xFC	; 252
    2a64:	b8 01       	movw	r22, r16
    2a66:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2a6a:	e0 91 e1 03 	lds	r30, 0x03E1
    2a6e:	f0 91 e2 03 	lds	r31, 0x03E2
    2a72:	9e 89       	ldd	r25, Y+22	; 0x16
    2a74:	86 89       	ldd	r24, Z+22	; 0x16
    2a76:	89 17       	cp	r24, r25
    2a78:	20 f4       	brcc	.+8      	; 0x2a82 <xTaskRemoveFromUnorderedEventList+0x68>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    2a7a:	81 e0       	ldi	r24, 0x01	; 1
    2a7c:	80 93 e7 03 	sts	0x03E7, r24
    2a80:	01 c0       	rjmp	.+2      	; 0x2a84 <xTaskRemoveFromUnorderedEventList+0x6a>
	}
	else
	{
		xReturn = pdFALSE;
    2a82:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    2a84:	df 91       	pop	r29
    2a86:	cf 91       	pop	r28
    2a88:	1f 91       	pop	r17
    2a8a:	0f 91       	pop	r16
    2a8c:	08 95       	ret

00002a8e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    2a8e:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2a90:	80 91 e6 03 	lds	r24, 0x03E6
    2a94:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2a96:	80 91 eb 03 	lds	r24, 0x03EB
    2a9a:	90 91 ec 03 	lds	r25, 0x03EC
    2a9e:	92 83       	std	Z+2, r25	; 0x02
    2aa0:	81 83       	std	Z+1, r24	; 0x01
}
    2aa2:	08 95       	ret

00002aa4 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2aa4:	fc 01       	movw	r30, r24
    2aa6:	db 01       	movw	r26, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2aa8:	0f b6       	in	r0, 0x3f	; 63
    2aaa:	f8 94       	cli
    2aac:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2aae:	60 91 eb 03 	lds	r22, 0x03EB
    2ab2:	70 91 ec 03 	lds	r23, 0x03EC
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    2ab6:	4d 91       	ld	r20, X+
    2ab8:	5c 91       	ld	r21, X
    2aba:	11 97       	sbiw	r26, 0x01	; 1
    2abc:	8f ef       	ldi	r24, 0xFF	; 255
    2abe:	4f 3f       	cpi	r20, 0xFF	; 255
    2ac0:	58 07       	cpc	r21, r24
    2ac2:	e9 f0       	breq	.+58     	; 0x2afe <xTaskCheckForTimeOut+0x5a>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2ac4:	80 91 e6 03 	lds	r24, 0x03E6
    2ac8:	90 81       	ld	r25, Z
    2aca:	98 17       	cp	r25, r24
    2acc:	29 f0       	breq	.+10     	; 0x2ad8 <xTaskCheckForTimeOut+0x34>
    2ace:	81 81       	ldd	r24, Z+1	; 0x01
    2ad0:	92 81       	ldd	r25, Z+2	; 0x02
    2ad2:	68 17       	cp	r22, r24
    2ad4:	79 07       	cpc	r23, r25
    2ad6:	a8 f4       	brcc	.+42     	; 0x2b02 <xTaskCheckForTimeOut+0x5e>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    2ad8:	81 81       	ldd	r24, Z+1	; 0x01
    2ada:	92 81       	ldd	r25, Z+2	; 0x02
    2adc:	9b 01       	movw	r18, r22
    2ade:	28 1b       	sub	r18, r24
    2ae0:	39 0b       	sbc	r19, r25
    2ae2:	24 17       	cp	r18, r20
    2ae4:	35 07       	cpc	r19, r21
    2ae6:	78 f4       	brcc	.+30     	; 0x2b06 <xTaskCheckForTimeOut+0x62>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    2ae8:	86 1b       	sub	r24, r22
    2aea:	97 0b       	sbc	r25, r23
    2aec:	84 0f       	add	r24, r20
    2aee:	95 1f       	adc	r25, r21
    2af0:	8d 93       	st	X+, r24
    2af2:	9c 93       	st	X, r25
			vTaskSetTimeOutState( pxTimeOut );
    2af4:	cf 01       	movw	r24, r30
    2af6:	0e 94 47 15 	call	0x2a8e	; 0x2a8e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2afa:	80 e0       	ldi	r24, 0x00	; 0
    2afc:	05 c0       	rjmp	.+10     	; 0x2b08 <xTaskCheckForTimeOut+0x64>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    2afe:	80 e0       	ldi	r24, 0x00	; 0
    2b00:	03 c0       	rjmp	.+6      	; 0x2b08 <xTaskCheckForTimeOut+0x64>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    2b02:	81 e0       	ldi	r24, 0x01	; 1
    2b04:	01 c0       	rjmp	.+2      	; 0x2b08 <xTaskCheckForTimeOut+0x64>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2b06:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2b08:	0f 90       	pop	r0
    2b0a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2b0c:	08 95       	ret

00002b0e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    2b0e:	81 e0       	ldi	r24, 0x01	; 1
    2b10:	80 93 e7 03 	sts	0x03E7, r24
}
    2b14:	08 95       	ret

00002b16 <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2b16:	80 91 e1 03 	lds	r24, 0x03E1
    2b1a:	90 91 e2 03 	lds	r25, 0x03E2

		return xReturn;
	}
    2b1e:	08 95       	ret

00002b20 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    2b20:	0f 93       	push	r16
    2b22:	1f 93       	push	r17
    2b24:	cf 93       	push	r28
    2b26:	df 93       	push	r29
    2b28:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    2b2a:	00 97       	sbiw	r24, 0x00	; 0
    2b2c:	09 f4       	brne	.+2      	; 0x2b30 <vTaskPriorityInherit+0x10>
    2b2e:	51 c0       	rjmp	.+162    	; 0x2bd2 <vTaskPriorityInherit+0xb2>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2b30:	8e 89       	ldd	r24, Y+22	; 0x16
    2b32:	e0 91 e1 03 	lds	r30, 0x03E1
    2b36:	f0 91 e2 03 	lds	r31, 0x03E2
    2b3a:	96 89       	ldd	r25, Z+22	; 0x16
    2b3c:	89 17       	cp	r24, r25
    2b3e:	08 f0       	brcs	.+2      	; 0x2b42 <vTaskPriorityInherit+0x22>
    2b40:	48 c0       	rjmp	.+144    	; 0x2bd2 <vTaskPriorityInherit+0xb2>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    2b42:	2c 85       	ldd	r18, Y+12	; 0x0c
    2b44:	3d 85       	ldd	r19, Y+13	; 0x0d
    2b46:	33 23       	and	r19, r19
    2b48:	5c f0       	brlt	.+22     	; 0x2b60 <vTaskPriorityInherit+0x40>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2b4a:	e0 91 e1 03 	lds	r30, 0x03E1
    2b4e:	f0 91 e2 03 	lds	r31, 0x03E2
    2b52:	96 89       	ldd	r25, Z+22	; 0x16
    2b54:	25 e0       	ldi	r18, 0x05	; 5
    2b56:	30 e0       	ldi	r19, 0x00	; 0
    2b58:	29 1b       	sub	r18, r25
    2b5a:	31 09       	sbc	r19, r1
    2b5c:	3d 87       	std	Y+13, r19	; 0x0d
    2b5e:	2c 87       	std	Y+12, r18	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    2b60:	90 e0       	ldi	r25, 0x00	; 0
    2b62:	9c 01       	movw	r18, r24
    2b64:	22 0f       	add	r18, r18
    2b66:	33 1f       	adc	r19, r19
    2b68:	22 0f       	add	r18, r18
    2b6a:	33 1f       	adc	r19, r19
    2b6c:	22 0f       	add	r18, r18
    2b6e:	33 1f       	adc	r19, r19
    2b70:	82 0f       	add	r24, r18
    2b72:	93 1f       	adc	r25, r19
    2b74:	8c 50       	subi	r24, 0x0C	; 12
    2b76:	9c 4f       	sbci	r25, 0xFC	; 252
    2b78:	2a 85       	ldd	r18, Y+10	; 0x0a
    2b7a:	3b 85       	ldd	r19, Y+11	; 0x0b
    2b7c:	28 17       	cp	r18, r24
    2b7e:	39 07       	cpc	r19, r25
    2b80:	11 f5       	brne	.+68     	; 0x2bc6 <vTaskPriorityInherit+0xa6>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2b82:	8e 01       	movw	r16, r28
    2b84:	0e 5f       	subi	r16, 0xFE	; 254
    2b86:	1f 4f       	sbci	r17, 0xFF	; 255
    2b88:	c8 01       	movw	r24, r16
    2b8a:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2b8e:	e0 91 e1 03 	lds	r30, 0x03E1
    2b92:	f0 91 e2 03 	lds	r31, 0x03E2
    2b96:	86 89       	ldd	r24, Z+22	; 0x16
    2b98:	8e 8b       	std	Y+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    2b9a:	90 91 ea 03 	lds	r25, 0x03EA
    2b9e:	98 17       	cp	r25, r24
    2ba0:	10 f4       	brcc	.+4      	; 0x2ba6 <vTaskPriorityInherit+0x86>
    2ba2:	80 93 ea 03 	sts	0x03EA, r24
    2ba6:	90 e0       	ldi	r25, 0x00	; 0
    2ba8:	9c 01       	movw	r18, r24
    2baa:	22 0f       	add	r18, r18
    2bac:	33 1f       	adc	r19, r19
    2bae:	22 0f       	add	r18, r18
    2bb0:	33 1f       	adc	r19, r19
    2bb2:	22 0f       	add	r18, r18
    2bb4:	33 1f       	adc	r19, r19
    2bb6:	82 0f       	add	r24, r18
    2bb8:	93 1f       	adc	r25, r19
    2bba:	8c 50       	subi	r24, 0x0C	; 12
    2bbc:	9c 4f       	sbci	r25, 0xFC	; 252
    2bbe:	b8 01       	movw	r22, r16
    2bc0:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>
    2bc4:	06 c0       	rjmp	.+12     	; 0x2bd2 <vTaskPriorityInherit+0xb2>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2bc6:	e0 91 e1 03 	lds	r30, 0x03E1
    2bca:	f0 91 e2 03 	lds	r31, 0x03E2
    2bce:	86 89       	ldd	r24, Z+22	; 0x16
    2bd0:	8e 8b       	std	Y+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2bd2:	df 91       	pop	r29
    2bd4:	cf 91       	pop	r28
    2bd6:	1f 91       	pop	r17
    2bd8:	0f 91       	pop	r16
    2bda:	08 95       	ret

00002bdc <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    2bdc:	0f 93       	push	r16
    2bde:	1f 93       	push	r17
    2be0:	cf 93       	push	r28
    2be2:	df 93       	push	r29
    2be4:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    2be6:	00 97       	sbiw	r24, 0x00	; 0
    2be8:	81 f1       	breq	.+96     	; 0x2c4a <xTaskPriorityDisinherit+0x6e>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    2bea:	8c a1       	lds	r24, 0x4c
    2bec:	81 50       	subi	r24, 0x01	; 1
    2bee:	8c a3       	lds	r24, 0x5c

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2bf0:	2e 89       	ldd	r18, Y+22	; 0x16
    2bf2:	9b a1       	lds	r25, 0x4b
    2bf4:	29 17       	cp	r18, r25
    2bf6:	59 f1       	breq	.+86     	; 0x2c4e <xTaskPriorityDisinherit+0x72>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    2bf8:	88 23       	and	r24, r24
    2bfa:	59 f5       	brne	.+86     	; 0x2c52 <xTaskPriorityDisinherit+0x76>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2bfc:	8e 01       	movw	r16, r28
    2bfe:	0e 5f       	subi	r16, 0xFE	; 254
    2c00:	1f 4f       	sbci	r17, 0xFF	; 255
    2c02:	c8 01       	movw	r24, r16
    2c04:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    2c08:	4b a1       	lds	r20, 0x4b
    2c0a:	4e 8b       	std	Y+22, r20	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2c0c:	24 2f       	mov	r18, r20
    2c0e:	30 e0       	ldi	r19, 0x00	; 0
    2c10:	85 e0       	ldi	r24, 0x05	; 5
    2c12:	90 e0       	ldi	r25, 0x00	; 0
    2c14:	82 1b       	sub	r24, r18
    2c16:	93 0b       	sbc	r25, r19
    2c18:	9d 87       	std	Y+13, r25	; 0x0d
    2c1a:	8c 87       	std	Y+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    2c1c:	80 91 ea 03 	lds	r24, 0x03EA
    2c20:	84 17       	cp	r24, r20
    2c22:	10 f4       	brcc	.+4      	; 0x2c28 <xTaskPriorityDisinherit+0x4c>
    2c24:	40 93 ea 03 	sts	0x03EA, r20
    2c28:	c9 01       	movw	r24, r18
    2c2a:	88 0f       	add	r24, r24
    2c2c:	99 1f       	adc	r25, r25
    2c2e:	88 0f       	add	r24, r24
    2c30:	99 1f       	adc	r25, r25
    2c32:	88 0f       	add	r24, r24
    2c34:	99 1f       	adc	r25, r25
    2c36:	28 0f       	add	r18, r24
    2c38:	39 1f       	adc	r19, r25
    2c3a:	c9 01       	movw	r24, r18
    2c3c:	8c 50       	subi	r24, 0x0C	; 12
    2c3e:	9c 4f       	sbci	r25, 0xFC	; 252
    2c40:	b8 01       	movw	r22, r16
    2c42:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    2c46:	81 e0       	ldi	r24, 0x01	; 1
    2c48:	05 c0       	rjmp	.+10     	; 0x2c54 <xTaskPriorityDisinherit+0x78>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    2c4a:	80 e0       	ldi	r24, 0x00	; 0
    2c4c:	03 c0       	rjmp	.+6      	; 0x2c54 <xTaskPriorityDisinherit+0x78>
    2c4e:	80 e0       	ldi	r24, 0x00	; 0
    2c50:	01 c0       	rjmp	.+2      	; 0x2c54 <xTaskPriorityDisinherit+0x78>
    2c52:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    2c54:	df 91       	pop	r29
    2c56:	cf 91       	pop	r28
    2c58:	1f 91       	pop	r17
    2c5a:	0f 91       	pop	r16
    2c5c:	08 95       	ret

00002c5e <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    2c5e:	e0 91 e1 03 	lds	r30, 0x03E1
    2c62:	f0 91 e2 03 	lds	r31, 0x03E2
    2c66:	84 85       	ldd	r24, Z+12	; 0x0c
    2c68:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2c6a:	e0 91 e1 03 	lds	r30, 0x03E1
    2c6e:	f0 91 e2 03 	lds	r31, 0x03E2
    2c72:	a0 91 e1 03 	lds	r26, 0x03E1
    2c76:	b0 91 e2 03 	lds	r27, 0x03E2
    2c7a:	56 96       	adiw	r26, 0x16	; 22
    2c7c:	4c 91       	ld	r20, X
    2c7e:	56 97       	sbiw	r26, 0x16	; 22
    2c80:	25 e0       	ldi	r18, 0x05	; 5
    2c82:	30 e0       	ldi	r19, 0x00	; 0
    2c84:	24 1b       	sub	r18, r20
    2c86:	31 09       	sbc	r19, r1
    2c88:	35 87       	std	Z+13, r19	; 0x0d
    2c8a:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    2c8c:	08 95       	ret

00002c8e <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2c8e:	80 91 e1 03 	lds	r24, 0x03E1
    2c92:	90 91 e2 03 	lds	r25, 0x03E2
    2c96:	00 97       	sbiw	r24, 0x00	; 0
    2c98:	39 f0       	breq	.+14     	; 0x2ca8 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2c9a:	e0 91 e1 03 	lds	r30, 0x03E1
    2c9e:	f0 91 e2 03 	lds	r31, 0x03E2
    2ca2:	84 a1       	lds	r24, 0x44
    2ca4:	8f 5f       	subi	r24, 0xFF	; 255
    2ca6:	84 a3       	lds	r24, 0x54
		}

		return pxCurrentTCB;
    2ca8:	80 91 e1 03 	lds	r24, 0x03E1
    2cac:	90 91 e2 03 	lds	r25, 0x03E2
	}
    2cb0:	08 95       	ret

00002cb2 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    2cb2:	0f 93       	push	r16
    2cb4:	1f 93       	push	r17
    2cb6:	cf 93       	push	r28
    2cb8:	c8 2f       	mov	r28, r24
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    2cba:	0f b6       	in	r0, 0x3f	; 63
    2cbc:	f8 94       	cli
    2cbe:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    2cc0:	e0 91 e1 03 	lds	r30, 0x03E1
    2cc4:	f0 91 e2 03 	lds	r31, 0x03E2
    2cc8:	85 a1       	lds	r24, 0x45
    2cca:	96 a1       	lds	r25, 0x46
    2ccc:	a7 a1       	lds	r26, 0x47
    2cce:	b0 a5       	lds	r27, 0x60
    2cd0:	00 97       	sbiw	r24, 0x00	; 0
    2cd2:	a1 05       	cpc	r26, r1
    2cd4:	b1 05       	cpc	r27, r1
    2cd6:	79 f4       	brne	.+30     	; 0x2cf6 <ulTaskNotifyTake+0x44>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    2cd8:	e0 91 e1 03 	lds	r30, 0x03E1
    2cdc:	f0 91 e2 03 	lds	r31, 0x03E2
    2ce0:	81 e0       	ldi	r24, 0x01	; 1
    2ce2:	81 a7       	lds	r24, 0x71

				if( xTicksToWait > ( TickType_t ) 0 )
    2ce4:	61 15       	cp	r22, r1
    2ce6:	71 05       	cpc	r23, r1
    2ce8:	31 f0       	breq	.+12     	; 0x2cf6 <ulTaskNotifyTake+0x44>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2cea:	cb 01       	movw	r24, r22
    2cec:	61 e0       	ldi	r22, 0x01	; 1
    2cee:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    2cf2:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2cf6:	0f 90       	pop	r0
    2cf8:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    2cfa:	0f b6       	in	r0, 0x3f	; 63
    2cfc:	f8 94       	cli
    2cfe:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    2d00:	e0 91 e1 03 	lds	r30, 0x03E1
    2d04:	f0 91 e2 03 	lds	r31, 0x03E2
    2d08:	05 a1       	lds	r16, 0x45
    2d0a:	16 a1       	lds	r17, 0x46
    2d0c:	27 a1       	lds	r18, 0x47
    2d0e:	30 a5       	lds	r19, 0x60

			if( ulReturn != 0UL )
    2d10:	01 15       	cp	r16, r1
    2d12:	11 05       	cpc	r17, r1
    2d14:	21 05       	cpc	r18, r1
    2d16:	31 05       	cpc	r19, r1
    2d18:	c1 f0       	breq	.+48     	; 0x2d4a <ulTaskNotifyTake+0x98>
			{
				if( xClearCountOnExit != pdFALSE )
    2d1a:	cc 23       	and	r28, r28
    2d1c:	49 f0       	breq	.+18     	; 0x2d30 <ulTaskNotifyTake+0x7e>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    2d1e:	e0 91 e1 03 	lds	r30, 0x03E1
    2d22:	f0 91 e2 03 	lds	r31, 0x03E2
    2d26:	15 a2       	lds	r17, 0x95
    2d28:	16 a2       	lds	r17, 0x96
    2d2a:	17 a2       	lds	r17, 0x97
    2d2c:	10 a6       	lds	r17, 0xb0
    2d2e:	0d c0       	rjmp	.+26     	; 0x2d4a <ulTaskNotifyTake+0x98>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    2d30:	e0 91 e1 03 	lds	r30, 0x03E1
    2d34:	f0 91 e2 03 	lds	r31, 0x03E2
    2d38:	d9 01       	movw	r26, r18
    2d3a:	c8 01       	movw	r24, r16
    2d3c:	01 97       	sbiw	r24, 0x01	; 1
    2d3e:	a1 09       	sbc	r26, r1
    2d40:	b1 09       	sbc	r27, r1
    2d42:	85 a3       	lds	r24, 0x55
    2d44:	96 a3       	lds	r25, 0x56
    2d46:	a7 a3       	lds	r26, 0x57
    2d48:	b0 a7       	lds	r27, 0x70
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2d4a:	e0 91 e1 03 	lds	r30, 0x03E1
    2d4e:	f0 91 e2 03 	lds	r31, 0x03E2
    2d52:	11 a6       	lds	r17, 0xb1
		}
		taskEXIT_CRITICAL();
    2d54:	0f 90       	pop	r0
    2d56:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    2d58:	60 2f       	mov	r22, r16
    2d5a:	71 2f       	mov	r23, r17
    2d5c:	82 2f       	mov	r24, r18
    2d5e:	93 2f       	mov	r25, r19
    2d60:	cf 91       	pop	r28
    2d62:	1f 91       	pop	r17
    2d64:	0f 91       	pop	r16
    2d66:	08 95       	ret

00002d68 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    2d68:	8f 92       	push	r8
    2d6a:	9f 92       	push	r9
    2d6c:	af 92       	push	r10
    2d6e:	bf 92       	push	r11
    2d70:	ef 92       	push	r14
    2d72:	ff 92       	push	r15
    2d74:	0f 93       	push	r16
    2d76:	1f 93       	push	r17
    2d78:	dc 01       	movw	r26, r24
    2d7a:	cb 01       	movw	r24, r22
    2d7c:	49 01       	movw	r8, r18
    2d7e:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    2d80:	0f b6       	in	r0, 0x3f	; 63
    2d82:	f8 94       	cli
    2d84:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    2d86:	e0 91 e1 03 	lds	r30, 0x03E1
    2d8a:	f0 91 e2 03 	lds	r31, 0x03E2
    2d8e:	21 a5       	lds	r18, 0x61
    2d90:	22 30       	cpi	r18, 0x02	; 2
    2d92:	19 f1       	breq	.+70     	; 0x2dda <xTaskNotifyWait+0x72>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    2d94:	e0 91 e1 03 	lds	r30, 0x03E1
    2d98:	f0 91 e2 03 	lds	r31, 0x03E2
    2d9c:	45 a1       	lds	r20, 0x45
    2d9e:	56 a1       	lds	r21, 0x46
    2da0:	67 a1       	lds	r22, 0x47
    2da2:	70 a5       	lds	r23, 0x60
    2da4:	80 95       	com	r24
    2da6:	90 95       	com	r25
    2da8:	a0 95       	com	r26
    2daa:	b0 95       	com	r27
    2dac:	84 23       	and	r24, r20
    2dae:	95 23       	and	r25, r21
    2db0:	a6 23       	and	r26, r22
    2db2:	b7 23       	and	r27, r23
    2db4:	85 a3       	lds	r24, 0x55
    2db6:	96 a3       	lds	r25, 0x56
    2db8:	a7 a3       	lds	r26, 0x57
    2dba:	b0 a7       	lds	r27, 0x70

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    2dbc:	e0 91 e1 03 	lds	r30, 0x03E1
    2dc0:	f0 91 e2 03 	lds	r31, 0x03E2
    2dc4:	81 e0       	ldi	r24, 0x01	; 1
    2dc6:	81 a7       	lds	r24, 0x71

				if( xTicksToWait > ( TickType_t ) 0 )
    2dc8:	e1 14       	cp	r14, r1
    2dca:	f1 04       	cpc	r15, r1
    2dcc:	31 f0       	breq	.+12     	; 0x2dda <xTaskNotifyWait+0x72>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2dce:	c7 01       	movw	r24, r14
    2dd0:	61 e0       	ldi	r22, 0x01	; 1
    2dd2:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    2dd6:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2dda:	0f 90       	pop	r0
    2ddc:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    2dde:	0f b6       	in	r0, 0x3f	; 63
    2de0:	f8 94       	cli
    2de2:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    2de4:	01 15       	cp	r16, r1
    2de6:	11 05       	cpc	r17, r1
    2de8:	69 f0       	breq	.+26     	; 0x2e04 <xTaskNotifyWait+0x9c>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    2dea:	e0 91 e1 03 	lds	r30, 0x03E1
    2dee:	f0 91 e2 03 	lds	r31, 0x03E2
    2df2:	85 a1       	lds	r24, 0x45
    2df4:	96 a1       	lds	r25, 0x46
    2df6:	a7 a1       	lds	r26, 0x47
    2df8:	b0 a5       	lds	r27, 0x60
    2dfa:	f8 01       	movw	r30, r16
    2dfc:	80 83       	st	Z, r24
    2dfe:	91 83       	std	Z+1, r25	; 0x01
    2e00:	a2 83       	std	Z+2, r26	; 0x02
    2e02:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    2e04:	e0 91 e1 03 	lds	r30, 0x03E1
    2e08:	f0 91 e2 03 	lds	r31, 0x03E2
    2e0c:	81 a5       	lds	r24, 0x61
    2e0e:	81 30       	cpi	r24, 0x01	; 1
    2e10:	b1 f0       	breq	.+44     	; 0x2e3e <xTaskNotifyWait+0xd6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    2e12:	e0 91 e1 03 	lds	r30, 0x03E1
    2e16:	f0 91 e2 03 	lds	r31, 0x03E2
    2e1a:	85 a1       	lds	r24, 0x45
    2e1c:	96 a1       	lds	r25, 0x46
    2e1e:	a7 a1       	lds	r26, 0x47
    2e20:	b0 a5       	lds	r27, 0x60
    2e22:	80 94       	com	r8
    2e24:	90 94       	com	r9
    2e26:	a0 94       	com	r10
    2e28:	b0 94       	com	r11
    2e2a:	88 22       	and	r8, r24
    2e2c:	99 22       	and	r9, r25
    2e2e:	aa 22       	and	r10, r26
    2e30:	bb 22       	and	r11, r27
    2e32:	85 a2       	lds	r24, 0x95
    2e34:	96 a2       	lds	r25, 0x96
    2e36:	a7 a2       	lds	r26, 0x97
    2e38:	b0 a6       	lds	r27, 0xb0
				xReturn = pdTRUE;
    2e3a:	81 e0       	ldi	r24, 0x01	; 1
    2e3c:	01 c0       	rjmp	.+2      	; 0x2e40 <xTaskNotifyWait+0xd8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    2e3e:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2e40:	e0 91 e1 03 	lds	r30, 0x03E1
    2e44:	f0 91 e2 03 	lds	r31, 0x03E2
    2e48:	11 a6       	lds	r17, 0xb1
		}
		taskEXIT_CRITICAL();
    2e4a:	0f 90       	pop	r0
    2e4c:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2e4e:	1f 91       	pop	r17
    2e50:	0f 91       	pop	r16
    2e52:	ff 90       	pop	r15
    2e54:	ef 90       	pop	r14
    2e56:	bf 90       	pop	r11
    2e58:	af 90       	pop	r10
    2e5a:	9f 90       	pop	r9
    2e5c:	8f 90       	pop	r8
    2e5e:	08 95       	ret

00002e60 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    2e60:	0f 93       	push	r16
    2e62:	1f 93       	push	r17
    2e64:	cf 93       	push	r28
    2e66:	df 93       	push	r29
    2e68:	ec 01       	movw	r28, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    2e6a:	0f b6       	in	r0, 0x3f	; 63
    2e6c:	f8 94       	cli
    2e6e:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    2e70:	01 15       	cp	r16, r1
    2e72:	11 05       	cpc	r17, r1
    2e74:	49 f0       	breq	.+18     	; 0x2e88 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    2e76:	8d a1       	lds	r24, 0x4d
    2e78:	9e a1       	lds	r25, 0x4e
    2e7a:	af a1       	lds	r26, 0x4f
    2e7c:	b8 a5       	lds	r27, 0x68
    2e7e:	f8 01       	movw	r30, r16
    2e80:	80 83       	st	Z, r24
    2e82:	91 83       	std	Z+1, r25	; 0x01
    2e84:	a2 83       	std	Z+2, r26	; 0x02
    2e86:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2e88:	39 a5       	lds	r19, 0x69

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    2e8a:	82 e0       	ldi	r24, 0x02	; 2
    2e8c:	89 a7       	lds	r24, 0x79

			switch( eAction )
    2e8e:	22 30       	cpi	r18, 0x02	; 2
    2e90:	b9 f0       	breq	.+46     	; 0x2ec0 <xTaskGenericNotify+0x60>
    2e92:	23 30       	cpi	r18, 0x03	; 3
    2e94:	18 f4       	brcc	.+6      	; 0x2e9c <xTaskGenericNotify+0x3c>
    2e96:	21 30       	cpi	r18, 0x01	; 1
    2e98:	51 f5       	brne	.+84     	; 0x2eee <xTaskGenericNotify+0x8e>
    2e9a:	05 c0       	rjmp	.+10     	; 0x2ea6 <xTaskGenericNotify+0x46>
    2e9c:	23 30       	cpi	r18, 0x03	; 3
    2e9e:	e1 f0       	breq	.+56     	; 0x2ed8 <xTaskGenericNotify+0x78>
    2ea0:	24 30       	cpi	r18, 0x04	; 4
    2ea2:	29 f5       	brne	.+74     	; 0x2eee <xTaskGenericNotify+0x8e>
    2ea4:	1e c0       	rjmp	.+60     	; 0x2ee2 <xTaskGenericNotify+0x82>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    2ea6:	8d a1       	lds	r24, 0x4d
    2ea8:	9e a1       	lds	r25, 0x4e
    2eaa:	af a1       	lds	r26, 0x4f
    2eac:	b8 a5       	lds	r27, 0x68
    2eae:	48 2b       	or	r20, r24
    2eb0:	59 2b       	or	r21, r25
    2eb2:	6a 2b       	or	r22, r26
    2eb4:	7b 2b       	or	r23, r27
    2eb6:	4d a3       	lds	r20, 0x5d
    2eb8:	5e a3       	lds	r21, 0x5e
    2eba:	6f a3       	lds	r22, 0x5f
    2ebc:	78 a7       	lds	r23, 0x78
					break;
    2ebe:	17 c0       	rjmp	.+46     	; 0x2eee <xTaskGenericNotify+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    2ec0:	8d a1       	lds	r24, 0x4d
    2ec2:	9e a1       	lds	r25, 0x4e
    2ec4:	af a1       	lds	r26, 0x4f
    2ec6:	b8 a5       	lds	r27, 0x68
    2ec8:	01 96       	adiw	r24, 0x01	; 1
    2eca:	a1 1d       	adc	r26, r1
    2ecc:	b1 1d       	adc	r27, r1
    2ece:	8d a3       	lds	r24, 0x5d
    2ed0:	9e a3       	lds	r25, 0x5e
    2ed2:	af a3       	lds	r26, 0x5f
    2ed4:	b8 a7       	lds	r27, 0x78
					break;
    2ed6:	0b c0       	rjmp	.+22     	; 0x2eee <xTaskGenericNotify+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    2ed8:	4d a3       	lds	r20, 0x5d
    2eda:	5e a3       	lds	r21, 0x5e
    2edc:	6f a3       	lds	r22, 0x5f
    2ede:	78 a7       	lds	r23, 0x78
					break;
    2ee0:	06 c0       	rjmp	.+12     	; 0x2eee <xTaskGenericNotify+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    2ee2:	32 30       	cpi	r19, 0x02	; 2
    2ee4:	71 f1       	breq	.+92     	; 0x2f42 <xTaskGenericNotify+0xe2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    2ee6:	4d a3       	lds	r20, 0x5d
    2ee8:	5e a3       	lds	r21, 0x5e
    2eea:	6f a3       	lds	r22, 0x5f
    2eec:	78 a7       	lds	r23, 0x78

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2eee:	31 30       	cpi	r19, 0x01	; 1
    2ef0:	51 f5       	brne	.+84     	; 0x2f46 <xTaskGenericNotify+0xe6>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2ef2:	8e 01       	movw	r16, r28
    2ef4:	0e 5f       	subi	r16, 0xFE	; 254
    2ef6:	1f 4f       	sbci	r17, 0xFF	; 255
    2ef8:	c8 01       	movw	r24, r16
    2efa:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    2efe:	8e 89       	ldd	r24, Y+22	; 0x16
    2f00:	90 91 ea 03 	lds	r25, 0x03EA
    2f04:	98 17       	cp	r25, r24
    2f06:	10 f4       	brcc	.+4      	; 0x2f0c <xTaskGenericNotify+0xac>
    2f08:	80 93 ea 03 	sts	0x03EA, r24
    2f0c:	90 e0       	ldi	r25, 0x00	; 0
    2f0e:	9c 01       	movw	r18, r24
    2f10:	22 0f       	add	r18, r18
    2f12:	33 1f       	adc	r19, r19
    2f14:	22 0f       	add	r18, r18
    2f16:	33 1f       	adc	r19, r19
    2f18:	22 0f       	add	r18, r18
    2f1a:	33 1f       	adc	r19, r19
    2f1c:	82 0f       	add	r24, r18
    2f1e:	93 1f       	adc	r25, r19
    2f20:	8c 50       	subi	r24, 0x0C	; 12
    2f22:	9c 4f       	sbci	r25, 0xFC	; 252
    2f24:	b8 01       	movw	r22, r16
    2f26:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2f2a:	e0 91 e1 03 	lds	r30, 0x03E1
    2f2e:	f0 91 e2 03 	lds	r31, 0x03E2
    2f32:	9e 89       	ldd	r25, Y+22	; 0x16
    2f34:	86 89       	ldd	r24, Z+22	; 0x16
    2f36:	89 17       	cp	r24, r25
    2f38:	40 f4       	brcc	.+16     	; 0x2f4a <xTaskGenericNotify+0xea>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    2f3a:	0e 94 38 06 	call	0xc70	; 0xc70 <vPortYield>
    2f3e:	81 e0       	ldi	r24, 0x01	; 1
    2f40:	05 c0       	rjmp	.+10     	; 0x2f4c <xTaskGenericNotify+0xec>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    2f42:	80 e0       	ldi	r24, 0x00	; 0
    2f44:	03 c0       	rjmp	.+6      	; 0x2f4c <xTaskGenericNotify+0xec>

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2f46:	81 e0       	ldi	r24, 0x01	; 1
    2f48:	01 c0       	rjmp	.+2      	; 0x2f4c <xTaskGenericNotify+0xec>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2f4a:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2f4c:	0f 90       	pop	r0
    2f4e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2f50:	df 91       	pop	r29
    2f52:	cf 91       	pop	r28
    2f54:	1f 91       	pop	r17
    2f56:	0f 91       	pop	r16
    2f58:	08 95       	ret

00002f5a <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    2f5a:	ef 92       	push	r14
    2f5c:	ff 92       	push	r15
    2f5e:	0f 93       	push	r16
    2f60:	1f 93       	push	r17
    2f62:	cf 93       	push	r28
    2f64:	df 93       	push	r29
    2f66:	ec 01       	movw	r28, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    2f68:	01 15       	cp	r16, r1
    2f6a:	11 05       	cpc	r17, r1
    2f6c:	49 f0       	breq	.+18     	; 0x2f80 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    2f6e:	8d a1       	lds	r24, 0x4d
    2f70:	9e a1       	lds	r25, 0x4e
    2f72:	af a1       	lds	r26, 0x4f
    2f74:	b8 a5       	lds	r27, 0x68
    2f76:	f8 01       	movw	r30, r16
    2f78:	80 83       	st	Z, r24
    2f7a:	91 83       	std	Z+1, r25	; 0x01
    2f7c:	a2 83       	std	Z+2, r26	; 0x02
    2f7e:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2f80:	39 a5       	lds	r19, 0x69
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    2f82:	82 e0       	ldi	r24, 0x02	; 2
    2f84:	89 a7       	lds	r24, 0x79

			switch( eAction )
    2f86:	22 30       	cpi	r18, 0x02	; 2
    2f88:	b9 f0       	breq	.+46     	; 0x2fb8 <xTaskGenericNotifyFromISR+0x5e>
    2f8a:	23 30       	cpi	r18, 0x03	; 3
    2f8c:	18 f4       	brcc	.+6      	; 0x2f94 <xTaskGenericNotifyFromISR+0x3a>
    2f8e:	21 30       	cpi	r18, 0x01	; 1
    2f90:	59 f5       	brne	.+86     	; 0x2fe8 <xTaskGenericNotifyFromISR+0x8e>
    2f92:	05 c0       	rjmp	.+10     	; 0x2f9e <xTaskGenericNotifyFromISR+0x44>
    2f94:	23 30       	cpi	r18, 0x03	; 3
    2f96:	e1 f0       	breq	.+56     	; 0x2fd0 <xTaskGenericNotifyFromISR+0x76>
    2f98:	24 30       	cpi	r18, 0x04	; 4
    2f9a:	31 f5       	brne	.+76     	; 0x2fe8 <xTaskGenericNotifyFromISR+0x8e>
    2f9c:	1e c0       	rjmp	.+60     	; 0x2fda <xTaskGenericNotifyFromISR+0x80>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    2f9e:	8d a1       	lds	r24, 0x4d
    2fa0:	9e a1       	lds	r25, 0x4e
    2fa2:	af a1       	lds	r26, 0x4f
    2fa4:	b8 a5       	lds	r27, 0x68
    2fa6:	84 2b       	or	r24, r20
    2fa8:	95 2b       	or	r25, r21
    2faa:	a6 2b       	or	r26, r22
    2fac:	b7 2b       	or	r27, r23
    2fae:	8d a3       	lds	r24, 0x5d
    2fb0:	9e a3       	lds	r25, 0x5e
    2fb2:	af a3       	lds	r26, 0x5f
    2fb4:	b8 a7       	lds	r27, 0x78
					break;
    2fb6:	18 c0       	rjmp	.+48     	; 0x2fe8 <xTaskGenericNotifyFromISR+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    2fb8:	8d a1       	lds	r24, 0x4d
    2fba:	9e a1       	lds	r25, 0x4e
    2fbc:	af a1       	lds	r26, 0x4f
    2fbe:	b8 a5       	lds	r27, 0x68
    2fc0:	01 96       	adiw	r24, 0x01	; 1
    2fc2:	a1 1d       	adc	r26, r1
    2fc4:	b1 1d       	adc	r27, r1
    2fc6:	8d a3       	lds	r24, 0x5d
    2fc8:	9e a3       	lds	r25, 0x5e
    2fca:	af a3       	lds	r26, 0x5f
    2fcc:	b8 a7       	lds	r27, 0x78
					break;
    2fce:	0c c0       	rjmp	.+24     	; 0x2fe8 <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    2fd0:	4d a3       	lds	r20, 0x5d
    2fd2:	5e a3       	lds	r21, 0x5e
    2fd4:	6f a3       	lds	r22, 0x5f
    2fd6:	78 a7       	lds	r23, 0x78
					break;
    2fd8:	07 c0       	rjmp	.+14     	; 0x2fe8 <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    2fda:	32 30       	cpi	r19, 0x02	; 2
    2fdc:	09 f4       	brne	.+2      	; 0x2fe0 <xTaskGenericNotifyFromISR+0x86>
    2fde:	41 c0       	rjmp	.+130    	; 0x3062 <xTaskGenericNotifyFromISR+0x108>
					{
						pxTCB->ulNotifiedValue = ulValue;
    2fe0:	4d a3       	lds	r20, 0x5d
    2fe2:	5e a3       	lds	r21, 0x5e
    2fe4:	6f a3       	lds	r22, 0x5f
    2fe6:	78 a7       	lds	r23, 0x78

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2fe8:	31 30       	cpi	r19, 0x01	; 1
    2fea:	e9 f5       	brne	.+122    	; 0x3066 <xTaskGenericNotifyFromISR+0x10c>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2fec:	80 91 e3 03 	lds	r24, 0x03E3
    2ff0:	88 23       	and	r24, r24
    2ff2:	e9 f4       	brne	.+58     	; 0x302e <xTaskGenericNotifyFromISR+0xd4>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2ff4:	8e 01       	movw	r16, r28
    2ff6:	0e 5f       	subi	r16, 0xFE	; 254
    2ff8:	1f 4f       	sbci	r17, 0xFF	; 255
    2ffa:	c8 01       	movw	r24, r16
    2ffc:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3000:	8e 89       	ldd	r24, Y+22	; 0x16
    3002:	90 91 ea 03 	lds	r25, 0x03EA
    3006:	98 17       	cp	r25, r24
    3008:	10 f4       	brcc	.+4      	; 0x300e <xTaskGenericNotifyFromISR+0xb4>
    300a:	80 93 ea 03 	sts	0x03EA, r24
    300e:	90 e0       	ldi	r25, 0x00	; 0
    3010:	9c 01       	movw	r18, r24
    3012:	22 0f       	add	r18, r18
    3014:	33 1f       	adc	r19, r19
    3016:	22 0f       	add	r18, r18
    3018:	33 1f       	adc	r19, r19
    301a:	22 0f       	add	r18, r18
    301c:	33 1f       	adc	r19, r19
    301e:	82 0f       	add	r24, r18
    3020:	93 1f       	adc	r25, r19
    3022:	8c 50       	subi	r24, 0x0C	; 12
    3024:	9c 4f       	sbci	r25, 0xFC	; 252
    3026:	b8 01       	movw	r22, r16
    3028:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>
    302c:	07 c0       	rjmp	.+14     	; 0x303c <xTaskGenericNotifyFromISR+0xe2>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    302e:	be 01       	movw	r22, r28
    3030:	64 5f       	subi	r22, 0xF4	; 244
    3032:	7f 4f       	sbci	r23, 0xFF	; 255
    3034:	83 e3       	ldi	r24, 0x33	; 51
    3036:	94 e0       	ldi	r25, 0x04	; 4
    3038:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    303c:	e0 91 e1 03 	lds	r30, 0x03E1
    3040:	f0 91 e2 03 	lds	r31, 0x03E2
    3044:	9e 89       	ldd	r25, Y+22	; 0x16
    3046:	86 89       	ldd	r24, Z+22	; 0x16
    3048:	89 17       	cp	r24, r25
    304a:	78 f4       	brcc	.+30     	; 0x306a <xTaskGenericNotifyFromISR+0x110>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    304c:	e1 14       	cp	r14, r1
    304e:	f1 04       	cpc	r15, r1
    3050:	21 f0       	breq	.+8      	; 0x305a <xTaskGenericNotifyFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    3052:	81 e0       	ldi	r24, 0x01	; 1
    3054:	f7 01       	movw	r30, r14
    3056:	80 83       	st	Z, r24
    3058:	09 c0       	rjmp	.+18     	; 0x306c <xTaskGenericNotifyFromISR+0x112>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    305a:	81 e0       	ldi	r24, 0x01	; 1
    305c:	80 93 e7 03 	sts	0x03E7, r24
    3060:	05 c0       	rjmp	.+10     	; 0x306c <xTaskGenericNotifyFromISR+0x112>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3062:	80 e0       	ldi	r24, 0x00	; 0
    3064:	03 c0       	rjmp	.+6      	; 0x306c <xTaskGenericNotifyFromISR+0x112>

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3066:	81 e0       	ldi	r24, 0x01	; 1
    3068:	01 c0       	rjmp	.+2      	; 0x306c <xTaskGenericNotifyFromISR+0x112>
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    306a:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    306c:	df 91       	pop	r29
    306e:	cf 91       	pop	r28
    3070:	1f 91       	pop	r17
    3072:	0f 91       	pop	r16
    3074:	ff 90       	pop	r15
    3076:	ef 90       	pop	r14
    3078:	08 95       	ret

0000307a <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    307a:	ef 92       	push	r14
    307c:	ff 92       	push	r15
    307e:	0f 93       	push	r16
    3080:	1f 93       	push	r17
    3082:	cf 93       	push	r28
    3084:	df 93       	push	r29
    3086:	ec 01       	movw	r28, r24
    3088:	8b 01       	movw	r16, r22

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    308a:	29 a5       	lds	r18, 0x69
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    308c:	82 e0       	ldi	r24, 0x02	; 2
    308e:	89 a7       	lds	r24, 0x79

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    3090:	8d a1       	lds	r24, 0x4d
    3092:	9e a1       	lds	r25, 0x4e
    3094:	af a1       	lds	r26, 0x4f
    3096:	b8 a5       	lds	r27, 0x68
    3098:	01 96       	adiw	r24, 0x01	; 1
    309a:	a1 1d       	adc	r26, r1
    309c:	b1 1d       	adc	r27, r1
    309e:	8d a3       	lds	r24, 0x5d
    30a0:	9e a3       	lds	r25, 0x5e
    30a2:	af a3       	lds	r26, 0x5f
    30a4:	b8 a7       	lds	r27, 0x78

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    30a6:	21 30       	cpi	r18, 0x01	; 1
    30a8:	e9 f5       	brne	.+122    	; 0x3124 <vTaskNotifyGiveFromISR+0xaa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    30aa:	80 91 e3 03 	lds	r24, 0x03E3
    30ae:	88 23       	and	r24, r24
    30b0:	01 f5       	brne	.+64     	; 0x30f2 <vTaskNotifyGiveFromISR+0x78>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    30b2:	ee 24       	eor	r14, r14
    30b4:	ff 24       	eor	r15, r15
    30b6:	68 94       	set
    30b8:	e1 f8       	bld	r14, 1
    30ba:	ec 0e       	add	r14, r28
    30bc:	fd 1e       	adc	r15, r29
    30be:	c7 01       	movw	r24, r14
    30c0:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    30c4:	8e 89       	ldd	r24, Y+22	; 0x16
    30c6:	90 91 ea 03 	lds	r25, 0x03EA
    30ca:	98 17       	cp	r25, r24
    30cc:	10 f4       	brcc	.+4      	; 0x30d2 <vTaskNotifyGiveFromISR+0x58>
    30ce:	80 93 ea 03 	sts	0x03EA, r24
    30d2:	90 e0       	ldi	r25, 0x00	; 0
    30d4:	9c 01       	movw	r18, r24
    30d6:	22 0f       	add	r18, r18
    30d8:	33 1f       	adc	r19, r19
    30da:	22 0f       	add	r18, r18
    30dc:	33 1f       	adc	r19, r19
    30de:	22 0f       	add	r18, r18
    30e0:	33 1f       	adc	r19, r19
    30e2:	82 0f       	add	r24, r18
    30e4:	93 1f       	adc	r25, r19
    30e6:	8c 50       	subi	r24, 0x0C	; 12
    30e8:	9c 4f       	sbci	r25, 0xFC	; 252
    30ea:	b7 01       	movw	r22, r14
    30ec:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>
    30f0:	07 c0       	rjmp	.+14     	; 0x3100 <vTaskNotifyGiveFromISR+0x86>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    30f2:	be 01       	movw	r22, r28
    30f4:	64 5f       	subi	r22, 0xF4	; 244
    30f6:	7f 4f       	sbci	r23, 0xFF	; 255
    30f8:	83 e3       	ldi	r24, 0x33	; 51
    30fa:	94 e0       	ldi	r25, 0x04	; 4
    30fc:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3100:	e0 91 e1 03 	lds	r30, 0x03E1
    3104:	f0 91 e2 03 	lds	r31, 0x03E2
    3108:	9e 89       	ldd	r25, Y+22	; 0x16
    310a:	86 89       	ldd	r24, Z+22	; 0x16
    310c:	89 17       	cp	r24, r25
    310e:	50 f4       	brcc	.+20     	; 0x3124 <vTaskNotifyGiveFromISR+0xaa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    3110:	01 15       	cp	r16, r1
    3112:	11 05       	cpc	r17, r1
    3114:	21 f0       	breq	.+8      	; 0x311e <vTaskNotifyGiveFromISR+0xa4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    3116:	81 e0       	ldi	r24, 0x01	; 1
    3118:	f8 01       	movw	r30, r16
    311a:	80 83       	st	Z, r24
    311c:	03 c0       	rjmp	.+6      	; 0x3124 <vTaskNotifyGiveFromISR+0xaa>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    311e:	81 e0       	ldi	r24, 0x01	; 1
    3120:	80 93 e7 03 	sts	0x03E7, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    3124:	df 91       	pop	r29
    3126:	cf 91       	pop	r28
    3128:	1f 91       	pop	r17
    312a:	0f 91       	pop	r16
    312c:	ff 90       	pop	r15
    312e:	ef 90       	pop	r14
    3130:	08 95       	ret

00003132 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    3132:	00 97       	sbiw	r24, 0x00	; 0
    3134:	29 f4       	brne	.+10     	; 0x3140 <xTaskNotifyStateClear+0xe>
    3136:	e0 91 e1 03 	lds	r30, 0x03E1
    313a:	f0 91 e2 03 	lds	r31, 0x03E2
    313e:	01 c0       	rjmp	.+2      	; 0x3142 <xTaskNotifyStateClear+0x10>
    3140:	fc 01       	movw	r30, r24

		taskENTER_CRITICAL();
    3142:	0f b6       	in	r0, 0x3f	; 63
    3144:	f8 94       	cli
    3146:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    3148:	81 a5       	lds	r24, 0x61
    314a:	82 30       	cpi	r24, 0x02	; 2
    314c:	19 f4       	brne	.+6      	; 0x3154 <xTaskNotifyStateClear+0x22>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    314e:	11 a6       	lds	r17, 0xb1
				xReturn = pdPASS;
    3150:	81 e0       	ldi	r24, 0x01	; 1
    3152:	01 c0       	rjmp	.+2      	; 0x3156 <xTaskNotifyStateClear+0x24>
			}
			else
			{
				xReturn = pdFAIL;
    3154:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    3156:	0f 90       	pop	r0
    3158:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    315a:	08 95       	ret

0000315c <timer_init>:
#include <avr/io.h>

void timer_init()
{
	//set timer mode This is CTC mode
	TCCR0 &= (~(1<<WGM00));
    315c:	83 b7       	in	r24, 0x33	; 51
    315e:	8f 7b       	andi	r24, 0xBF	; 191
    3160:	83 bf       	out	0x33, r24	; 51
	TCCR0 |= 1<<WGM01;
    3162:	83 b7       	in	r24, 0x33	; 51
    3164:	88 60       	ori	r24, 0x08	; 8
    3166:	83 bf       	out	0x33, r24	; 51
	//choose prescaler this is fcpu/1024
	TCCR0 |= (1<<CS00);
    3168:	83 b7       	in	r24, 0x33	; 51
    316a:	81 60       	ori	r24, 0x01	; 1
    316c:	83 bf       	out	0x33, r24	; 51
	TCCR0 &= (~(1<<CS01));
    316e:	83 b7       	in	r24, 0x33	; 51
    3170:	8d 7f       	andi	r24, 0xFD	; 253
    3172:	83 bf       	out	0x33, r24	; 51
	TCCR0 |= (1<<CS02);
    3174:	83 b7       	in	r24, 0x33	; 51
    3176:	84 60       	ori	r24, 0x04	; 4
    3178:	83 bf       	out	0x33, r24	; 51
	// we want timer to tick every 10ms;; 10ms = ((1024"the prescaler")/(8000000"FCPU"))*OCR0
	OCR0 = 78;
    317a:	8e e4       	ldi	r24, 0x4E	; 78
    317c:	8c bf       	out	0x3c, r24	; 60
	//enable sie for global interupts
	//ENABLE TIMER INTERRUPTS
	TIMSK |= (1<<OCIE0);
    317e:	89 b7       	in	r24, 0x39	; 57
    3180:	82 60       	ori	r24, 0x02	; 2
    3182:	89 bf       	out	0x39, r24	; 57
	
    3184:	08 95       	ret

00003186 <__subsf3>:
    3186:	50 58       	subi	r21, 0x80	; 128

00003188 <__addsf3>:
    3188:	bb 27       	eor	r27, r27
    318a:	aa 27       	eor	r26, r26
    318c:	0e d0       	rcall	.+28     	; 0x31aa <__addsf3x>
    318e:	9f c0       	rjmp	.+318    	; 0x32ce <__fp_round>
    3190:	90 d0       	rcall	.+288    	; 0x32b2 <__fp_pscA>
    3192:	30 f0       	brcs	.+12     	; 0x31a0 <__addsf3+0x18>
    3194:	95 d0       	rcall	.+298    	; 0x32c0 <__fp_pscB>
    3196:	20 f0       	brcs	.+8      	; 0x31a0 <__addsf3+0x18>
    3198:	31 f4       	brne	.+12     	; 0x31a6 <__addsf3+0x1e>
    319a:	9f 3f       	cpi	r25, 0xFF	; 255
    319c:	11 f4       	brne	.+4      	; 0x31a2 <__addsf3+0x1a>
    319e:	1e f4       	brtc	.+6      	; 0x31a6 <__addsf3+0x1e>
    31a0:	85 c0       	rjmp	.+266    	; 0x32ac <__fp_nan>
    31a2:	0e f4       	brtc	.+2      	; 0x31a6 <__addsf3+0x1e>
    31a4:	e0 95       	com	r30
    31a6:	e7 fb       	bst	r30, 7
    31a8:	7b c0       	rjmp	.+246    	; 0x32a0 <__fp_inf>

000031aa <__addsf3x>:
    31aa:	e9 2f       	mov	r30, r25
    31ac:	a1 d0       	rcall	.+322    	; 0x32f0 <__fp_split3>
    31ae:	80 f3       	brcs	.-32     	; 0x3190 <__addsf3+0x8>
    31b0:	ba 17       	cp	r27, r26
    31b2:	62 07       	cpc	r22, r18
    31b4:	73 07       	cpc	r23, r19
    31b6:	84 07       	cpc	r24, r20
    31b8:	95 07       	cpc	r25, r21
    31ba:	18 f0       	brcs	.+6      	; 0x31c2 <__addsf3x+0x18>
    31bc:	71 f4       	brne	.+28     	; 0x31da <__addsf3x+0x30>
    31be:	9e f5       	brtc	.+102    	; 0x3226 <__addsf3x+0x7c>
    31c0:	b9 c0       	rjmp	.+370    	; 0x3334 <__fp_zero>
    31c2:	0e f4       	brtc	.+2      	; 0x31c6 <__addsf3x+0x1c>
    31c4:	e0 95       	com	r30
    31c6:	0b 2e       	mov	r0, r27
    31c8:	ba 2f       	mov	r27, r26
    31ca:	a0 2d       	mov	r26, r0
    31cc:	0b 01       	movw	r0, r22
    31ce:	b9 01       	movw	r22, r18
    31d0:	90 01       	movw	r18, r0
    31d2:	0c 01       	movw	r0, r24
    31d4:	ca 01       	movw	r24, r20
    31d6:	a0 01       	movw	r20, r0
    31d8:	11 24       	eor	r1, r1
    31da:	ff 27       	eor	r31, r31
    31dc:	59 1b       	sub	r21, r25
    31de:	99 f0       	breq	.+38     	; 0x3206 <__addsf3x+0x5c>
    31e0:	59 3f       	cpi	r21, 0xF9	; 249
    31e2:	50 f4       	brcc	.+20     	; 0x31f8 <__addsf3x+0x4e>
    31e4:	50 3e       	cpi	r21, 0xE0	; 224
    31e6:	68 f1       	brcs	.+90     	; 0x3242 <__addsf3x+0x98>
    31e8:	1a 16       	cp	r1, r26
    31ea:	f0 40       	sbci	r31, 0x00	; 0
    31ec:	a2 2f       	mov	r26, r18
    31ee:	23 2f       	mov	r18, r19
    31f0:	34 2f       	mov	r19, r20
    31f2:	44 27       	eor	r20, r20
    31f4:	58 5f       	subi	r21, 0xF8	; 248
    31f6:	f3 cf       	rjmp	.-26     	; 0x31de <__addsf3x+0x34>
    31f8:	46 95       	lsr	r20
    31fa:	37 95       	ror	r19
    31fc:	27 95       	ror	r18
    31fe:	a7 95       	ror	r26
    3200:	f0 40       	sbci	r31, 0x00	; 0
    3202:	53 95       	inc	r21
    3204:	c9 f7       	brne	.-14     	; 0x31f8 <__addsf3x+0x4e>
    3206:	7e f4       	brtc	.+30     	; 0x3226 <__addsf3x+0x7c>
    3208:	1f 16       	cp	r1, r31
    320a:	ba 0b       	sbc	r27, r26
    320c:	62 0b       	sbc	r22, r18
    320e:	73 0b       	sbc	r23, r19
    3210:	84 0b       	sbc	r24, r20
    3212:	ba f0       	brmi	.+46     	; 0x3242 <__addsf3x+0x98>
    3214:	91 50       	subi	r25, 0x01	; 1
    3216:	a1 f0       	breq	.+40     	; 0x3240 <__addsf3x+0x96>
    3218:	ff 0f       	add	r31, r31
    321a:	bb 1f       	adc	r27, r27
    321c:	66 1f       	adc	r22, r22
    321e:	77 1f       	adc	r23, r23
    3220:	88 1f       	adc	r24, r24
    3222:	c2 f7       	brpl	.-16     	; 0x3214 <__addsf3x+0x6a>
    3224:	0e c0       	rjmp	.+28     	; 0x3242 <__addsf3x+0x98>
    3226:	ba 0f       	add	r27, r26
    3228:	62 1f       	adc	r22, r18
    322a:	73 1f       	adc	r23, r19
    322c:	84 1f       	adc	r24, r20
    322e:	48 f4       	brcc	.+18     	; 0x3242 <__addsf3x+0x98>
    3230:	87 95       	ror	r24
    3232:	77 95       	ror	r23
    3234:	67 95       	ror	r22
    3236:	b7 95       	ror	r27
    3238:	f7 95       	ror	r31
    323a:	9e 3f       	cpi	r25, 0xFE	; 254
    323c:	08 f0       	brcs	.+2      	; 0x3240 <__addsf3x+0x96>
    323e:	b3 cf       	rjmp	.-154    	; 0x31a6 <__addsf3+0x1e>
    3240:	93 95       	inc	r25
    3242:	88 0f       	add	r24, r24
    3244:	08 f0       	brcs	.+2      	; 0x3248 <__addsf3x+0x9e>
    3246:	99 27       	eor	r25, r25
    3248:	ee 0f       	add	r30, r30
    324a:	97 95       	ror	r25
    324c:	87 95       	ror	r24
    324e:	08 95       	ret

00003250 <__cmpsf2>:
    3250:	03 d0       	rcall	.+6      	; 0x3258 <__fp_cmp>
    3252:	08 f4       	brcc	.+2      	; 0x3256 <__cmpsf2+0x6>
    3254:	81 e0       	ldi	r24, 0x01	; 1
    3256:	08 95       	ret

00003258 <__fp_cmp>:
    3258:	99 0f       	add	r25, r25
    325a:	00 08       	sbc	r0, r0
    325c:	55 0f       	add	r21, r21
    325e:	aa 0b       	sbc	r26, r26
    3260:	e0 e8       	ldi	r30, 0x80	; 128
    3262:	fe ef       	ldi	r31, 0xFE	; 254
    3264:	16 16       	cp	r1, r22
    3266:	17 06       	cpc	r1, r23
    3268:	e8 07       	cpc	r30, r24
    326a:	f9 07       	cpc	r31, r25
    326c:	c0 f0       	brcs	.+48     	; 0x329e <__fp_cmp+0x46>
    326e:	12 16       	cp	r1, r18
    3270:	13 06       	cpc	r1, r19
    3272:	e4 07       	cpc	r30, r20
    3274:	f5 07       	cpc	r31, r21
    3276:	98 f0       	brcs	.+38     	; 0x329e <__fp_cmp+0x46>
    3278:	62 1b       	sub	r22, r18
    327a:	73 0b       	sbc	r23, r19
    327c:	84 0b       	sbc	r24, r20
    327e:	95 0b       	sbc	r25, r21
    3280:	39 f4       	brne	.+14     	; 0x3290 <__fp_cmp+0x38>
    3282:	0a 26       	eor	r0, r26
    3284:	61 f0       	breq	.+24     	; 0x329e <__fp_cmp+0x46>
    3286:	23 2b       	or	r18, r19
    3288:	24 2b       	or	r18, r20
    328a:	25 2b       	or	r18, r21
    328c:	21 f4       	brne	.+8      	; 0x3296 <__fp_cmp+0x3e>
    328e:	08 95       	ret
    3290:	0a 26       	eor	r0, r26
    3292:	09 f4       	brne	.+2      	; 0x3296 <__fp_cmp+0x3e>
    3294:	a1 40       	sbci	r26, 0x01	; 1
    3296:	a6 95       	lsr	r26
    3298:	8f ef       	ldi	r24, 0xFF	; 255
    329a:	81 1d       	adc	r24, r1
    329c:	81 1d       	adc	r24, r1
    329e:	08 95       	ret

000032a0 <__fp_inf>:
    32a0:	97 f9       	bld	r25, 7
    32a2:	9f 67       	ori	r25, 0x7F	; 127
    32a4:	80 e8       	ldi	r24, 0x80	; 128
    32a6:	70 e0       	ldi	r23, 0x00	; 0
    32a8:	60 e0       	ldi	r22, 0x00	; 0
    32aa:	08 95       	ret

000032ac <__fp_nan>:
    32ac:	9f ef       	ldi	r25, 0xFF	; 255
    32ae:	80 ec       	ldi	r24, 0xC0	; 192
    32b0:	08 95       	ret

000032b2 <__fp_pscA>:
    32b2:	00 24       	eor	r0, r0
    32b4:	0a 94       	dec	r0
    32b6:	16 16       	cp	r1, r22
    32b8:	17 06       	cpc	r1, r23
    32ba:	18 06       	cpc	r1, r24
    32bc:	09 06       	cpc	r0, r25
    32be:	08 95       	ret

000032c0 <__fp_pscB>:
    32c0:	00 24       	eor	r0, r0
    32c2:	0a 94       	dec	r0
    32c4:	12 16       	cp	r1, r18
    32c6:	13 06       	cpc	r1, r19
    32c8:	14 06       	cpc	r1, r20
    32ca:	05 06       	cpc	r0, r21
    32cc:	08 95       	ret

000032ce <__fp_round>:
    32ce:	09 2e       	mov	r0, r25
    32d0:	03 94       	inc	r0
    32d2:	00 0c       	add	r0, r0
    32d4:	11 f4       	brne	.+4      	; 0x32da <__fp_round+0xc>
    32d6:	88 23       	and	r24, r24
    32d8:	52 f0       	brmi	.+20     	; 0x32ee <__fp_round+0x20>
    32da:	bb 0f       	add	r27, r27
    32dc:	40 f4       	brcc	.+16     	; 0x32ee <__fp_round+0x20>
    32de:	bf 2b       	or	r27, r31
    32e0:	11 f4       	brne	.+4      	; 0x32e6 <__fp_round+0x18>
    32e2:	60 ff       	sbrs	r22, 0
    32e4:	04 c0       	rjmp	.+8      	; 0x32ee <__fp_round+0x20>
    32e6:	6f 5f       	subi	r22, 0xFF	; 255
    32e8:	7f 4f       	sbci	r23, 0xFF	; 255
    32ea:	8f 4f       	sbci	r24, 0xFF	; 255
    32ec:	9f 4f       	sbci	r25, 0xFF	; 255
    32ee:	08 95       	ret

000032f0 <__fp_split3>:
    32f0:	57 fd       	sbrc	r21, 7
    32f2:	90 58       	subi	r25, 0x80	; 128
    32f4:	44 0f       	add	r20, r20
    32f6:	55 1f       	adc	r21, r21
    32f8:	59 f0       	breq	.+22     	; 0x3310 <__fp_splitA+0x10>
    32fa:	5f 3f       	cpi	r21, 0xFF	; 255
    32fc:	71 f0       	breq	.+28     	; 0x331a <__fp_splitA+0x1a>
    32fe:	47 95       	ror	r20

00003300 <__fp_splitA>:
    3300:	88 0f       	add	r24, r24
    3302:	97 fb       	bst	r25, 7
    3304:	99 1f       	adc	r25, r25
    3306:	61 f0       	breq	.+24     	; 0x3320 <__fp_splitA+0x20>
    3308:	9f 3f       	cpi	r25, 0xFF	; 255
    330a:	79 f0       	breq	.+30     	; 0x332a <__fp_splitA+0x2a>
    330c:	87 95       	ror	r24
    330e:	08 95       	ret
    3310:	12 16       	cp	r1, r18
    3312:	13 06       	cpc	r1, r19
    3314:	14 06       	cpc	r1, r20
    3316:	55 1f       	adc	r21, r21
    3318:	f2 cf       	rjmp	.-28     	; 0x32fe <__fp_split3+0xe>
    331a:	46 95       	lsr	r20
    331c:	f1 df       	rcall	.-30     	; 0x3300 <__fp_splitA>
    331e:	08 c0       	rjmp	.+16     	; 0x3330 <__fp_splitA+0x30>
    3320:	16 16       	cp	r1, r22
    3322:	17 06       	cpc	r1, r23
    3324:	18 06       	cpc	r1, r24
    3326:	99 1f       	adc	r25, r25
    3328:	f1 cf       	rjmp	.-30     	; 0x330c <__fp_splitA+0xc>
    332a:	86 95       	lsr	r24
    332c:	71 05       	cpc	r23, r1
    332e:	61 05       	cpc	r22, r1
    3330:	08 94       	sec
    3332:	08 95       	ret

00003334 <__fp_zero>:
    3334:	e8 94       	clt

00003336 <__fp_szero>:
    3336:	bb 27       	eor	r27, r27
    3338:	66 27       	eor	r22, r22
    333a:	77 27       	eor	r23, r23
    333c:	cb 01       	movw	r24, r22
    333e:	97 f9       	bld	r25, 7
    3340:	08 95       	ret

00003342 <memcpy>:
    3342:	fb 01       	movw	r30, r22
    3344:	dc 01       	movw	r26, r24
    3346:	02 c0       	rjmp	.+4      	; 0x334c <memcpy+0xa>
    3348:	01 90       	ld	r0, Z+
    334a:	0d 92       	st	X+, r0
    334c:	41 50       	subi	r20, 0x01	; 1
    334e:	50 40       	sbci	r21, 0x00	; 0
    3350:	d8 f7       	brcc	.-10     	; 0x3348 <memcpy+0x6>
    3352:	08 95       	ret

00003354 <_exit>:
    3354:	f8 94       	cli

00003356 <__stop_program>:
    3356:	ff cf       	rjmp	.-2      	; 0x3356 <__stop_program>


Rtos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002b74  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000020  00800060  00002b74  00002c08  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000003bc  00800080  00800080  00002c28  2**0
                  ALLOC
  3 .stab         00000750  00000000  00000000  00002c28  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000000e7  00000000  00000000  00003378  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000200  00000000  00000000  00003460  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003a9c  00000000  00000000  00003660  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000f78  00000000  00000000  000070fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001935  00000000  00000000  00008074  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000d58  00000000  00000000  000099ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000016a6  00000000  00000000  0000a704  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004075  00000000  00000000  0000bdaa  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000150  00000000  00000000  0000fe1f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 00 07 	jmp	0xe00	; 0xe00 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 e7       	ldi	r30, 0x74	; 116
      68:	fb e2       	ldi	r31, 0x2B	; 43
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a0 38       	cpi	r26, 0x80	; 128
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	a0 e8       	ldi	r26, 0x80	; 128
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ac 33       	cpi	r26, 0x3C	; 60
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <main>
      8a:	0c 94 b8 15 	jmp	0x2b70	; 0x2b70 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <adc_init>:
#include <avr/interrupt.h>

void adc_init()
{
	// AREF = AVcc
	ADMUX = (1<<REFS0);
      92:	80 e4       	ldi	r24, 0x40	; 64
      94:	87 b9       	out	0x07, r24	; 7
	
	// ADC Enable and prescaler of 128
	// 16000000/128 = 125000
	ADCSRA = (1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0);
      96:	87 e8       	ldi	r24, 0x87	; 135
      98:	86 b9       	out	0x06, r24	; 6
}
      9a:	08 95       	ret

0000009c <adc_read>:
{
	// select the corresponding channel 0~7
	// ANDing with ’7? will always keep the value
	// of ‘ch’ between 0 and 7
	ch &= 0b00000111;  // AND operation with 7
	ADMUX = (ADMUX & 0xF8)|ch; // clears the bottom 3 bits before ORing
      9c:	97 b1       	in	r25, 0x07	; 7
uint16_t adc_read(uint8_t ch)
{
	// select the corresponding channel 0~7
	// ANDing with ’7? will always keep the value
	// of ‘ch’ between 0 and 7
	ch &= 0b00000111;  // AND operation with 7
      9e:	87 70       	andi	r24, 0x07	; 7
	ADMUX = (ADMUX & 0xF8)|ch; // clears the bottom 3 bits before ORing
      a0:	98 7f       	andi	r25, 0xF8	; 248
      a2:	98 2b       	or	r25, r24
      a4:	97 b9       	out	0x07, r25	; 7
	
	// start single convertion
	// write ’1? to ADSC
	ADCSRA |= (1<<ADSC);
      a6:	36 9a       	sbi	0x06, 6	; 6
	
	// wait for conversion to complete
	// ADSC becomes ’0? again
	// till then, run loop continuously
	while(ADCSRA & (1<<ADSC));
      a8:	36 99       	sbic	0x06, 6	; 6
      aa:	fe cf       	rjmp	.-4      	; 0xa8 <adc_read+0xc>
	
	
	return (ADC);
      ac:	84 b1       	in	r24, 0x04	; 4
      ae:	95 b1       	in	r25, 0x05	; 5
}
      b0:	08 95       	ret

000000b2 <ADC_vinit>:

void ADC_vinit()
{
	
	// 5v vref
	ADMUX |=(1<<REFS0);
      b2:	3e 9a       	sbi	0x07, 6	; 7
	ADMUX &= (~(1<<REFS1));
      b4:	3f 98       	cbi	0x07, 7	; 7
	
	//port number |= (1<<0);
	
	ADCSRA |=(1<<ADEN); // Enable ADC
      b6:	37 9a       	sbi	0x06, 7	; 6
	
	// devide by 64
	ADCSRA |=(1<<ADPS2);
      b8:	32 9a       	sbi	0x06, 2	; 6
	ADCSRA |=(1<<ADPS1);
      ba:	31 9a       	sbi	0x06, 1	; 6
	ADCSRA &= (~(1<<ADPS0));
      bc:	30 98       	cbi	0x06, 0	; 6
	
	ADCSRA |= (1<<ADIE);//Enable interrupts
      be:	33 9a       	sbi	0x06, 3	; 6
	
}
      c0:	08 95       	ret

000000c2 <ADC_u16convert>:
void ADC_u16convert()
{
	ADCSRA |= (1<<ADSC);
      c2:	36 9a       	sbi	0x06, 6	; 6
	
	ADCSRA |= (1<<4);
      c4:	34 9a       	sbi	0x06, 4	; 6
	
	while((ADCSRA&(1<<4))==0)
      c6:	34 9b       	sbis	0x06, 4	; 6
      c8:	fe cf       	rjmp	.-4      	; 0xc6 <ADC_u16convert+0x4>
	
	unsigned short ret = 0;//(ADCL) | (ADCH<<8)  ;
	
	
	return ret;
      ca:	08 95       	ret

000000cc <write_eeprom>:
 *  Author: Abdullah
 */ 
#include <avr/io.h>
void write_eeprom(short address , char data)
{
	while(((EECR& (1<<EEWE))>>EEWE)==1)
      cc:	e1 99       	sbic	0x1c, 1	; 28
      ce:	fe cf       	rjmp	.-4      	; 0xcc <write_eeprom>
	{
		/*wait until EEPROM IS FREE */
	}
	
	//adrress of the EEPROM and because it is 1024 is 12 bits so to chars one high and one low
	EEARL = (char)address;
      d0:	8e bb       	out	0x1e, r24	; 30
	EEARH= (char)(address>>8);
      d2:	89 2f       	mov	r24, r25
      d4:	99 0f       	add	r25, r25
      d6:	99 0b       	sbc	r25, r25
      d8:	8f bb       	out	0x1f, r24	; 31
	//Set data
	EEDR = data;
      da:	6d bb       	out	0x1d, r22	; 29
	//set master
	EECR |= (1<<EEMWE);
      dc:	e2 9a       	sbi	0x1c, 2	; 28
	//set write enable
	EECR |= (1<<EEWE);
      de:	e1 9a       	sbi	0x1c, 1	; 28
}
      e0:	08 95       	ret

000000e2 <read_eeprom>:
char read_eeprom(short address)
{
	while( ((EECR & (1<<EEWE))>>EEWE) ==1)
      e2:	e1 99       	sbic	0x1c, 1	; 28
      e4:	fe cf       	rjmp	.-4      	; 0xe2 <read_eeprom>
	{
		//wiat until EEPROM is free	
	}
	
	//adress
	EEARL = (char)address;
      e6:	8e bb       	out	0x1e, r24	; 30
	EEARH= (char)(address>>8);
      e8:	89 2f       	mov	r24, r25
      ea:	99 0f       	add	r25, r25
      ec:	99 0b       	sbc	r25, r25
      ee:	8f bb       	out	0x1f, r24	; 31
	//
	EECR |= (1<<EERE);
      f0:	e0 9a       	sbi	0x1c, 0	; 28
	
	return EEDR;	
      f2:	8d b3       	in	r24, 0x1d	; 29
      f4:	08 95       	ret

000000f6 <prvTestWaitCondition>:

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
      f6:	44 23       	and	r20, r20
      f8:	41 f4       	brne	.+16     	; 0x10a <prvTestWaitCondition+0x14>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
      fa:	68 23       	and	r22, r24
      fc:	79 23       	and	r23, r25
		{
			xWaitConditionMet = pdTRUE;
      fe:	81 e0       	ldi	r24, 0x01	; 1
     100:	61 15       	cp	r22, r1
     102:	71 05       	cpc	r23, r1
     104:	51 f4       	brne	.+20     	; 0x11a <prvTestWaitCondition+0x24>
     106:	80 e0       	ldi	r24, 0x00	; 0
     108:	08 95       	ret
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     10a:	9b 01       	movw	r18, r22
     10c:	28 23       	and	r18, r24
     10e:	39 23       	and	r19, r25
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
		{
			xWaitConditionMet = pdTRUE;
     110:	81 e0       	ldi	r24, 0x01	; 1
     112:	62 17       	cp	r22, r18
     114:	73 07       	cpc	r23, r19
     116:	09 f0       	breq	.+2      	; 0x11a <prvTestWaitCondition+0x24>
     118:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
}
     11a:	08 95       	ret

0000011c <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     11c:	cf 93       	push	r28
     11e:	df 93       	push	r29
	EventGroup_t *pxEventBits;

		/* Allocate the event group. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
     120:	8b e0       	ldi	r24, 0x0B	; 11
     122:	90 e0       	ldi	r25, 0x00	; 0
     124:	0e 94 24 02 	call	0x448	; 0x448 <pvPortMalloc>
     128:	ec 01       	movw	r28, r24

		if( pxEventBits != NULL )
     12a:	00 97       	sbiw	r24, 0x00	; 0
     12c:	31 f0       	breq	.+12     	; 0x13a <xEventGroupCreate+0x1e>
		{
			pxEventBits->uxEventBits = 0;
     12e:	fc 01       	movw	r30, r24
     130:	11 92       	st	Z+, r1
     132:	11 92       	st	Z+, r1
     134:	cf 01       	movw	r24, r30
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     136:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInitialise>
		{
			traceEVENT_GROUP_CREATE_FAILED();
		}

		return ( EventGroupHandle_t ) pxEventBits;
	}
     13a:	8c 2f       	mov	r24, r28
     13c:	9d 2f       	mov	r25, r29
     13e:	df 91       	pop	r29
     140:	cf 91       	pop	r28
     142:	08 95       	ret

00000144 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     144:	af 92       	push	r10
     146:	bf 92       	push	r11
     148:	cf 92       	push	r12
     14a:	df 92       	push	r13
     14c:	ef 92       	push	r14
     14e:	ff 92       	push	r15
     150:	0f 93       	push	r16
     152:	1f 93       	push	r17
     154:	cf 93       	push	r28
     156:	df 93       	push	r29
     158:	5c 01       	movw	r10, r24
     15a:	6b 01       	movw	r12, r22
     15c:	e4 2e       	mov	r14, r20
     15e:	f2 2e       	mov	r15, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     160:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     164:	f5 01       	movw	r30, r10
     166:	c0 81       	ld	r28, Z
     168:	d1 81       	ldd	r29, Z+1	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     16a:	ce 01       	movw	r24, r28
     16c:	b6 01       	movw	r22, r12
     16e:	4f 2d       	mov	r20, r15
     170:	0e 94 7b 00 	call	0xf6	; 0xf6 <prvTestWaitCondition>

		if( xWaitConditionMet != pdFALSE )
     174:	88 23       	and	r24, r24
     176:	51 f0       	breq	.+20     	; 0x18c <xEventGroupWaitBits+0x48>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     178:	ee 20       	and	r14, r14
     17a:	01 f1       	breq	.+64     	; 0x1bc <xEventGroupWaitBits+0x78>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     17c:	c0 94       	com	r12
     17e:	d0 94       	com	r13
     180:	cc 22       	and	r12, r28
     182:	dd 22       	and	r13, r29
     184:	f5 01       	movw	r30, r10
     186:	d1 82       	std	Z+1, r13	; 0x01
     188:	c0 82       	st	Z, r12
     18a:	18 c0       	rjmp	.+48     	; 0x1bc <xEventGroupWaitBits+0x78>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     18c:	01 15       	cp	r16, r1
     18e:	11 05       	cpc	r17, r1
     190:	a9 f0       	breq	.+42     	; 0x1bc <xEventGroupWaitBits+0x78>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     192:	ee 20       	and	r14, r14
     194:	19 f4       	brne	.+6      	; 0x19c <xEventGroupWaitBits+0x58>
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
     196:	60 e0       	ldi	r22, 0x00	; 0
     198:	70 e0       	ldi	r23, 0x00	; 0
     19a:	02 c0       	rjmp	.+4      	; 0x1a0 <xEventGroupWaitBits+0x5c>
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     19c:	60 e0       	ldi	r22, 0x00	; 0
     19e:	71 e0       	ldi	r23, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     1a0:	f1 10       	cpse	r15, r1
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     1a2:	74 60       	ori	r23, 0x04	; 4
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     1a4:	6c 29       	or	r22, r12
     1a6:	7d 29       	or	r23, r13
     1a8:	c5 01       	movw	r24, r10
     1aa:	02 96       	adiw	r24, 0x02	; 2
     1ac:	a8 01       	movw	r20, r16
     1ae:	0e 94 95 11 	call	0x232a	; 0x232a <vTaskPlaceOnUnorderedEventList>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     1b2:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
     1b6:	88 23       	and	r24, r24
     1b8:	39 f4       	brne	.+14     	; 0x1c8 <xEventGroupWaitBits+0x84>
     1ba:	04 c0       	rjmp	.+8      	; 0x1c4 <xEventGroupWaitBits+0x80>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     1bc:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <xTaskResumeAll>
     1c0:	ce 01       	movw	r24, r28
     1c2:	21 c0       	rjmp	.+66     	; 0x206 <xEventGroupWaitBits+0xc2>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     1c4:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     1c8:	0e 94 1b 13 	call	0x2636	; 0x2636 <uxTaskResetEventItemValue>
     1cc:	ec 01       	movw	r28, r24

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     1ce:	91 fd       	sbrc	r25, 1
     1d0:	18 c0       	rjmp	.+48     	; 0x202 <xEventGroupWaitBits+0xbe>
		{
			taskENTER_CRITICAL();
     1d2:	0f b6       	in	r0, 0x3f	; 63
     1d4:	f8 94       	cli
     1d6:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     1d8:	f5 01       	movw	r30, r10
     1da:	c0 81       	ld	r28, Z
     1dc:	d1 81       	ldd	r29, Z+1	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     1de:	ce 01       	movw	r24, r28
     1e0:	b6 01       	movw	r22, r12
     1e2:	4f 2d       	mov	r20, r15
     1e4:	0e 94 7b 00 	call	0xf6	; 0xf6 <prvTestWaitCondition>
     1e8:	88 23       	and	r24, r24
     1ea:	49 f0       	breq	.+18     	; 0x1fe <xEventGroupWaitBits+0xba>
				{
					if( xClearOnExit != pdFALSE )
     1ec:	ee 20       	and	r14, r14
     1ee:	39 f0       	breq	.+14     	; 0x1fe <xEventGroupWaitBits+0xba>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     1f0:	c0 94       	com	r12
     1f2:	d0 94       	com	r13
     1f4:	cc 22       	and	r12, r28
     1f6:	dd 22       	and	r13, r29
     1f8:	f5 01       	movw	r30, r10
     1fa:	d1 82       	std	Z+1, r13	; 0x01
     1fc:	c0 82       	st	Z, r12
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     1fe:	0f 90       	pop	r0
     200:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     202:	ce 01       	movw	r24, r28
     204:	90 70       	andi	r25, 0x00	; 0
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     206:	df 91       	pop	r29
     208:	cf 91       	pop	r28
     20a:	1f 91       	pop	r17
     20c:	0f 91       	pop	r16
     20e:	ff 90       	pop	r15
     210:	ef 90       	pop	r14
     212:	df 90       	pop	r13
     214:	cf 90       	pop	r12
     216:	bf 90       	pop	r11
     218:	af 90       	pop	r10
     21a:	08 95       	ret

0000021c <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     21c:	fc 01       	movw	r30, r24
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     21e:	0f b6       	in	r0, 0x3f	; 63
     220:	f8 94       	cli
     222:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     224:	80 81       	ld	r24, Z
     226:	91 81       	ldd	r25, Z+1	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     228:	60 95       	com	r22
     22a:	70 95       	com	r23
     22c:	68 23       	and	r22, r24
     22e:	79 23       	and	r23, r25
     230:	71 83       	std	Z+1, r23	; 0x01
     232:	60 83       	st	Z, r22
	}
	taskEXIT_CRITICAL();
     234:	0f 90       	pop	r0
     236:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     238:	08 95       	ret

0000023a <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     23a:	fc 01       	movw	r30, r24
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
     23c:	80 81       	ld	r24, Z
     23e:	91 81       	ldd	r25, Z+1	; 0x01
     240:	08 95       	ret

00000242 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     242:	af 92       	push	r10
     244:	bf 92       	push	r11
     246:	cf 92       	push	r12
     248:	df 92       	push	r13
     24a:	ef 92       	push	r14
     24c:	ff 92       	push	r15
     24e:	0f 93       	push	r16
     250:	1f 93       	push	r17
     252:	cf 93       	push	r28
     254:	df 93       	push	r29
     256:	8c 01       	movw	r16, r24
     258:	eb 01       	movw	r28, r22
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     25a:	0f 2e       	mov	r0, r31
     25c:	f5 e0       	ldi	r31, 0x05	; 5
     25e:	cf 2e       	mov	r12, r31
     260:	dd 24       	eor	r13, r13
     262:	f0 2d       	mov	r31, r0
     264:	c8 0e       	add	r12, r24
     266:	d9 1e       	adc	r13, r25
	vTaskSuspendAll();
     268:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     26c:	d8 01       	movw	r26, r16
     26e:	17 96       	adiw	r26, 0x07	; 7
     270:	ed 91       	ld	r30, X+
     272:	fc 91       	ld	r31, X
     274:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     276:	8d 91       	ld	r24, X+
     278:	9c 91       	ld	r25, X
     27a:	11 97       	sbiw	r26, 0x01	; 1
     27c:	8c 2b       	or	r24, r28
     27e:	9d 2b       	or	r25, r29
     280:	11 96       	adiw	r26, 0x01	; 1
     282:	9c 93       	st	X, r25
     284:	8e 93       	st	-X, r24

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     286:	ce 16       	cp	r12, r30
     288:	df 06       	cpc	r13, r31
     28a:	c1 f1       	breq	.+112    	; 0x2fc <xEventGroupSetBits+0xba>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     28c:	aa 24       	eor	r10, r10
     28e:	bb 24       	eor	r11, r11
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     290:	ff 24       	eor	r15, r15
     292:	f3 94       	inc	r15
     294:	ee 24       	eor	r14, r14
     296:	01 c0       	rjmp	.+2      	; 0x29a <xEventGroupSetBits+0x58>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     298:	fe 01       	movw	r30, r28
		{
			pxNext = listGET_NEXT( pxListItem );
     29a:	c2 81       	ldd	r28, Z+2	; 0x02
     29c:	d3 81       	ldd	r29, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     29e:	80 81       	ld	r24, Z
     2a0:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     2a2:	bc 01       	movw	r22, r24
     2a4:	60 70       	andi	r22, 0x00	; 0
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     2a6:	9c 01       	movw	r18, r24
     2a8:	30 70       	andi	r19, 0x00	; 0

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     2aa:	92 fd       	sbrc	r25, 2
     2ac:	0b c0       	rjmp	.+22     	; 0x2c4 <xEventGroupSetBits+0x82>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     2ae:	d8 01       	movw	r26, r16
     2b0:	8d 91       	ld	r24, X+
     2b2:	9c 91       	ld	r25, X
     2b4:	11 97       	sbiw	r26, 0x01	; 1
     2b6:	82 23       	and	r24, r18
     2b8:	93 23       	and	r25, r19
				{
					xMatchFound = pdTRUE;
     2ba:	4f 2d       	mov	r20, r15
     2bc:	00 97       	sbiw	r24, 0x00	; 0
     2be:	69 f4       	brne	.+26     	; 0x2da <xEventGroupSetBits+0x98>
     2c0:	4e 2d       	mov	r20, r14
     2c2:	0b c0       	rjmp	.+22     	; 0x2da <xEventGroupSetBits+0x98>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     2c4:	d8 01       	movw	r26, r16
     2c6:	8d 91       	ld	r24, X+
     2c8:	9c 91       	ld	r25, X
     2ca:	11 97       	sbiw	r26, 0x01	; 1
     2cc:	82 23       	and	r24, r18
     2ce:	93 23       	and	r25, r19
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     2d0:	4f 2d       	mov	r20, r15
     2d2:	28 17       	cp	r18, r24
     2d4:	39 07       	cpc	r19, r25
     2d6:	09 f0       	breq	.+2      	; 0x2da <xEventGroupSetBits+0x98>
     2d8:	4e 2d       	mov	r20, r14
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     2da:	44 23       	and	r20, r20
     2dc:	59 f0       	breq	.+22     	; 0x2f4 <xEventGroupSetBits+0xb2>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     2de:	70 ff       	sbrs	r23, 0
     2e0:	02 c0       	rjmp	.+4      	; 0x2e6 <xEventGroupSetBits+0xa4>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     2e2:	a2 2a       	or	r10, r18
     2e4:	b3 2a       	or	r11, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     2e6:	d8 01       	movw	r26, r16
     2e8:	6d 91       	ld	r22, X+
     2ea:	7c 91       	ld	r23, X
     2ec:	72 60       	ori	r23, 0x02	; 2
     2ee:	cf 01       	movw	r24, r30
     2f0:	0e 94 f9 11 	call	0x23f2	; 0x23f2 <xTaskRemoveFromUnorderedEventList>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     2f4:	cc 16       	cp	r12, r28
     2f6:	dd 06       	cpc	r13, r29
     2f8:	79 f6       	brne	.-98     	; 0x298 <xEventGroupSetBits+0x56>
     2fa:	02 c0       	rjmp	.+4      	; 0x300 <xEventGroupSetBits+0xbe>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     2fc:	aa 24       	eor	r10, r10
     2fe:	bb 24       	eor	r11, r11
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     300:	c5 01       	movw	r24, r10
     302:	80 95       	com	r24
     304:	90 95       	com	r25
     306:	f8 01       	movw	r30, r16
     308:	a0 80       	ld	r10, Z
     30a:	b1 80       	ldd	r11, Z+1	; 0x01
     30c:	a8 22       	and	r10, r24
     30e:	b9 22       	and	r11, r25
     310:	b1 82       	std	Z+1, r11	; 0x01
     312:	a0 82       	st	Z, r10
	}
	( void ) xTaskResumeAll();
     314:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
     318:	d8 01       	movw	r26, r16
     31a:	8c 91       	ld	r24, X
     31c:	11 96       	adiw	r26, 0x01	; 1
     31e:	9c 91       	ld	r25, X
     320:	11 97       	sbiw	r26, 0x01	; 1
     322:	df 91       	pop	r29
     324:	cf 91       	pop	r28
     326:	1f 91       	pop	r17
     328:	0f 91       	pop	r16
     32a:	ff 90       	pop	r15
     32c:	ef 90       	pop	r14
     32e:	df 90       	pop	r13
     330:	cf 90       	pop	r12
     332:	bf 90       	pop	r11
     334:	af 90       	pop	r10
     336:	08 95       	ret

00000338 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     338:	af 92       	push	r10
     33a:	bf 92       	push	r11
     33c:	cf 92       	push	r12
     33e:	df 92       	push	r13
     340:	ef 92       	push	r14
     342:	ff 92       	push	r15
     344:	0f 93       	push	r16
     346:	1f 93       	push	r17
     348:	cf 93       	push	r28
     34a:	df 93       	push	r29
     34c:	6c 01       	movw	r12, r24
     34e:	eb 01       	movw	r28, r22
     350:	7a 01       	movw	r14, r20
     352:	59 01       	movw	r10, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     354:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     358:	f6 01       	movw	r30, r12
     35a:	00 81       	ld	r16, Z
     35c:	11 81       	ldd	r17, Z+1	; 0x01

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     35e:	c6 01       	movw	r24, r12
     360:	be 01       	movw	r22, r28
     362:	0e 94 21 01 	call	0x242	; 0x242 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     366:	c0 2b       	or	r28, r16
     368:	d1 2b       	or	r29, r17
     36a:	c7 01       	movw	r24, r14
     36c:	8c 23       	and	r24, r28
     36e:	9d 23       	and	r25, r29
     370:	8e 15       	cp	r24, r14
     372:	9f 05       	cpc	r25, r15
     374:	51 f4       	brne	.+20     	; 0x38a <xEventGroupSync+0x52>
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     376:	80 95       	com	r24
     378:	90 95       	com	r25
     37a:	f6 01       	movw	r30, r12
     37c:	20 81       	ld	r18, Z
     37e:	31 81       	ldd	r19, Z+1	; 0x01
     380:	82 23       	and	r24, r18
     382:	93 23       	and	r25, r19
     384:	91 83       	std	Z+1, r25	; 0x01
     386:	80 83       	st	Z, r24
     388:	12 c0       	rjmp	.+36     	; 0x3ae <xEventGroupSync+0x76>

			xTicksToWait = 0;
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     38a:	a1 14       	cp	r10, r1
     38c:	b1 04       	cpc	r11, r1
     38e:	61 f0       	breq	.+24     	; 0x3a8 <xEventGroupSync+0x70>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     390:	b7 01       	movw	r22, r14
     392:	75 60       	ori	r23, 0x05	; 5
     394:	c6 01       	movw	r24, r12
     396:	02 96       	adiw	r24, 0x02	; 2
     398:	a5 01       	movw	r20, r10
     39a:	0e 94 95 11 	call	0x232a	; 0x232a <vTaskPlaceOnUnorderedEventList>
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     39e:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
     3a2:	88 23       	and	r24, r24
     3a4:	49 f4       	brne	.+18     	; 0x3b8 <xEventGroupSync+0x80>
     3a6:	06 c0       	rjmp	.+12     	; 0x3b4 <xEventGroupSync+0x7c>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     3a8:	f6 01       	movw	r30, r12
     3aa:	c0 81       	ld	r28, Z
     3ac:	d1 81       	ldd	r29, Z+1	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     3ae:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <xTaskResumeAll>
     3b2:	1c c0       	rjmp	.+56     	; 0x3ec <xEventGroupSync+0xb4>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     3b4:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     3b8:	0e 94 1b 13 	call	0x2636	; 0x2636 <uxTaskResetEventItemValue>

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     3bc:	91 fd       	sbrc	r25, 1
     3be:	14 c0       	rjmp	.+40     	; 0x3e8 <xEventGroupSync+0xb0>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     3c0:	0f b6       	in	r0, 0x3f	; 63
     3c2:	f8 94       	cli
     3c4:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     3c6:	f6 01       	movw	r30, r12
     3c8:	80 81       	ld	r24, Z
     3ca:	91 81       	ldd	r25, Z+1	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     3cc:	97 01       	movw	r18, r14
     3ce:	28 23       	and	r18, r24
     3d0:	39 23       	and	r19, r25
     3d2:	2e 15       	cp	r18, r14
     3d4:	3f 05       	cpc	r19, r15
     3d6:	31 f4       	brne	.+12     	; 0x3e4 <xEventGroupSync+0xac>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     3d8:	20 95       	com	r18
     3da:	30 95       	com	r19
     3dc:	28 23       	and	r18, r24
     3de:	39 23       	and	r19, r25
     3e0:	31 83       	std	Z+1, r19	; 0x01
     3e2:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     3e4:	0f 90       	pop	r0
     3e6:	0f be       	out	0x3f, r0	; 63
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     3e8:	ec 01       	movw	r28, r24
     3ea:	d0 70       	andi	r29, 0x00	; 0
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     3ec:	8c 2f       	mov	r24, r28
     3ee:	9d 2f       	mov	r25, r29
     3f0:	df 91       	pop	r29
     3f2:	cf 91       	pop	r28
     3f4:	1f 91       	pop	r17
     3f6:	0f 91       	pop	r16
     3f8:	ff 90       	pop	r15
     3fa:	ef 90       	pop	r14
     3fc:	df 90       	pop	r13
     3fe:	cf 90       	pop	r12
     400:	bf 90       	pop	r11
     402:	af 90       	pop	r10
     404:	08 95       	ret

00000406 <vEventGroupDelete>:
	return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     406:	cf 93       	push	r28
     408:	df 93       	push	r29
     40a:	ec 01       	movw	r28, r24
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

	vTaskSuspendAll();
     40c:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     410:	8a 81       	ldd	r24, Y+2	; 0x02
     412:	88 23       	and	r24, r24
     414:	49 f0       	breq	.+18     	; 0x428 <vEventGroupDelete+0x22>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     416:	8f 81       	ldd	r24, Y+7	; 0x07
     418:	98 85       	ldd	r25, Y+8	; 0x08
     41a:	60 e0       	ldi	r22, 0x00	; 0
     41c:	72 e0       	ldi	r23, 0x02	; 2
     41e:	0e 94 f9 11 	call	0x23f2	; 0x23f2 <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     422:	8a 81       	ldd	r24, Y+2	; 0x02
     424:	88 23       	and	r24, r24
     426:	b9 f7       	brne	.-18     	; 0x416 <vEventGroupDelete+0x10>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     428:	ce 01       	movw	r24, r28
     42a:	0e 94 c4 02 	call	0x588	; 0x588 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     42e:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <xTaskResumeAll>
}
     432:	df 91       	pop	r29
     434:	cf 91       	pop	r28
     436:	08 95       	ret

00000438 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
     438:	ba 01       	movw	r22, r20
     43a:	0e 94 21 01 	call	0x242	; 0x242 <xEventGroupSetBits>
}
     43e:	08 95       	ret

00000440 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
     440:	ba 01       	movw	r22, r20
     442:	0e 94 0e 01 	call	0x21c	; 0x21c <xEventGroupClearBits>
}
     446:	08 95       	ret

00000448 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     448:	0f 93       	push	r16
     44a:	1f 93       	push	r17
     44c:	cf 93       	push	r28
     44e:	df 93       	push	r29
     450:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     452:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     456:	80 91 80 00 	lds	r24, 0x0080
     45a:	88 23       	and	r24, r24
     45c:	f9 f4       	brne	.+62     	; 0x49c <pvPortMalloc+0x54>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     45e:	8a e8       	ldi	r24, 0x8A	; 138
     460:	90 e0       	ldi	r25, 0x00	; 0
     462:	90 93 82 00 	sts	0x0082, r25
     466:	80 93 81 00 	sts	0x0081, r24
	xStart.xBlockSize = ( size_t ) 0;
     46a:	10 92 84 00 	sts	0x0084, r1
     46e:	10 92 83 00 	sts	0x0083, r1

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     472:	8f e1       	ldi	r24, 0x1F	; 31
     474:	93 e0       	ldi	r25, 0x03	; 3
     476:	90 93 88 00 	sts	0x0088, r25
     47a:	80 93 87 00 	sts	0x0087, r24
	xEnd.pxNextFreeBlock = NULL;
     47e:	e7 e8       	ldi	r30, 0x87	; 135
     480:	f0 e0       	ldi	r31, 0x00	; 0
     482:	12 92       	st	-Z, r1
     484:	12 92       	st	-Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     486:	90 93 8d 00 	sts	0x008D, r25
     48a:	80 93 8c 00 	sts	0x008C, r24
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     48e:	f0 93 8b 00 	sts	0x008B, r31
     492:	e0 93 8a 00 	sts	0x008A, r30
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
     496:	81 e0       	ldi	r24, 0x01	; 1
     498:	80 93 80 00 	sts	0x0080, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     49c:	20 97       	sbiw	r28, 0x00	; 0
     49e:	09 f4       	brne	.+2      	; 0x4a2 <pvPortMalloc+0x5a>
     4a0:	62 c0       	rjmp	.+196    	; 0x566 <pvPortMalloc+0x11e>
		{
			xWantedSize += heapSTRUCT_SIZE;
     4a2:	9e 01       	movw	r18, r28
     4a4:	2c 5f       	subi	r18, 0xFC	; 252
     4a6:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     4a8:	23 96       	adiw	r28, 0x03	; 3
     4aa:	83 e0       	ldi	r24, 0x03	; 3
     4ac:	ce 31       	cpi	r28, 0x1E	; 30
     4ae:	d8 07       	cpc	r29, r24
     4b0:	08 f0       	brcs	.+2      	; 0x4b4 <pvPortMalloc+0x6c>
     4b2:	5c c0       	rjmp	.+184    	; 0x56c <pvPortMalloc+0x124>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     4b4:	e0 91 81 00 	lds	r30, 0x0081
     4b8:	f0 91 82 00 	lds	r31, 0x0082

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     4bc:	a1 e8       	ldi	r26, 0x81	; 129
     4be:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     4c0:	02 c0       	rjmp	.+4      	; 0x4c6 <pvPortMalloc+0x7e>
     4c2:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     4c4:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     4c6:	82 81       	ldd	r24, Z+2	; 0x02
     4c8:	93 81       	ldd	r25, Z+3	; 0x03
     4ca:	82 17       	cp	r24, r18
     4cc:	93 07       	cpc	r25, r19
     4ce:	20 f4       	brcc	.+8      	; 0x4d8 <pvPortMalloc+0x90>
     4d0:	80 81       	ld	r24, Z
     4d2:	91 81       	ldd	r25, Z+1	; 0x01
     4d4:	00 97       	sbiw	r24, 0x00	; 0
     4d6:	a9 f7       	brne	.-22     	; 0x4c2 <pvPortMalloc+0x7a>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     4d8:	c0 e0       	ldi	r28, 0x00	; 0
     4da:	e5 38       	cpi	r30, 0x85	; 133
     4dc:	fc 07       	cpc	r31, r28
     4de:	09 f4       	brne	.+2      	; 0x4e2 <pvPortMalloc+0x9a>
     4e0:	48 c0       	rjmp	.+144    	; 0x572 <pvPortMalloc+0x12a>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     4e2:	8d 91       	ld	r24, X+
     4e4:	9c 91       	ld	r25, X
     4e6:	11 97       	sbiw	r26, 0x01	; 1
     4e8:	8c 01       	movw	r16, r24
     4ea:	0c 5f       	subi	r16, 0xFC	; 252
     4ec:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     4ee:	80 81       	ld	r24, Z
     4f0:	91 81       	ldd	r25, Z+1	; 0x01
     4f2:	11 96       	adiw	r26, 0x01	; 1
     4f4:	9c 93       	st	X, r25
     4f6:	8e 93       	st	-X, r24

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     4f8:	82 81       	ldd	r24, Z+2	; 0x02
     4fa:	93 81       	ldd	r25, Z+3	; 0x03
     4fc:	82 1b       	sub	r24, r18
     4fe:	93 0b       	sbc	r25, r19
     500:	89 30       	cpi	r24, 0x09	; 9
     502:	91 05       	cpc	r25, r1
     504:	18 f1       	brcs	.+70     	; 0x54c <pvPortMalloc+0x104>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     506:	af 01       	movw	r20, r30
     508:	42 0f       	add	r20, r18
     50a:	53 1f       	adc	r21, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     50c:	da 01       	movw	r26, r20
     50e:	13 96       	adiw	r26, 0x03	; 3
     510:	9c 93       	st	X, r25
     512:	8e 93       	st	-X, r24
     514:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     516:	33 83       	std	Z+3, r19	; 0x03
     518:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     51a:	12 96       	adiw	r26, 0x02	; 2
     51c:	2d 91       	ld	r18, X+
     51e:	3c 91       	ld	r19, X
     520:	13 97       	sbiw	r26, 0x03	; 3
     522:	61 e8       	ldi	r22, 0x81	; 129
     524:	70 e0       	ldi	r23, 0x00	; 0
     526:	01 c0       	rjmp	.+2      	; 0x52a <pvPortMalloc+0xe2>
     528:	bd 01       	movw	r22, r26
     52a:	eb 01       	movw	r28, r22
     52c:	a8 81       	ld	r26, Y
     52e:	b9 81       	ldd	r27, Y+1	; 0x01
     530:	12 96       	adiw	r26, 0x02	; 2
     532:	8d 91       	ld	r24, X+
     534:	9c 91       	ld	r25, X
     536:	13 97       	sbiw	r26, 0x03	; 3
     538:	82 17       	cp	r24, r18
     53a:	93 07       	cpc	r25, r19
     53c:	a8 f3       	brcs	.-22     	; 0x528 <pvPortMalloc+0xe0>
     53e:	ea 01       	movw	r28, r20
     540:	b9 83       	std	Y+1, r27	; 0x01
     542:	a8 83       	st	Y, r26
     544:	db 01       	movw	r26, r22
     546:	11 96       	adiw	r26, 0x01	; 1
     548:	5c 93       	st	X, r21
     54a:	4e 93       	st	-X, r20
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     54c:	80 91 60 00 	lds	r24, 0x0060
     550:	90 91 61 00 	lds	r25, 0x0061
     554:	22 81       	ldd	r18, Z+2	; 0x02
     556:	33 81       	ldd	r19, Z+3	; 0x03
     558:	82 1b       	sub	r24, r18
     55a:	93 0b       	sbc	r25, r19
     55c:	90 93 61 00 	sts	0x0061, r25
     560:	80 93 60 00 	sts	0x0060, r24
     564:	08 c0       	rjmp	.+16     	; 0x576 <pvPortMalloc+0x12e>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     566:	00 e0       	ldi	r16, 0x00	; 0
     568:	10 e0       	ldi	r17, 0x00	; 0
     56a:	05 c0       	rjmp	.+10     	; 0x576 <pvPortMalloc+0x12e>
     56c:	00 e0       	ldi	r16, 0x00	; 0
     56e:	10 e0       	ldi	r17, 0x00	; 0
     570:	02 c0       	rjmp	.+4      	; 0x576 <pvPortMalloc+0x12e>
     572:	00 e0       	ldi	r16, 0x00	; 0
     574:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     576:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     57a:	80 2f       	mov	r24, r16
     57c:	91 2f       	mov	r25, r17
     57e:	df 91       	pop	r29
     580:	cf 91       	pop	r28
     582:	1f 91       	pop	r17
     584:	0f 91       	pop	r16
     586:	08 95       	ret

00000588 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     588:	0f 93       	push	r16
     58a:	1f 93       	push	r17
     58c:	cf 93       	push	r28
     58e:	df 93       	push	r29
     590:	ec 01       	movw	r28, r24
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     592:	00 97       	sbiw	r24, 0x00	; 0
     594:	39 f1       	breq	.+78     	; 0x5e4 <vPortFree+0x5c>
		before it. */
		puc -= heapSTRUCT_SIZE;

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
     596:	8c 01       	movw	r16, r24
     598:	04 50       	subi	r16, 0x04	; 4
     59a:	10 40       	sbci	r17, 0x00	; 0

		vTaskSuspendAll();
     59c:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     5a0:	f8 01       	movw	r30, r16
     5a2:	22 81       	ldd	r18, Z+2	; 0x02
     5a4:	33 81       	ldd	r19, Z+3	; 0x03
     5a6:	a1 e8       	ldi	r26, 0x81	; 129
     5a8:	b0 e0       	ldi	r27, 0x00	; 0
     5aa:	01 c0       	rjmp	.+2      	; 0x5ae <vPortFree+0x26>
     5ac:	df 01       	movw	r26, r30
     5ae:	ed 91       	ld	r30, X+
     5b0:	fc 91       	ld	r31, X
     5b2:	11 97       	sbiw	r26, 0x01	; 1
     5b4:	82 81       	ldd	r24, Z+2	; 0x02
     5b6:	93 81       	ldd	r25, Z+3	; 0x03
     5b8:	82 17       	cp	r24, r18
     5ba:	93 07       	cpc	r25, r19
     5bc:	b8 f3       	brcs	.-18     	; 0x5ac <vPortFree+0x24>
     5be:	24 97       	sbiw	r28, 0x04	; 4
     5c0:	f9 83       	std	Y+1, r31	; 0x01
     5c2:	e8 83       	st	Y, r30
     5c4:	0d 93       	st	X+, r16
     5c6:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     5c8:	80 91 60 00 	lds	r24, 0x0060
     5cc:	90 91 61 00 	lds	r25, 0x0061
     5d0:	2a 81       	ldd	r18, Y+2	; 0x02
     5d2:	3b 81       	ldd	r19, Y+3	; 0x03
     5d4:	82 0f       	add	r24, r18
     5d6:	93 1f       	adc	r25, r19
     5d8:	90 93 61 00 	sts	0x0061, r25
     5dc:	80 93 60 00 	sts	0x0060, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     5e0:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <xTaskResumeAll>
	}
}
     5e4:	df 91       	pop	r29
     5e6:	cf 91       	pop	r28
     5e8:	1f 91       	pop	r17
     5ea:	0f 91       	pop	r16
     5ec:	08 95       	ret

000005ee <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
     5ee:	80 91 60 00 	lds	r24, 0x0060
     5f2:	90 91 61 00 	lds	r25, 0x0061
     5f6:	08 95       	ret

000005f8 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* This just exists to keep the linker quiet. */
}
     5f8:	08 95       	ret

000005fa <keypad_init>:



void keypad_init()
{
	DDRC = 0x0f;
     5fa:	8f e0       	ldi	r24, 0x0F	; 15
     5fc:	84 bb       	out	0x14, r24	; 20
	PORTC = 0xf0;
     5fe:	80 ef       	ldi	r24, 0xF0	; 240
     600:	85 bb       	out	0x15, r24	; 21
	//floating point
	SFIOR &=(~(1<<PUD));
     602:	80 b7       	in	r24, 0x30	; 48
     604:	8b 7f       	andi	r24, 0xFB	; 251
     606:	80 bf       	out	0x30, r24	; 48
}
     608:	08 95       	ret

0000060a <check>:

char check()
{
     60a:	af 92       	push	r10
     60c:	bf 92       	push	r11
     60e:	cf 92       	push	r12
     610:	df 92       	push	r13
     612:	ef 92       	push	r14
     614:	ff 92       	push	r15
     616:	0f 93       	push	r16
     618:	1f 93       	push	r17
     61a:	cf 93       	push	r28
     61c:	df 93       	push	r29
     61e:	cd b7       	in	r28, 0x3d	; 61
     620:	de b7       	in	r29, 0x3e	; 62
     622:	60 97       	sbiw	r28, 0x10	; 16
     624:	0f b6       	in	r0, 0x3f	; 63
     626:	f8 94       	cli
     628:	de bf       	out	0x3e, r29	; 62
     62a:	0f be       	out	0x3f, r0	; 63
     62c:	cd bf       	out	0x3d, r28	; 61
	char ret =0;
	char flag=0;
	
	char buttonss[4][4]  = {{'7','4','1','o'},{'8','5','2','0'},{'9','6','3','='},{'//','*','-','+'}};
     62e:	de 01       	movw	r26, r28
     630:	11 96       	adiw	r26, 0x01	; 1
     632:	e2 e6       	ldi	r30, 0x62	; 98
     634:	f0 e0       	ldi	r31, 0x00	; 0
     636:	80 e1       	ldi	r24, 0x10	; 16
     638:	01 90       	ld	r0, Z+
     63a:	0d 92       	st	X+, r0
     63c:	81 50       	subi	r24, 0x01	; 1
     63e:	e1 f7       	brne	.-8      	; 0x638 <check+0x2e>
     640:	ee 24       	eor	r14, r14
     642:	ff 24       	eor	r15, r15
}

char check()
{
	char ret =0;
	char flag=0;
     644:	10 e0       	ldi	r17, 0x00	; 0
	SFIOR &=(~(1<<PUD));
}

char check()
{
	char ret =0;
     646:	00 e0       	ldi	r16, 0x00	; 0
	char row,col;
	
	for(char r=0;r<4;r++)
	{
		PORTC |=0x0f;
		PORTC &= (~(1<<r));
     648:	e1 e0       	ldi	r30, 0x01	; 1
     64a:	f0 e0       	ldi	r31, 0x00	; 0
     64c:	aa 24       	eor	r10, r10
     64e:	bb 24       	eor	r11, r11
     650:	68 94       	set
     652:	a2 f8       	bld	r10, 2
		{
			if(((PINC& (1<<(c+4)))>>(c+4))==0)
			{
				row=c;
				col=r;
				flag=1;
     654:	61 e0       	ldi	r22, 0x01	; 1
	
	char row,col;
	
	for(char r=0;r<4;r++)
	{
		PORTC |=0x0f;
     656:	85 b3       	in	r24, 0x15	; 21
     658:	8f 60       	ori	r24, 0x0F	; 15
     65a:	85 bb       	out	0x15, r24	; 21
		PORTC &= (~(1<<r));
     65c:	25 b3       	in	r18, 0x15	; 21
     65e:	cf 01       	movw	r24, r30
     660:	0e 2c       	mov	r0, r14
     662:	02 c0       	rjmp	.+4      	; 0x668 <check+0x5e>
     664:	88 0f       	add	r24, r24
     666:	99 1f       	adc	r25, r25
     668:	0a 94       	dec	r0
     66a:	e2 f7       	brpl	.-8      	; 0x664 <check+0x5a>
     66c:	80 95       	com	r24
     66e:	82 23       	and	r24, r18
     670:	85 bb       	out	0x15, r24	; 21
     672:	95 01       	movw	r18, r10
		
		for(char c=0;c<4;c++)
		{
			if(((PINC& (1<<(c+4)))>>(c+4))==0)
     674:	ae 2d       	mov	r26, r14
	PORTC = 0xf0;
	//floating point
	SFIOR &=(~(1<<PUD));
}

char check()
     676:	72 2f       	mov	r23, r18
     678:	74 50       	subi	r23, 0x04	; 4
		PORTC |=0x0f;
		PORTC &= (~(1<<r));
		
		for(char c=0;c<4;c++)
		{
			if(((PINC& (1<<(c+4)))>>(c+4))==0)
     67a:	83 b3       	in	r24, 0x13	; 19
     67c:	af 01       	movw	r20, r30
     67e:	02 2e       	mov	r0, r18
     680:	02 c0       	rjmp	.+4      	; 0x686 <check+0x7c>
     682:	44 0f       	add	r20, r20
     684:	55 1f       	adc	r21, r21
     686:	0a 94       	dec	r0
     688:	e2 f7       	brpl	.-8      	; 0x682 <check+0x78>
     68a:	90 e0       	ldi	r25, 0x00	; 0
     68c:	84 23       	and	r24, r20
     68e:	95 23       	and	r25, r21
     690:	02 2e       	mov	r0, r18
     692:	02 c0       	rjmp	.+4      	; 0x698 <check+0x8e>
     694:	95 95       	asr	r25
     696:	87 95       	ror	r24
     698:	0a 94       	dec	r0
     69a:	e2 f7       	brpl	.-8      	; 0x694 <check+0x8a>
     69c:	00 97       	sbiw	r24, 0x00	; 0
     69e:	21 f4       	brne	.+8      	; 0x6a8 <check+0x9e>
     6a0:	ca 2e       	mov	r12, r26
     6a2:	d7 2e       	mov	r13, r23
			{
				row=c;
				col=r;
				flag=1;
     6a4:	16 2f       	mov	r17, r22
				ret=1;
     6a6:	06 2f       	mov	r16, r22
		PORTC |=0x0f;
		PORTC &= (~(1<<r));
		
		for(char c=0;c<4;c++)
		{
			if(((PINC& (1<<(c+4)))>>(c+4))==0)
     6a8:	2f 5f       	subi	r18, 0xFF	; 255
     6aa:	3f 4f       	sbci	r19, 0xFF	; 255
	for(char r=0;r<4;r++)
	{
		PORTC |=0x0f;
		PORTC &= (~(1<<r));
		
		for(char c=0;c<4;c++)
     6ac:	28 30       	cpi	r18, 0x08	; 8
     6ae:	31 05       	cpc	r19, r1
     6b0:	11 f7       	brne	.-60     	; 0x676 <check+0x6c>
				flag=1;
				ret=1;
			}
			
		}
		if(flag == 1 )
     6b2:	11 30       	cpi	r17, 0x01	; 1
     6b4:	39 f0       	breq	.+14     	; 0x6c4 <check+0xba>
     6b6:	08 94       	sec
     6b8:	e1 1c       	adc	r14, r1
     6ba:	f1 1c       	adc	r15, r1
	
	char buttonss[4][4]  = {{'7','4','1','o'},{'8','5','2','0'},{'9','6','3','='},{'//','*','-','+'}};
	
	char row,col;
	
	for(char r=0;r<4;r++)
     6bc:	84 e0       	ldi	r24, 0x04	; 4
     6be:	e8 16       	cp	r14, r24
     6c0:	f1 04       	cpc	r15, r1
     6c2:	49 f6       	brne	.-110    	; 0x656 <check+0x4c>
		{
			break;
		}
	}
	
	if(flag==1)
     6c4:	11 30       	cpi	r17, 0x01	; 1
     6c6:	59 f4       	brne	.+22     	; 0x6de <check+0xd4>
	{
		ret = buttonss[row][col];
     6c8:	ed 2d       	mov	r30, r13
     6ca:	f0 e0       	ldi	r31, 0x00	; 0
     6cc:	ee 0f       	add	r30, r30
     6ce:	ff 1f       	adc	r31, r31
     6d0:	ee 0f       	add	r30, r30
     6d2:	ff 1f       	adc	r31, r31
     6d4:	ec 0d       	add	r30, r12
     6d6:	f1 1d       	adc	r31, r1
     6d8:	ec 0f       	add	r30, r28
     6da:	fd 1f       	adc	r31, r29
     6dc:	01 81       	ldd	r16, Z+1	; 0x01
	
	
	
	
	return ret;
     6de:	80 2f       	mov	r24, r16
     6e0:	60 96       	adiw	r28, 0x10	; 16
     6e2:	0f b6       	in	r0, 0x3f	; 63
     6e4:	f8 94       	cli
     6e6:	de bf       	out	0x3e, r29	; 62
     6e8:	0f be       	out	0x3f, r0	; 63
     6ea:	cd bf       	out	0x3d, r28	; 61
     6ec:	df 91       	pop	r29
     6ee:	cf 91       	pop	r28
     6f0:	1f 91       	pop	r17
     6f2:	0f 91       	pop	r16
     6f4:	ff 90       	pop	r15
     6f6:	ef 90       	pop	r14
     6f8:	df 90       	pop	r13
     6fa:	cf 90       	pop	r12
     6fc:	bf 90       	pop	r11
     6fe:	af 90       	pop	r10
     700:	08 95       	ret

00000702 <sendFallingEdge>:
	LCD_vsendCommand(address);
	
}
static void sendFallingEdge()
{
	PORTA |=(1<<EN);
     702:	db 9a       	sbi	0x1b, 3	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     704:	8f e9       	ldi	r24, 0x9F	; 159
     706:	9f e0       	ldi	r25, 0x0F	; 15
     708:	01 97       	sbiw	r24, 0x01	; 1
     70a:	f1 f7       	brne	.-4      	; 0x708 <sendFallingEdge+0x6>
     70c:	00 c0       	rjmp	.+0      	; 0x70e <sendFallingEdge+0xc>
     70e:	00 00       	nop
	_delay_ms(2);
	PORTA &=(~(1<<EN));
     710:	db 98       	cbi	0x1b, 3	; 27
     712:	8f e9       	ldi	r24, 0x9F	; 159
     714:	9f e0       	ldi	r25, 0x0F	; 15
     716:	01 97       	sbiw	r24, 0x01	; 1
     718:	f1 f7       	brne	.-4      	; 0x716 <sendFallingEdge+0x14>
     71a:	00 c0       	rjmp	.+0      	; 0x71c <sendFallingEdge+0x1a>
     71c:	00 00       	nop
	_delay_ms(2);
}
     71e:	08 95       	ret

00000720 <LCD_vsendCommand>:
}
#endif

#if defined (LCD_4bit)
void LCD_vsendCommand(char cmd) // run command on LCD
{
     720:	cf 93       	push	r28
     722:	c8 2f       	mov	r28, r24
	PORTA&= (~(1<<RS));// make RS regiter to zero to make it command
     724:	d9 98       	cbi	0x1b, 1	; 27
	
	PORTA&=0x0f;
     726:	8b b3       	in	r24, 0x1b	; 27
     728:	8f 70       	andi	r24, 0x0F	; 15
     72a:	8b bb       	out	0x1b, r24	; 27
	
	PORTA |= (0xf0 & cmd);
     72c:	8b b3       	in	r24, 0x1b	; 27
     72e:	9c 2f       	mov	r25, r28
     730:	90 7f       	andi	r25, 0xF0	; 240
     732:	89 2b       	or	r24, r25
     734:	8b bb       	out	0x1b, r24	; 27
	sendFallingEdge(); // run the command
     736:	0e 94 81 03 	call	0x702	; 0x702 <sendFallingEdge>
	
	PORTA&=0x0f;
     73a:	8b b3       	in	r24, 0x1b	; 27
     73c:	8f 70       	andi	r24, 0x0F	; 15
     73e:	8b bb       	out	0x1b, r24	; 27
	PORTA |= ((0x0f &cmd)<<4);
     740:	8b b3       	in	r24, 0x1b	; 27
     742:	c2 95       	swap	r28
     744:	c0 7f       	andi	r28, 0xF0	; 240
     746:	c8 2b       	or	r28, r24
     748:	cb bb       	out	0x1b, r28	; 27
	sendFallingEdge();// run the command
     74a:	0e 94 81 03 	call	0x702	; 0x702 <sendFallingEdge>
	
	
}
     74e:	cf 91       	pop	r28
     750:	08 95       	ret

00000752 <LCD_VINIT>:
void LCD_VINIT()
{
	DDRA |= 0xf0;
     752:	8a b3       	in	r24, 0x1a	; 26
     754:	80 6f       	ori	r24, 0xF0	; 240
     756:	8a bb       	out	0x1a, r24	; 26
	DDRA |=0x0e;
     758:	8a b3       	in	r24, 0x1a	; 26
     75a:	8e 60       	ori	r24, 0x0E	; 14
     75c:	8a bb       	out	0x1a, r24	; 26
	PORTA &=(~(1<<RW));
     75e:	da 98       	cbi	0x1b, 2	; 27
	
	//4bit mode all 8 bits used for data
	LCD_vsendCommand(0x33);
     760:	83 e3       	ldi	r24, 0x33	; 51
     762:	0e 94 90 03 	call	0x720	; 0x720 <LCD_vsendCommand>
	LCD_vsendCommand(0x32);
     766:	82 e3       	ldi	r24, 0x32	; 50
     768:	0e 94 90 03 	call	0x720	; 0x720 <LCD_vsendCommand>
	LCD_vsendCommand(0x28); // 2 lines 4 bit mode
     76c:	88 e2       	ldi	r24, 0x28	; 40
     76e:	0e 94 90 03 	call	0x720	; 0x720 <LCD_vsendCommand>
	
	LCD_vsendCommand(CLEAR_SCREEN);//clear screen
     772:	81 e0       	ldi	r24, 0x01	; 1
     774:	0e 94 90 03 	call	0x720	; 0x720 <LCD_vsendCommand>
	LCD_vsendCommand(CURSOR_ON);//Turn on cursor
     778:	8e e0       	ldi	r24, 0x0E	; 14
     77a:	0e 94 90 03 	call	0x720	; 0x720 <LCD_vsendCommand>
     77e:	8f e3       	ldi	r24, 0x3F	; 63
     780:	9c e9       	ldi	r25, 0x9C	; 156
     782:	01 97       	sbiw	r24, 0x01	; 1
     784:	f1 f7       	brne	.-4      	; 0x782 <LCD_VINIT+0x30>
     786:	00 c0       	rjmp	.+0      	; 0x788 <LCD_VINIT+0x36>
     788:	00 00       	nop
	_delay_ms(20);
	
}
     78a:	08 95       	ret

0000078c <LCD_vsendData>:
void LCD_vsendData(char data) // run command on LCD
{
     78c:	cf 93       	push	r28
     78e:	c8 2f       	mov	r28, r24
	PORTA|= (1<<RS); // make RS regiter to zero to make it command
     790:	d9 9a       	sbi	0x1b, 1	; 27
	
	PORTA&=0x0f;
     792:	8b b3       	in	r24, 0x1b	; 27
     794:	8f 70       	andi	r24, 0x0F	; 15
     796:	8b bb       	out	0x1b, r24	; 27
	
	PORTA |= (0xf0 & data);
     798:	8b b3       	in	r24, 0x1b	; 27
     79a:	9c 2f       	mov	r25, r28
     79c:	90 7f       	andi	r25, 0xF0	; 240
     79e:	89 2b       	or	r24, r25
     7a0:	8b bb       	out	0x1b, r24	; 27
	sendFallingEdge(); // run the command
     7a2:	0e 94 81 03 	call	0x702	; 0x702 <sendFallingEdge>
	
	PORTA&=0x0f;
     7a6:	8b b3       	in	r24, 0x1b	; 27
     7a8:	8f 70       	andi	r24, 0x0F	; 15
     7aa:	8b bb       	out	0x1b, r24	; 27
	PORTA |= ((0x0f &data)<<4);
     7ac:	8b b3       	in	r24, 0x1b	; 27
     7ae:	c2 95       	swap	r28
     7b0:	c0 7f       	andi	r28, 0xF0	; 240
     7b2:	c8 2b       	or	r28, r24
     7b4:	cb bb       	out	0x1b, r28	; 27
	sendFallingEdge();// run the command
     7b6:	0e 94 81 03 	call	0x702	; 0x702 <sendFallingEdge>
	
	
}
     7ba:	cf 91       	pop	r28
     7bc:	08 95       	ret

000007be <clear_screen>:
#endif
void clear_screen()
{
	LCD_vsendCommand(CLEAR_SCREEN);//clear screen
     7be:	81 e0       	ldi	r24, 0x01	; 1
     7c0:	0e 94 90 03 	call	0x720	; 0x720 <LCD_vsendCommand>
}
     7c4:	08 95       	ret

000007c6 <LCD_VGOTO>:
void LCD_VGOTO(char row,char col)
{
	char address;
	if (row==0)
     7c6:	88 23       	and	r24, r24
     7c8:	11 f4       	brne	.+4      	; 0x7ce <LCD_VGOTO+0x8>
	{
		address=0x80;
     7ca:	80 e8       	ldi	r24, 0x80	; 128
     7cc:	01 c0       	rjmp	.+2      	; 0x7d0 <LCD_VGOTO+0xa>
	}
	else
	{
		address=0xC0;
     7ce:	80 ec       	ldi	r24, 0xC0	; 192
	}
	
	address +=col;
	
	LCD_vsendCommand(address);
     7d0:	86 0f       	add	r24, r22
     7d2:	0e 94 90 03 	call	0x720	; 0x720 <LCD_vsendCommand>
	
}
     7d6:	08 95       	ret

000007d8 <LCD_VsnedString>:
	_delay_ms(2);
	PORTA &=(~(1<<EN));
	_delay_ms(2);
}
void LCD_VsnedString(char str[])
{
     7d8:	0f 93       	push	r16
     7da:	1f 93       	push	r17
     7dc:	cf 93       	push	r28
     7de:	8c 01       	movw	r16, r24
	char i=0;
	while(str[i] != '\0')
     7e0:	fc 01       	movw	r30, r24
     7e2:	80 81       	ld	r24, Z
     7e4:	88 23       	and	r24, r24
     7e6:	51 f0       	breq	.+20     	; 0x7fc <LCD_VsnedString+0x24>
	PORTA &=(~(1<<EN));
	_delay_ms(2);
}
void LCD_VsnedString(char str[])
{
	char i=0;
     7e8:	c0 e0       	ldi	r28, 0x00	; 0
	while(str[i] != '\0')
	{
		LCD_vsendData(str[i]);
     7ea:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
		i++;
     7ee:	cf 5f       	subi	r28, 0xFF	; 255
	_delay_ms(2);
}
void LCD_VsnedString(char str[])
{
	char i=0;
	while(str[i] != '\0')
     7f0:	f8 01       	movw	r30, r16
     7f2:	ec 0f       	add	r30, r28
     7f4:	f1 1d       	adc	r31, r1
     7f6:	80 81       	ld	r24, Z
     7f8:	88 23       	and	r24, r24
     7fa:	b9 f7       	brne	.-18     	; 0x7ea <LCD_VsnedString+0x12>
	{
		LCD_vsendData(str[i]);
		i++;
	}
	
}
     7fc:	cf 91       	pop	r28
     7fe:	1f 91       	pop	r17
     800:	0f 91       	pop	r16
     802:	08 95       	ret

00000804 <writeSetpassword>:

void writeSetpassword()
{
	LCD_vsendData('S');
     804:	83 e5       	ldi	r24, 0x53	; 83
     806:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('e');
     80a:	85 e6       	ldi	r24, 0x65	; 101
     80c:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('t');
     810:	84 e7       	ldi	r24, 0x74	; 116
     812:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData(' ');
     816:	80 e2       	ldi	r24, 0x20	; 32
     818:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('P');
     81c:	80 e5       	ldi	r24, 0x50	; 80
     81e:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('a');
     822:	81 e6       	ldi	r24, 0x61	; 97
     824:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('s');
     828:	83 e7       	ldi	r24, 0x73	; 115
     82a:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('s');
     82e:	83 e7       	ldi	r24, 0x73	; 115
     830:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('w');
     834:	87 e7       	ldi	r24, 0x77	; 119
     836:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('o');
     83a:	8f e6       	ldi	r24, 0x6F	; 111
     83c:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('r');
     840:	82 e7       	ldi	r24, 0x72	; 114
     842:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('d');
     846:	84 e6       	ldi	r24, 0x64	; 100
     848:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	
}
     84c:	08 95       	ret

0000084e <writeloginscreen>:

void writeloginscreen()
{
	
	LCD_vsendData('L');
     84e:	8c e4       	ldi	r24, 0x4C	; 76
     850:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('o');
     854:	8f e6       	ldi	r24, 0x6F	; 111
     856:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('g');
     85a:	87 e6       	ldi	r24, 0x67	; 103
     85c:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('i');
     860:	89 e6       	ldi	r24, 0x69	; 105
     862:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('n');
     866:	8e e6       	ldi	r24, 0x6E	; 110
     868:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData(':');
     86c:	8a e3       	ldi	r24, 0x3A	; 58
     86e:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_VGOTO(1,0);
     872:	81 e0       	ldi	r24, 0x01	; 1
     874:	60 e0       	ldi	r22, 0x00	; 0
     876:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <LCD_VGOTO>
	LCD_vsendData('1');
     87a:	81 e3       	ldi	r24, 0x31	; 49
     87c:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('.');
     880:	8e e2       	ldi	r24, 0x2E	; 46
     882:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('A');
     886:	81 e4       	ldi	r24, 0x41	; 65
     888:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('d');
     88c:	84 e6       	ldi	r24, 0x64	; 100
     88e:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('m');
     892:	8d e6       	ldi	r24, 0x6D	; 109
     894:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('i');
     898:	89 e6       	ldi	r24, 0x69	; 105
     89a:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('n');
     89e:	8e e6       	ldi	r24, 0x6E	; 110
     8a0:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData(' ');
     8a4:	80 e2       	ldi	r24, 0x20	; 32
     8a6:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('2');
     8aa:	82 e3       	ldi	r24, 0x32	; 50
     8ac:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('.');
     8b0:	8e e2       	ldi	r24, 0x2E	; 46
     8b2:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('G');
     8b6:	87 e4       	ldi	r24, 0x47	; 71
     8b8:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('u');
     8bc:	85 e7       	ldi	r24, 0x75	; 117
     8be:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('e');
     8c2:	85 e6       	ldi	r24, 0x65	; 101
     8c4:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('s');
     8c8:	83 e7       	ldi	r24, 0x73	; 115
     8ca:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('t');
     8ce:	84 e7       	ldi	r24, 0x74	; 116
     8d0:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
}
     8d4:	08 95       	ret

000008d6 <writewrongpassword>:

void writewrongpassword()
{
	LCD_vsendData('W');
     8d6:	87 e5       	ldi	r24, 0x57	; 87
     8d8:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('r');
     8dc:	82 e7       	ldi	r24, 0x72	; 114
     8de:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('o');
     8e2:	8f e6       	ldi	r24, 0x6F	; 111
     8e4:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('n');
     8e8:	8e e6       	ldi	r24, 0x6E	; 110
     8ea:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('g');
     8ee:	87 e6       	ldi	r24, 0x67	; 103
     8f0:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData(' ');
     8f4:	80 e2       	ldi	r24, 0x20	; 32
     8f6:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('P');
     8fa:	80 e5       	ldi	r24, 0x50	; 80
     8fc:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('a');
     900:	81 e6       	ldi	r24, 0x61	; 97
     902:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('s');
     906:	83 e7       	ldi	r24, 0x73	; 115
     908:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('s');
     90c:	83 e7       	ldi	r24, 0x73	; 115
     90e:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('w');
     912:	87 e7       	ldi	r24, 0x77	; 119
     914:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('o');
     918:	8f e6       	ldi	r24, 0x6F	; 111
     91a:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('r');
     91e:	82 e7       	ldi	r24, 0x72	; 114
     920:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('d');
     924:	84 e6       	ldi	r24, 0x64	; 100
     926:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	
	
	
}
     92a:	08 95       	ret

0000092c <writeadminscreen>:

void writeadminscreen()
{
	
	LCD_vsendData('R');
     92c:	82 e5       	ldi	r24, 0x52	; 82
     92e:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('o');
     932:	8f e6       	ldi	r24, 0x6F	; 111
     934:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('o');
     938:	8f e6       	ldi	r24, 0x6F	; 111
     93a:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('m');
     93e:	8d e6       	ldi	r24, 0x6D	; 109
     940:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('s');
     944:	83 e7       	ldi	r24, 0x73	; 115
     946:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData(':');
     94a:	8a e3       	ldi	r24, 0x3A	; 58
     94c:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('1');
     950:	81 e3       	ldi	r24, 0x31	; 49
     952:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData(' ');
     956:	80 e2       	ldi	r24, 0x20	; 32
     958:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('2');
     95c:	82 e3       	ldi	r24, 0x32	; 50
     95e:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData(' ');
     962:	80 e2       	ldi	r24, 0x20	; 32
     964:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('3');
     968:	83 e3       	ldi	r24, 0x33	; 51
     96a:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	
	LCD_VGOTO(1,0);
     96e:	81 e0       	ldi	r24, 0x01	; 1
     970:	60 e0       	ldi	r22, 0x00	; 0
     972:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <LCD_VGOTO>
	LCD_vsendData('4');
     976:	84 e3       	ldi	r24, 0x34	; 52
     978:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('.');
     97c:	8e e2       	ldi	r24, 0x2E	; 46
     97e:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('T');
     982:	84 e5       	ldi	r24, 0x54	; 84
     984:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('V');
     988:	86 e5       	ldi	r24, 0x56	; 86
     98a:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData(' ');
     98e:	80 e2       	ldi	r24, 0x20	; 32
     990:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('5');
     994:	85 e3       	ldi	r24, 0x35	; 53
     996:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('.');
     99a:	8e e2       	ldi	r24, 0x2E	; 46
     99c:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('A');
     9a0:	81 e4       	ldi	r24, 0x41	; 65
     9a2:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('c');
     9a6:	83 e6       	ldi	r24, 0x63	; 99
     9a8:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	
	
	//LCD_vsendData('W');
	
	
}
     9ac:	08 95       	ret

000009ae <writeguestscreen>:

void writeguestscreen()
{
	
	LCD_vsendData('R');
     9ae:	82 e5       	ldi	r24, 0x52	; 82
     9b0:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('o');
     9b4:	8f e6       	ldi	r24, 0x6F	; 111
     9b6:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('o');
     9ba:	8f e6       	ldi	r24, 0x6F	; 111
     9bc:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('m');
     9c0:	8d e6       	ldi	r24, 0x6D	; 109
     9c2:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('s');
     9c6:	83 e7       	ldi	r24, 0x73	; 115
     9c8:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData(':');
     9cc:	8a e3       	ldi	r24, 0x3A	; 58
     9ce:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('1');
     9d2:	81 e3       	ldi	r24, 0x31	; 49
     9d4:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData(' ');
     9d8:	80 e2       	ldi	r24, 0x20	; 32
     9da:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('2');
     9de:	82 e3       	ldi	r24, 0x32	; 50
     9e0:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData(' ');
     9e4:	80 e2       	ldi	r24, 0x20	; 32
     9e6:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	LCD_vsendData('3');
     9ea:	83 e3       	ldi	r24, 0x33	; 51
     9ec:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_vsendData>
	
	
	
     9f0:	08 95       	ret

000009f2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     9f2:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9f4:	03 96       	adiw	r24, 0x03	; 3
     9f6:	92 83       	std	Z+2, r25	; 0x02
     9f8:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     9fa:	2f ef       	ldi	r18, 0xFF	; 255
     9fc:	3f ef       	ldi	r19, 0xFF	; 255
     9fe:	34 83       	std	Z+4, r19	; 0x04
     a00:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a02:	96 83       	std	Z+6, r25	; 0x06
     a04:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a06:	90 87       	std	Z+8, r25	; 0x08
     a08:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     a0a:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     a0c:	08 95       	ret

00000a0e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     a0e:	fc 01       	movw	r30, r24
     a10:	11 86       	std	Z+9, r1	; 0x09
     a12:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     a14:	08 95       	ret

00000a16 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     a16:	cf 93       	push	r28
     a18:	df 93       	push	r29
     a1a:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     a1c:	dc 01       	movw	r26, r24
     a1e:	11 96       	adiw	r26, 0x01	; 1
     a20:	cd 91       	ld	r28, X+
     a22:	dc 91       	ld	r29, X
     a24:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     a26:	d3 83       	std	Z+3, r29	; 0x03
     a28:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     a2a:	2c 81       	ldd	r18, Y+4	; 0x04
     a2c:	3d 81       	ldd	r19, Y+5	; 0x05
     a2e:	35 83       	std	Z+5, r19	; 0x05
     a30:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     a32:	ac 81       	ldd	r26, Y+4	; 0x04
     a34:	bd 81       	ldd	r27, Y+5	; 0x05
     a36:	13 96       	adiw	r26, 0x03	; 3
     a38:	7c 93       	st	X, r23
     a3a:	6e 93       	st	-X, r22
     a3c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     a3e:	7d 83       	std	Y+5, r23	; 0x05
     a40:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a42:	91 87       	std	Z+9, r25	; 0x09
     a44:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     a46:	fc 01       	movw	r30, r24
     a48:	20 81       	ld	r18, Z
     a4a:	2f 5f       	subi	r18, 0xFF	; 255
     a4c:	20 83       	st	Z, r18
}
     a4e:	df 91       	pop	r29
     a50:	cf 91       	pop	r28
     a52:	08 95       	ret

00000a54 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     a54:	cf 93       	push	r28
     a56:	df 93       	push	r29
     a58:	ac 01       	movw	r20, r24
     a5a:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     a5c:	28 81       	ld	r18, Y
     a5e:	39 81       	ldd	r19, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     a60:	8f ef       	ldi	r24, 0xFF	; 255
     a62:	2f 3f       	cpi	r18, 0xFF	; 255
     a64:	38 07       	cpc	r19, r24
     a66:	21 f4       	brne	.+8      	; 0xa70 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     a68:	fa 01       	movw	r30, r20
     a6a:	a7 81       	ldd	r26, Z+7	; 0x07
     a6c:	b0 85       	ldd	r27, Z+8	; 0x08
     a6e:	0d c0       	rjmp	.+26     	; 0xa8a <vListInsert+0x36>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a70:	da 01       	movw	r26, r20
     a72:	13 96       	adiw	r26, 0x03	; 3
     a74:	01 c0       	rjmp	.+2      	; 0xa78 <vListInsert+0x24>
     a76:	df 01       	movw	r26, r30
     a78:	12 96       	adiw	r26, 0x02	; 2
     a7a:	ed 91       	ld	r30, X+
     a7c:	fc 91       	ld	r31, X
     a7e:	13 97       	sbiw	r26, 0x03	; 3
     a80:	80 81       	ld	r24, Z
     a82:	91 81       	ldd	r25, Z+1	; 0x01
     a84:	28 17       	cp	r18, r24
     a86:	39 07       	cpc	r19, r25
     a88:	b0 f7       	brcc	.-20     	; 0xa76 <vListInsert+0x22>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     a8a:	12 96       	adiw	r26, 0x02	; 2
     a8c:	ed 91       	ld	r30, X+
     a8e:	fc 91       	ld	r31, X
     a90:	13 97       	sbiw	r26, 0x03	; 3
     a92:	fb 83       	std	Y+3, r31	; 0x03
     a94:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     a96:	d5 83       	std	Z+5, r29	; 0x05
     a98:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     a9a:	bd 83       	std	Y+5, r27	; 0x05
     a9c:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     a9e:	13 96       	adiw	r26, 0x03	; 3
     aa0:	dc 93       	st	X, r29
     aa2:	ce 93       	st	-X, r28
     aa4:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     aa6:	59 87       	std	Y+9, r21	; 0x09
     aa8:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     aaa:	fa 01       	movw	r30, r20
     aac:	80 81       	ld	r24, Z
     aae:	8f 5f       	subi	r24, 0xFF	; 255
     ab0:	80 83       	st	Z, r24
}
     ab2:	df 91       	pop	r29
     ab4:	cf 91       	pop	r28
     ab6:	08 95       	ret

00000ab8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     ab8:	cf 93       	push	r28
     aba:	df 93       	push	r29
     abc:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     abe:	c0 85       	ldd	r28, Z+8	; 0x08
     ac0:	d1 85       	ldd	r29, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     ac2:	a2 81       	ldd	r26, Z+2	; 0x02
     ac4:	b3 81       	ldd	r27, Z+3	; 0x03
     ac6:	84 81       	ldd	r24, Z+4	; 0x04
     ac8:	95 81       	ldd	r25, Z+5	; 0x05
     aca:	15 96       	adiw	r26, 0x05	; 5
     acc:	9c 93       	st	X, r25
     ace:	8e 93       	st	-X, r24
     ad0:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     ad2:	a4 81       	ldd	r26, Z+4	; 0x04
     ad4:	b5 81       	ldd	r27, Z+5	; 0x05
     ad6:	82 81       	ldd	r24, Z+2	; 0x02
     ad8:	93 81       	ldd	r25, Z+3	; 0x03
     ada:	13 96       	adiw	r26, 0x03	; 3
     adc:	9c 93       	st	X, r25
     ade:	8e 93       	st	-X, r24
     ae0:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     ae2:	a9 81       	ldd	r26, Y+1	; 0x01
     ae4:	ba 81       	ldd	r27, Y+2	; 0x02
     ae6:	ae 17       	cp	r26, r30
     ae8:	bf 07       	cpc	r27, r31
     aea:	31 f4       	brne	.+12     	; 0xaf8 <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     aec:	14 96       	adiw	r26, 0x04	; 4
     aee:	8d 91       	ld	r24, X+
     af0:	9c 91       	ld	r25, X
     af2:	15 97       	sbiw	r26, 0x05	; 5
     af4:	9a 83       	std	Y+2, r25	; 0x02
     af6:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     af8:	11 86       	std	Z+9, r1	; 0x09
     afa:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     afc:	88 81       	ld	r24, Y
     afe:	81 50       	subi	r24, 0x01	; 1
     b00:	88 83       	st	Y, r24

	return pxList->uxNumberOfItems;
}
     b02:	df 91       	pop	r29
     b04:	cf 91       	pop	r28
     b06:	08 95       	ret

00000b08 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     b08:	21 e1       	ldi	r18, 0x11	; 17
     b0a:	fc 01       	movw	r30, r24
     b0c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     b0e:	31 97       	sbiw	r30, 0x01	; 1
     b10:	32 e2       	ldi	r19, 0x22	; 34
     b12:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     b14:	fc 01       	movw	r30, r24
     b16:	32 97       	sbiw	r30, 0x02	; 2
     b18:	a3 e3       	ldi	r26, 0x33	; 51
     b1a:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     b1c:	fc 01       	movw	r30, r24
     b1e:	33 97       	sbiw	r30, 0x03	; 3
     b20:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     b22:	fc 01       	movw	r30, r24
     b24:	34 97       	sbiw	r30, 0x04	; 4
     b26:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     b28:	fc 01       	movw	r30, r24
     b2a:	35 97       	sbiw	r30, 0x05	; 5
     b2c:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     b2e:	fc 01       	movw	r30, r24
     b30:	36 97       	sbiw	r30, 0x06	; 6
     b32:	60 e8       	ldi	r22, 0x80	; 128
     b34:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     b36:	fc 01       	movw	r30, r24
     b38:	37 97       	sbiw	r30, 0x07	; 7
     b3a:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     b3c:	fc 01       	movw	r30, r24
     b3e:	38 97       	sbiw	r30, 0x08	; 8
     b40:	62 e0       	ldi	r22, 0x02	; 2
     b42:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     b44:	fc 01       	movw	r30, r24
     b46:	39 97       	sbiw	r30, 0x09	; 9
     b48:	63 e0       	ldi	r22, 0x03	; 3
     b4a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     b4c:	fc 01       	movw	r30, r24
     b4e:	3a 97       	sbiw	r30, 0x0a	; 10
     b50:	64 e0       	ldi	r22, 0x04	; 4
     b52:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     b54:	fc 01       	movw	r30, r24
     b56:	3b 97       	sbiw	r30, 0x0b	; 11
     b58:	65 e0       	ldi	r22, 0x05	; 5
     b5a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     b5c:	fc 01       	movw	r30, r24
     b5e:	3c 97       	sbiw	r30, 0x0c	; 12
     b60:	66 e0       	ldi	r22, 0x06	; 6
     b62:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     b64:	fc 01       	movw	r30, r24
     b66:	3d 97       	sbiw	r30, 0x0d	; 13
     b68:	67 e0       	ldi	r22, 0x07	; 7
     b6a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     b6c:	fc 01       	movw	r30, r24
     b6e:	3e 97       	sbiw	r30, 0x0e	; 14
     b70:	68 e0       	ldi	r22, 0x08	; 8
     b72:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     b74:	fc 01       	movw	r30, r24
     b76:	3f 97       	sbiw	r30, 0x0f	; 15
     b78:	69 e0       	ldi	r22, 0x09	; 9
     b7a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     b7c:	fc 01       	movw	r30, r24
     b7e:	70 97       	sbiw	r30, 0x10	; 16
     b80:	60 e1       	ldi	r22, 0x10	; 16
     b82:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     b84:	fc 01       	movw	r30, r24
     b86:	71 97       	sbiw	r30, 0x11	; 17
     b88:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     b8a:	fc 01       	movw	r30, r24
     b8c:	72 97       	sbiw	r30, 0x12	; 18
     b8e:	22 e1       	ldi	r18, 0x12	; 18
     b90:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     b92:	fc 01       	movw	r30, r24
     b94:	73 97       	sbiw	r30, 0x13	; 19
     b96:	23 e1       	ldi	r18, 0x13	; 19
     b98:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     b9a:	fc 01       	movw	r30, r24
     b9c:	74 97       	sbiw	r30, 0x14	; 20
     b9e:	24 e1       	ldi	r18, 0x14	; 20
     ba0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     ba2:	fc 01       	movw	r30, r24
     ba4:	75 97       	sbiw	r30, 0x15	; 21
     ba6:	25 e1       	ldi	r18, 0x15	; 21
     ba8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     baa:	fc 01       	movw	r30, r24
     bac:	76 97       	sbiw	r30, 0x16	; 22
     bae:	26 e1       	ldi	r18, 0x16	; 22
     bb0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     bb2:	fc 01       	movw	r30, r24
     bb4:	77 97       	sbiw	r30, 0x17	; 23
     bb6:	27 e1       	ldi	r18, 0x17	; 23
     bb8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     bba:	fc 01       	movw	r30, r24
     bbc:	78 97       	sbiw	r30, 0x18	; 24
     bbe:	28 e1       	ldi	r18, 0x18	; 24
     bc0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     bc2:	fc 01       	movw	r30, r24
     bc4:	79 97       	sbiw	r30, 0x19	; 25
     bc6:	29 e1       	ldi	r18, 0x19	; 25
     bc8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     bca:	fc 01       	movw	r30, r24
     bcc:	7a 97       	sbiw	r30, 0x1a	; 26
     bce:	20 e2       	ldi	r18, 0x20	; 32
     bd0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     bd2:	fc 01       	movw	r30, r24
     bd4:	7b 97       	sbiw	r30, 0x1b	; 27
     bd6:	21 e2       	ldi	r18, 0x21	; 33
     bd8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     bda:	fc 01       	movw	r30, r24
     bdc:	7c 97       	sbiw	r30, 0x1c	; 28
     bde:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     be0:	fc 01       	movw	r30, r24
     be2:	7d 97       	sbiw	r30, 0x1d	; 29
     be4:	23 e2       	ldi	r18, 0x23	; 35
     be6:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     be8:	fc 01       	movw	r30, r24
     bea:	7e 97       	sbiw	r30, 0x1e	; 30
     bec:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     bee:	fc 01       	movw	r30, r24
     bf0:	7f 97       	sbiw	r30, 0x1f	; 31
     bf2:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     bf4:	fc 01       	movw	r30, r24
     bf6:	b0 97       	sbiw	r30, 0x20	; 32
     bf8:	26 e2       	ldi	r18, 0x26	; 38
     bfa:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     bfc:	fc 01       	movw	r30, r24
     bfe:	b1 97       	sbiw	r30, 0x21	; 33
     c00:	27 e2       	ldi	r18, 0x27	; 39
     c02:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     c04:	fc 01       	movw	r30, r24
     c06:	b2 97       	sbiw	r30, 0x22	; 34
     c08:	28 e2       	ldi	r18, 0x28	; 40
     c0a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     c0c:	fc 01       	movw	r30, r24
     c0e:	b3 97       	sbiw	r30, 0x23	; 35
     c10:	29 e2       	ldi	r18, 0x29	; 41
     c12:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     c14:	fc 01       	movw	r30, r24
     c16:	b4 97       	sbiw	r30, 0x24	; 36
     c18:	20 e3       	ldi	r18, 0x30	; 48
     c1a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     c1c:	fc 01       	movw	r30, r24
     c1e:	b5 97       	sbiw	r30, 0x25	; 37
     c20:	21 e3       	ldi	r18, 0x31	; 49
     c22:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     c24:	86 97       	sbiw	r24, 0x26	; 38
}
     c26:	08 95       	ret

00000c28 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     c28:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
     c2a:	8c e7       	ldi	r24, 0x7C	; 124
     c2c:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     c2e:	8b e0       	ldi	r24, 0x0B	; 11
     c30:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     c32:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     c34:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     c36:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     c38:	a0 91 ab 03 	lds	r26, 0x03AB
     c3c:	b0 91 ac 03 	lds	r27, 0x03AC
     c40:	cd 91       	ld	r28, X+
     c42:	cd bf       	out	0x3d, r28	; 61
     c44:	dd 91       	ld	r29, X+
     c46:	de bf       	out	0x3e, r29	; 62
     c48:	ff 91       	pop	r31
     c4a:	ef 91       	pop	r30
     c4c:	df 91       	pop	r29
     c4e:	cf 91       	pop	r28
     c50:	bf 91       	pop	r27
     c52:	af 91       	pop	r26
     c54:	9f 91       	pop	r25
     c56:	8f 91       	pop	r24
     c58:	7f 91       	pop	r23
     c5a:	6f 91       	pop	r22
     c5c:	5f 91       	pop	r21
     c5e:	4f 91       	pop	r20
     c60:	3f 91       	pop	r19
     c62:	2f 91       	pop	r18
     c64:	1f 91       	pop	r17
     c66:	0f 91       	pop	r16
     c68:	ff 90       	pop	r15
     c6a:	ef 90       	pop	r14
     c6c:	df 90       	pop	r13
     c6e:	cf 90       	pop	r12
     c70:	bf 90       	pop	r11
     c72:	af 90       	pop	r10
     c74:	9f 90       	pop	r9
     c76:	8f 90       	pop	r8
     c78:	7f 90       	pop	r7
     c7a:	6f 90       	pop	r6
     c7c:	5f 90       	pop	r5
     c7e:	4f 90       	pop	r4
     c80:	3f 90       	pop	r3
     c82:	2f 90       	pop	r2
     c84:	1f 90       	pop	r1
     c86:	0f 90       	pop	r0
     c88:	0f be       	out	0x3f, r0	; 63
     c8a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     c8c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     c8e:	81 e0       	ldi	r24, 0x01	; 1
     c90:	08 95       	ret

00000c92 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     c92:	08 95       	ret

00000c94 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     c94:	0f 92       	push	r0
     c96:	0f b6       	in	r0, 0x3f	; 63
     c98:	f8 94       	cli
     c9a:	0f 92       	push	r0
     c9c:	1f 92       	push	r1
     c9e:	11 24       	eor	r1, r1
     ca0:	2f 92       	push	r2
     ca2:	3f 92       	push	r3
     ca4:	4f 92       	push	r4
     ca6:	5f 92       	push	r5
     ca8:	6f 92       	push	r6
     caa:	7f 92       	push	r7
     cac:	8f 92       	push	r8
     cae:	9f 92       	push	r9
     cb0:	af 92       	push	r10
     cb2:	bf 92       	push	r11
     cb4:	cf 92       	push	r12
     cb6:	df 92       	push	r13
     cb8:	ef 92       	push	r14
     cba:	ff 92       	push	r15
     cbc:	0f 93       	push	r16
     cbe:	1f 93       	push	r17
     cc0:	2f 93       	push	r18
     cc2:	3f 93       	push	r19
     cc4:	4f 93       	push	r20
     cc6:	5f 93       	push	r21
     cc8:	6f 93       	push	r22
     cca:	7f 93       	push	r23
     ccc:	8f 93       	push	r24
     cce:	9f 93       	push	r25
     cd0:	af 93       	push	r26
     cd2:	bf 93       	push	r27
     cd4:	cf 93       	push	r28
     cd6:	df 93       	push	r29
     cd8:	ef 93       	push	r30
     cda:	ff 93       	push	r31
     cdc:	a0 91 ab 03 	lds	r26, 0x03AB
     ce0:	b0 91 ac 03 	lds	r27, 0x03AC
     ce4:	0d b6       	in	r0, 0x3d	; 61
     ce6:	0d 92       	st	X+, r0
     ce8:	0e b6       	in	r0, 0x3e	; 62
     cea:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     cec:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     cf0:	a0 91 ab 03 	lds	r26, 0x03AB
     cf4:	b0 91 ac 03 	lds	r27, 0x03AC
     cf8:	cd 91       	ld	r28, X+
     cfa:	cd bf       	out	0x3d, r28	; 61
     cfc:	dd 91       	ld	r29, X+
     cfe:	de bf       	out	0x3e, r29	; 62
     d00:	ff 91       	pop	r31
     d02:	ef 91       	pop	r30
     d04:	df 91       	pop	r29
     d06:	cf 91       	pop	r28
     d08:	bf 91       	pop	r27
     d0a:	af 91       	pop	r26
     d0c:	9f 91       	pop	r25
     d0e:	8f 91       	pop	r24
     d10:	7f 91       	pop	r23
     d12:	6f 91       	pop	r22
     d14:	5f 91       	pop	r21
     d16:	4f 91       	pop	r20
     d18:	3f 91       	pop	r19
     d1a:	2f 91       	pop	r18
     d1c:	1f 91       	pop	r17
     d1e:	0f 91       	pop	r16
     d20:	ff 90       	pop	r15
     d22:	ef 90       	pop	r14
     d24:	df 90       	pop	r13
     d26:	cf 90       	pop	r12
     d28:	bf 90       	pop	r11
     d2a:	af 90       	pop	r10
     d2c:	9f 90       	pop	r9
     d2e:	8f 90       	pop	r8
     d30:	7f 90       	pop	r7
     d32:	6f 90       	pop	r6
     d34:	5f 90       	pop	r5
     d36:	4f 90       	pop	r4
     d38:	3f 90       	pop	r3
     d3a:	2f 90       	pop	r2
     d3c:	1f 90       	pop	r1
     d3e:	0f 90       	pop	r0
     d40:	0f be       	out	0x3f, r0	; 63
     d42:	0f 90       	pop	r0

	asm volatile ( "ret" );
     d44:	08 95       	ret

00000d46 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     d46:	0f 92       	push	r0
     d48:	0f b6       	in	r0, 0x3f	; 63
     d4a:	f8 94       	cli
     d4c:	0f 92       	push	r0
     d4e:	1f 92       	push	r1
     d50:	11 24       	eor	r1, r1
     d52:	2f 92       	push	r2
     d54:	3f 92       	push	r3
     d56:	4f 92       	push	r4
     d58:	5f 92       	push	r5
     d5a:	6f 92       	push	r6
     d5c:	7f 92       	push	r7
     d5e:	8f 92       	push	r8
     d60:	9f 92       	push	r9
     d62:	af 92       	push	r10
     d64:	bf 92       	push	r11
     d66:	cf 92       	push	r12
     d68:	df 92       	push	r13
     d6a:	ef 92       	push	r14
     d6c:	ff 92       	push	r15
     d6e:	0f 93       	push	r16
     d70:	1f 93       	push	r17
     d72:	2f 93       	push	r18
     d74:	3f 93       	push	r19
     d76:	4f 93       	push	r20
     d78:	5f 93       	push	r21
     d7a:	6f 93       	push	r22
     d7c:	7f 93       	push	r23
     d7e:	8f 93       	push	r24
     d80:	9f 93       	push	r25
     d82:	af 93       	push	r26
     d84:	bf 93       	push	r27
     d86:	cf 93       	push	r28
     d88:	df 93       	push	r29
     d8a:	ef 93       	push	r30
     d8c:	ff 93       	push	r31
     d8e:	a0 91 ab 03 	lds	r26, 0x03AB
     d92:	b0 91 ac 03 	lds	r27, 0x03AC
     d96:	0d b6       	in	r0, 0x3d	; 61
     d98:	0d 92       	st	X+, r0
     d9a:	0e b6       	in	r0, 0x3e	; 62
     d9c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     d9e:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <xTaskIncrementTick>
     da2:	88 23       	and	r24, r24
     da4:	11 f0       	breq	.+4      	; 0xdaa <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     da6:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     daa:	a0 91 ab 03 	lds	r26, 0x03AB
     dae:	b0 91 ac 03 	lds	r27, 0x03AC
     db2:	cd 91       	ld	r28, X+
     db4:	cd bf       	out	0x3d, r28	; 61
     db6:	dd 91       	ld	r29, X+
     db8:	de bf       	out	0x3e, r29	; 62
     dba:	ff 91       	pop	r31
     dbc:	ef 91       	pop	r30
     dbe:	df 91       	pop	r29
     dc0:	cf 91       	pop	r28
     dc2:	bf 91       	pop	r27
     dc4:	af 91       	pop	r26
     dc6:	9f 91       	pop	r25
     dc8:	8f 91       	pop	r24
     dca:	7f 91       	pop	r23
     dcc:	6f 91       	pop	r22
     dce:	5f 91       	pop	r21
     dd0:	4f 91       	pop	r20
     dd2:	3f 91       	pop	r19
     dd4:	2f 91       	pop	r18
     dd6:	1f 91       	pop	r17
     dd8:	0f 91       	pop	r16
     dda:	ff 90       	pop	r15
     ddc:	ef 90       	pop	r14
     dde:	df 90       	pop	r13
     de0:	cf 90       	pop	r12
     de2:	bf 90       	pop	r11
     de4:	af 90       	pop	r10
     de6:	9f 90       	pop	r9
     de8:	8f 90       	pop	r8
     dea:	7f 90       	pop	r7
     dec:	6f 90       	pop	r6
     dee:	5f 90       	pop	r5
     df0:	4f 90       	pop	r4
     df2:	3f 90       	pop	r3
     df4:	2f 90       	pop	r2
     df6:	1f 90       	pop	r1
     df8:	0f 90       	pop	r0
     dfa:	0f be       	out	0x3f, r0	; 63
     dfc:	0f 90       	pop	r0

	asm volatile ( "ret" );
     dfe:	08 95       	ret

00000e00 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     e00:	0e 94 a3 06 	call	0xd46	; 0xd46 <vPortYieldFromTick>
		asm volatile ( "reti" );
     e04:	18 95       	reti

00000e06 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     e06:	0f b6       	in	r0, 0x3f	; 63
     e08:	f8 94       	cli
     e0a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     e0c:	fc 01       	movw	r30, r24
     e0e:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     e10:	0f 90       	pop	r0
     e12:	0f be       	out	0x3f, r0	; 63

	taskENTER_CRITICAL();
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
		{
			xReturn = pdTRUE;
     e14:	81 e0       	ldi	r24, 0x01	; 1
     e16:	91 11       	cpse	r25, r1
     e18:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}
     e1a:	08 95       	ret

00000e1c <prvCopyDataFromQueue>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     e1c:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     e1e:	44 8d       	ldd	r20, Z+28	; 0x1c
     e20:	44 23       	and	r20, r20
     e22:	c1 f0       	breq	.+48     	; 0xe54 <prvCopyDataFromQueue+0x38>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     e24:	26 81       	ldd	r18, Z+6	; 0x06
     e26:	37 81       	ldd	r19, Z+7	; 0x07
     e28:	24 0f       	add	r18, r20
     e2a:	31 1d       	adc	r19, r1
     e2c:	37 83       	std	Z+7, r19	; 0x07
     e2e:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     e30:	a2 81       	ldd	r26, Z+2	; 0x02
     e32:	b3 81       	ldd	r27, Z+3	; 0x03
     e34:	2a 17       	cp	r18, r26
     e36:	3b 07       	cpc	r19, r27
     e38:	20 f0       	brcs	.+8      	; 0xe42 <prvCopyDataFromQueue+0x26>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     e3a:	20 81       	ld	r18, Z
     e3c:	31 81       	ldd	r19, Z+1	; 0x01
     e3e:	37 83       	std	Z+7, r19	; 0x07
     e40:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     e42:	36 81       	ldd	r19, Z+6	; 0x06
     e44:	27 81       	ldd	r18, Z+7	; 0x07
     e46:	86 2f       	mov	r24, r22
     e48:	97 2f       	mov	r25, r23
     e4a:	63 2f       	mov	r22, r19
     e4c:	72 2f       	mov	r23, r18
     e4e:	50 e0       	ldi	r21, 0x00	; 0
     e50:	0e 94 af 15 	call	0x2b5e	; 0x2b5e <memcpy>
     e54:	08 95       	ret

00000e56 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     e56:	ef 92       	push	r14
     e58:	ff 92       	push	r15
     e5a:	0f 93       	push	r16
     e5c:	1f 93       	push	r17
     e5e:	cf 93       	push	r28
     e60:	8c 01       	movw	r16, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     e62:	0f b6       	in	r0, 0x3f	; 63
     e64:	f8 94       	cli
     e66:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
     e68:	fc 01       	movw	r30, r24
     e6a:	c6 8d       	ldd	r28, Z+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     e6c:	1c 16       	cp	r1, r28
     e6e:	cc f4       	brge	.+50     	; 0xea2 <prvUnlockQueue+0x4c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e70:	81 89       	ldd	r24, Z+17	; 0x11
     e72:	88 23       	and	r24, r24
     e74:	31 f4       	brne	.+12     	; 0xe82 <prvUnlockQueue+0x2c>
     e76:	15 c0       	rjmp	.+42     	; 0xea2 <prvUnlockQueue+0x4c>
     e78:	f8 01       	movw	r30, r16
     e7a:	81 89       	ldd	r24, Z+17	; 0x11
     e7c:	88 23       	and	r24, r24
     e7e:	41 f4       	brne	.+16     	; 0xe90 <prvUnlockQueue+0x3a>
     e80:	10 c0       	rjmp	.+32     	; 0xea2 <prvUnlockQueue+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e82:	0f 2e       	mov	r0, r31
     e84:	f1 e1       	ldi	r31, 0x11	; 17
     e86:	ef 2e       	mov	r14, r31
     e88:	ff 24       	eor	r15, r15
     e8a:	f0 2d       	mov	r31, r0
     e8c:	e0 0e       	add	r14, r16
     e8e:	f1 1e       	adc	r15, r17
     e90:	c7 01       	movw	r24, r14
     e92:	0e 94 ae 11 	call	0x235c	; 0x235c <xTaskRemoveFromEventList>
     e96:	88 23       	and	r24, r24
     e98:	11 f0       	breq	.+4      	; 0xe9e <prvUnlockQueue+0x48>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
     e9a:	0e 94 73 12 	call	0x24e6	; 0x24e6 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
     e9e:	c1 50       	subi	r28, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     ea0:	59 f7       	brne	.-42     	; 0xe78 <prvUnlockQueue+0x22>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
     ea2:	8f ef       	ldi	r24, 0xFF	; 255
     ea4:	f8 01       	movw	r30, r16
     ea6:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     ea8:	0f 90       	pop	r0
     eaa:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     eac:	0f b6       	in	r0, 0x3f	; 63
     eae:	f8 94       	cli
     eb0:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
     eb2:	f8 01       	movw	r30, r16
     eb4:	c5 8d       	ldd	r28, Z+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
     eb6:	1c 16       	cp	r1, r28
     eb8:	c4 f4       	brge	.+48     	; 0xeea <prvUnlockQueue+0x94>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     eba:	80 85       	ldd	r24, Z+8	; 0x08
     ebc:	88 23       	and	r24, r24
     ebe:	31 f4       	brne	.+12     	; 0xecc <prvUnlockQueue+0x76>
     ec0:	14 c0       	rjmp	.+40     	; 0xeea <prvUnlockQueue+0x94>
     ec2:	f8 01       	movw	r30, r16
     ec4:	80 85       	ldd	r24, Z+8	; 0x08
     ec6:	88 23       	and	r24, r24
     ec8:	39 f4       	brne	.+14     	; 0xed8 <prvUnlockQueue+0x82>
     eca:	0f c0       	rjmp	.+30     	; 0xeea <prvUnlockQueue+0x94>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ecc:	ee 24       	eor	r14, r14
     ece:	ff 24       	eor	r15, r15
     ed0:	68 94       	set
     ed2:	e3 f8       	bld	r14, 3
     ed4:	e0 0e       	add	r14, r16
     ed6:	f1 1e       	adc	r15, r17
     ed8:	c7 01       	movw	r24, r14
     eda:	0e 94 ae 11 	call	0x235c	; 0x235c <xTaskRemoveFromEventList>
     ede:	88 23       	and	r24, r24
     ee0:	11 f0       	breq	.+4      	; 0xee6 <prvUnlockQueue+0x90>
				{
					vTaskMissedYield();
     ee2:	0e 94 73 12 	call	0x24e6	; 0x24e6 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
     ee6:	c1 50       	subi	r28, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
     ee8:	61 f7       	brne	.-40     	; 0xec2 <prvUnlockQueue+0x6c>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
     eea:	8f ef       	ldi	r24, 0xFF	; 255
     eec:	f8 01       	movw	r30, r16
     eee:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     ef0:	0f 90       	pop	r0
     ef2:	0f be       	out	0x3f, r0	; 63
}
     ef4:	cf 91       	pop	r28
     ef6:	1f 91       	pop	r17
     ef8:	0f 91       	pop	r16
     efa:	ff 90       	pop	r15
     efc:	ef 90       	pop	r14
     efe:	08 95       	ret

00000f00 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     f00:	0f 93       	push	r16
     f02:	1f 93       	push	r17
     f04:	cf 93       	push	r28
     f06:	df 93       	push	r29
     f08:	ec 01       	movw	r28, r24
     f0a:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     f0c:	0a 8d       	ldd	r16, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     f0e:	4c 8d       	ldd	r20, Y+28	; 0x1c
     f10:	44 23       	and	r20, r20
     f12:	61 f4       	brne	.+24     	; 0xf2c <prvCopyDataToQueue+0x2c>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     f14:	88 81       	ld	r24, Y
     f16:	99 81       	ldd	r25, Y+1	; 0x01
     f18:	00 97       	sbiw	r24, 0x00	; 0
     f1a:	09 f0       	breq	.+2      	; 0xf1e <prvCopyDataToQueue+0x1e>
     f1c:	42 c0       	rjmp	.+132    	; 0xfa2 <prvCopyDataToQueue+0xa2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     f1e:	8a 81       	ldd	r24, Y+2	; 0x02
     f20:	9b 81       	ldd	r25, Y+3	; 0x03
     f22:	0e 94 da 12 	call	0x25b4	; 0x25b4 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     f26:	1b 82       	std	Y+3, r1	; 0x03
     f28:	1a 82       	std	Y+2, r1	; 0x02
     f2a:	42 c0       	rjmp	.+132    	; 0xfb0 <prvCopyDataToQueue+0xb0>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     f2c:	11 23       	and	r17, r17
     f2e:	b9 f4       	brne	.+46     	; 0xf5e <prvCopyDataToQueue+0x5e>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     f30:	8c 81       	ldd	r24, Y+4	; 0x04
     f32:	9d 81       	ldd	r25, Y+5	; 0x05
     f34:	50 e0       	ldi	r21, 0x00	; 0
     f36:	0e 94 af 15 	call	0x2b5e	; 0x2b5e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     f3a:	2c 8d       	ldd	r18, Y+28	; 0x1c
     f3c:	8c 81       	ldd	r24, Y+4	; 0x04
     f3e:	9d 81       	ldd	r25, Y+5	; 0x05
     f40:	82 0f       	add	r24, r18
     f42:	91 1d       	adc	r25, r1
     f44:	9d 83       	std	Y+5, r25	; 0x05
     f46:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     f48:	2a 81       	ldd	r18, Y+2	; 0x02
     f4a:	3b 81       	ldd	r19, Y+3	; 0x03
     f4c:	82 17       	cp	r24, r18
     f4e:	93 07       	cpc	r25, r19
     f50:	50 f1       	brcs	.+84     	; 0xfa6 <prvCopyDataToQueue+0xa6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     f52:	88 81       	ld	r24, Y
     f54:	99 81       	ldd	r25, Y+1	; 0x01
     f56:	9d 83       	std	Y+5, r25	; 0x05
     f58:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     f5a:	80 e0       	ldi	r24, 0x00	; 0
     f5c:	29 c0       	rjmp	.+82     	; 0xfb0 <prvCopyDataToQueue+0xb0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     f5e:	8e 81       	ldd	r24, Y+6	; 0x06
     f60:	9f 81       	ldd	r25, Y+7	; 0x07
     f62:	50 e0       	ldi	r21, 0x00	; 0
     f64:	0e 94 af 15 	call	0x2b5e	; 0x2b5e <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     f68:	4c 8d       	ldd	r20, Y+28	; 0x1c
     f6a:	50 e0       	ldi	r21, 0x00	; 0
     f6c:	50 95       	com	r21
     f6e:	41 95       	neg	r20
     f70:	5f 4f       	sbci	r21, 0xFF	; 255
     f72:	8e 81       	ldd	r24, Y+6	; 0x06
     f74:	9f 81       	ldd	r25, Y+7	; 0x07
     f76:	84 0f       	add	r24, r20
     f78:	95 1f       	adc	r25, r21
     f7a:	9f 83       	std	Y+7, r25	; 0x07
     f7c:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     f7e:	28 81       	ld	r18, Y
     f80:	39 81       	ldd	r19, Y+1	; 0x01
     f82:	82 17       	cp	r24, r18
     f84:	93 07       	cpc	r25, r19
     f86:	30 f4       	brcc	.+12     	; 0xf94 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     f88:	8a 81       	ldd	r24, Y+2	; 0x02
     f8a:	9b 81       	ldd	r25, Y+3	; 0x03
     f8c:	84 0f       	add	r24, r20
     f8e:	95 1f       	adc	r25, r21
     f90:	9f 83       	std	Y+7, r25	; 0x07
     f92:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     f94:	12 30       	cpi	r17, 0x02	; 2
     f96:	49 f4       	brne	.+18     	; 0xfaa <prvCopyDataToQueue+0xaa>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     f98:	00 23       	and	r16, r16
     f9a:	49 f0       	breq	.+18     	; 0xfae <prvCopyDataToQueue+0xae>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
     f9c:	01 50       	subi	r16, 0x01	; 1
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     f9e:	80 e0       	ldi	r24, 0x00	; 0
     fa0:	07 c0       	rjmp	.+14     	; 0xfb0 <prvCopyDataToQueue+0xb0>
     fa2:	80 e0       	ldi	r24, 0x00	; 0
     fa4:	05 c0       	rjmp	.+10     	; 0xfb0 <prvCopyDataToQueue+0xb0>
     fa6:	80 e0       	ldi	r24, 0x00	; 0
     fa8:	03 c0       	rjmp	.+6      	; 0xfb0 <prvCopyDataToQueue+0xb0>
     faa:	80 e0       	ldi	r24, 0x00	; 0
     fac:	01 c0       	rjmp	.+2      	; 0xfb0 <prvCopyDataToQueue+0xb0>
     fae:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
     fb0:	0f 5f       	subi	r16, 0xFF	; 255
     fb2:	0a 8f       	std	Y+26, r16	; 0x1a

	return xReturn;
}
     fb4:	df 91       	pop	r29
     fb6:	cf 91       	pop	r28
     fb8:	1f 91       	pop	r17
     fba:	0f 91       	pop	r16
     fbc:	08 95       	ret

00000fbe <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     fbe:	cf 93       	push	r28
     fc0:	df 93       	push	r29
     fc2:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     fc4:	0f b6       	in	r0, 0x3f	; 63
     fc6:	f8 94       	cli
     fc8:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     fca:	48 81       	ld	r20, Y
     fcc:	59 81       	ldd	r21, Y+1	; 0x01
     fce:	2b 8d       	ldd	r18, Y+27	; 0x1b
     fd0:	30 e0       	ldi	r19, 0x00	; 0
     fd2:	ec 8d       	ldd	r30, Y+28	; 0x1c
     fd4:	f0 e0       	ldi	r31, 0x00	; 0
     fd6:	2e 9f       	mul	r18, r30
     fd8:	c0 01       	movw	r24, r0
     fda:	2f 9f       	mul	r18, r31
     fdc:	90 0d       	add	r25, r0
     fde:	3e 9f       	mul	r19, r30
     fe0:	90 0d       	add	r25, r0
     fe2:	11 24       	eor	r1, r1
     fe4:	84 0f       	add	r24, r20
     fe6:	95 1f       	adc	r25, r21
     fe8:	9b 83       	std	Y+3, r25	; 0x03
     fea:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     fec:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     fee:	5d 83       	std	Y+5, r21	; 0x05
     ff0:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     ff2:	c9 01       	movw	r24, r18
     ff4:	01 97       	sbiw	r24, 0x01	; 1
     ff6:	e8 9f       	mul	r30, r24
     ff8:	90 01       	movw	r18, r0
     ffa:	e9 9f       	mul	r30, r25
     ffc:	30 0d       	add	r19, r0
     ffe:	f8 9f       	mul	r31, r24
    1000:	30 0d       	add	r19, r0
    1002:	11 24       	eor	r1, r1
    1004:	24 0f       	add	r18, r20
    1006:	35 1f       	adc	r19, r21
    1008:	3f 83       	std	Y+7, r19	; 0x07
    100a:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    100c:	8f ef       	ldi	r24, 0xFF	; 255
    100e:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1010:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1012:	66 23       	and	r22, r22
    1014:	61 f4       	brne	.+24     	; 0x102e <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1016:	88 85       	ldd	r24, Y+8	; 0x08
    1018:	88 23       	and	r24, r24
    101a:	89 f0       	breq	.+34     	; 0x103e <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    101c:	ce 01       	movw	r24, r28
    101e:	08 96       	adiw	r24, 0x08	; 8
    1020:	0e 94 ae 11 	call	0x235c	; 0x235c <xTaskRemoveFromEventList>
    1024:	88 23       	and	r24, r24
    1026:	59 f0       	breq	.+22     	; 0x103e <xQueueGenericReset+0x80>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1028:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>
    102c:	08 c0       	rjmp	.+16     	; 0x103e <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    102e:	ce 01       	movw	r24, r28
    1030:	08 96       	adiw	r24, 0x08	; 8
    1032:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1036:	ce 01       	movw	r24, r28
    1038:	41 96       	adiw	r24, 0x11	; 17
    103a:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    103e:	0f 90       	pop	r0
    1040:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1042:	81 e0       	ldi	r24, 0x01	; 1
    1044:	df 91       	pop	r29
    1046:	cf 91       	pop	r28
    1048:	08 95       	ret

0000104a <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    104a:	0f 93       	push	r16
    104c:	1f 93       	push	r17
    104e:	cf 93       	push	r28
    1050:	df 93       	push	r29
    1052:	08 2f       	mov	r16, r24
    1054:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1056:	66 23       	and	r22, r22
    1058:	21 f0       	breq	.+8      	; 0x1062 <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    105a:	68 9f       	mul	r22, r24
    105c:	c0 01       	movw	r24, r0
    105e:	11 24       	eor	r1, r1
    1060:	02 c0       	rjmp	.+4      	; 0x1066 <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1062:	80 e0       	ldi	r24, 0x00	; 0
    1064:	90 e0       	ldi	r25, 0x00	; 0
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    1066:	4f 96       	adiw	r24, 0x1f	; 31
    1068:	0e 94 24 02 	call	0x448	; 0x448 <pvPortMalloc>
    106c:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    106e:	00 97       	sbiw	r24, 0x00	; 0
    1070:	71 f0       	breq	.+28     	; 0x108e <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1072:	11 23       	and	r17, r17
    1074:	19 f4       	brne	.+6      	; 0x107c <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1076:	99 83       	std	Y+1, r25	; 0x01
    1078:	88 83       	st	Y, r24
    107a:	03 c0       	rjmp	.+6      	; 0x1082 <xQueueGenericCreate+0x38>

		if( pxNewQueue != NULL )
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
    107c:	4f 96       	adiw	r24, 0x1f	; 31
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    107e:	99 83       	std	Y+1, r25	; 0x01
    1080:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1082:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1084:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1086:	ce 01       	movw	r24, r28
    1088:	61 e0       	ldi	r22, 0x01	; 1
    108a:	0e 94 df 07 	call	0xfbe	; 0xfbe <xQueueGenericReset>

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}
    108e:	8c 2f       	mov	r24, r28
    1090:	9d 2f       	mov	r25, r29
    1092:	df 91       	pop	r29
    1094:	cf 91       	pop	r28
    1096:	1f 91       	pop	r17
    1098:	0f 91       	pop	r16
    109a:	08 95       	ret

0000109c <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    109c:	8f 92       	push	r8
    109e:	9f 92       	push	r9
    10a0:	bf 92       	push	r11
    10a2:	cf 92       	push	r12
    10a4:	df 92       	push	r13
    10a6:	ef 92       	push	r14
    10a8:	ff 92       	push	r15
    10aa:	0f 93       	push	r16
    10ac:	1f 93       	push	r17
    10ae:	cf 93       	push	r28
    10b0:	df 93       	push	r29
    10b2:	00 d0       	rcall	.+0      	; 0x10b4 <xQueueGenericSend+0x18>
    10b4:	00 d0       	rcall	.+0      	; 0x10b6 <xQueueGenericSend+0x1a>
    10b6:	0f 92       	push	r0
    10b8:	cd b7       	in	r28, 0x3d	; 61
    10ba:	de b7       	in	r29, 0x3e	; 62
    10bc:	8c 01       	movw	r16, r24
    10be:	4b 01       	movw	r8, r22
    10c0:	5d 83       	std	Y+5, r21	; 0x05
    10c2:	4c 83       	std	Y+4, r20	; 0x04
    10c4:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    10c6:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    10c8:	bb 24       	eor	r11, r11
    10ca:	b3 94       	inc	r11
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    10cc:	cc 24       	eor	r12, r12
    10ce:	dd 24       	eor	r13, r13
    10d0:	68 94       	set
    10d2:	c3 f8       	bld	r12, 3
    10d4:	c8 0e       	add	r12, r24
    10d6:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    10d8:	0f b6       	in	r0, 0x3f	; 63
    10da:	f8 94       	cli
    10dc:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    10de:	f8 01       	movw	r30, r16
    10e0:	92 8d       	ldd	r25, Z+26	; 0x1a
    10e2:	83 8d       	ldd	r24, Z+27	; 0x1b
    10e4:	98 17       	cp	r25, r24
    10e6:	18 f0       	brcs	.+6      	; 0x10ee <xQueueGenericSend+0x52>
    10e8:	f2 e0       	ldi	r31, 0x02	; 2
    10ea:	ef 16       	cp	r14, r31
    10ec:	d1 f4       	brne	.+52     	; 0x1122 <xQueueGenericSend+0x86>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    10ee:	c8 01       	movw	r24, r16
    10f0:	b4 01       	movw	r22, r8
    10f2:	4e 2d       	mov	r20, r14
    10f4:	0e 94 80 07 	call	0xf00	; 0xf00 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10f8:	f8 01       	movw	r30, r16
    10fa:	91 89       	ldd	r25, Z+17	; 0x11
    10fc:	99 23       	and	r25, r25
    10fe:	49 f0       	breq	.+18     	; 0x1112 <xQueueGenericSend+0x76>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1100:	c8 01       	movw	r24, r16
    1102:	41 96       	adiw	r24, 0x11	; 17
    1104:	0e 94 ae 11 	call	0x235c	; 0x235c <xTaskRemoveFromEventList>
    1108:	88 23       	and	r24, r24
    110a:	39 f0       	breq	.+14     	; 0x111a <xQueueGenericSend+0x7e>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    110c:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>
    1110:	04 c0       	rjmp	.+8      	; 0x111a <xQueueGenericSend+0x7e>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1112:	88 23       	and	r24, r24
    1114:	11 f0       	breq	.+4      	; 0x111a <xQueueGenericSend+0x7e>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1116:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    111a:	0f 90       	pop	r0
    111c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    111e:	81 e0       	ldi	r24, 0x01	; 1
    1120:	52 c0       	rjmp	.+164    	; 0x11c6 <xQueueGenericSend+0x12a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1122:	8c 81       	ldd	r24, Y+4	; 0x04
    1124:	9d 81       	ldd	r25, Y+5	; 0x05
    1126:	00 97       	sbiw	r24, 0x00	; 0
    1128:	21 f4       	brne	.+8      	; 0x1132 <xQueueGenericSend+0x96>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    112a:	0f 90       	pop	r0
    112c:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    112e:	80 e0       	ldi	r24, 0x00	; 0
    1130:	4a c0       	rjmp	.+148    	; 0x11c6 <xQueueGenericSend+0x12a>
				}
				else if( xEntryTimeSet == pdFALSE )
    1132:	ff 20       	and	r15, r15
    1134:	29 f4       	brne	.+10     	; 0x1140 <xQueueGenericSend+0xa4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1136:	ce 01       	movw	r24, r28
    1138:	01 96       	adiw	r24, 0x01	; 1
    113a:	0e 94 33 12 	call	0x2466	; 0x2466 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    113e:	fb 2c       	mov	r15, r11
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1140:	0f 90       	pop	r0
    1142:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1144:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1148:	0f b6       	in	r0, 0x3f	; 63
    114a:	f8 94       	cli
    114c:	0f 92       	push	r0
    114e:	f8 01       	movw	r30, r16
    1150:	85 8d       	ldd	r24, Z+29	; 0x1d
    1152:	8f 3f       	cpi	r24, 0xFF	; 255
    1154:	09 f4       	brne	.+2      	; 0x1158 <xQueueGenericSend+0xbc>
    1156:	15 8e       	std	Z+29, r1	; 0x1d
    1158:	f8 01       	movw	r30, r16
    115a:	86 8d       	ldd	r24, Z+30	; 0x1e
    115c:	8f 3f       	cpi	r24, 0xFF	; 255
    115e:	09 f4       	brne	.+2      	; 0x1162 <xQueueGenericSend+0xc6>
    1160:	16 8e       	std	Z+30, r1	; 0x1e
    1162:	0f 90       	pop	r0
    1164:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1166:	ce 01       	movw	r24, r28
    1168:	01 96       	adiw	r24, 0x01	; 1
    116a:	be 01       	movw	r22, r28
    116c:	6c 5f       	subi	r22, 0xFC	; 252
    116e:	7f 4f       	sbci	r23, 0xFF	; 255
    1170:	0e 94 3e 12 	call	0x247c	; 0x247c <xTaskCheckForTimeOut>
    1174:	88 23       	and	r24, r24
    1176:	09 f5       	brne	.+66     	; 0x11ba <xQueueGenericSend+0x11e>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1178:	0f b6       	in	r0, 0x3f	; 63
    117a:	f8 94       	cli
    117c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    117e:	f8 01       	movw	r30, r16
    1180:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1182:	0f 90       	pop	r0
    1184:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1186:	f8 01       	movw	r30, r16
    1188:	83 8d       	ldd	r24, Z+27	; 0x1b
    118a:	98 17       	cp	r25, r24
    118c:	81 f4       	brne	.+32     	; 0x11ae <xQueueGenericSend+0x112>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    118e:	6c 81       	ldd	r22, Y+4	; 0x04
    1190:	7d 81       	ldd	r23, Y+5	; 0x05
    1192:	c6 01       	movw	r24, r12
    1194:	0e 94 83 11 	call	0x2306	; 0x2306 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1198:	c8 01       	movw	r24, r16
    119a:	0e 94 2b 07 	call	0xe56	; 0xe56 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    119e:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <xTaskResumeAll>
    11a2:	88 23       	and	r24, r24
    11a4:	09 f0       	breq	.+2      	; 0x11a8 <xQueueGenericSend+0x10c>
    11a6:	98 cf       	rjmp	.-208    	; 0x10d8 <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
    11a8:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>
    11ac:	95 cf       	rjmp	.-214    	; 0x10d8 <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    11ae:	c8 01       	movw	r24, r16
    11b0:	0e 94 2b 07 	call	0xe56	; 0xe56 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    11b4:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <xTaskResumeAll>
    11b8:	8f cf       	rjmp	.-226    	; 0x10d8 <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    11ba:	c8 01       	movw	r24, r16
    11bc:	0e 94 2b 07 	call	0xe56	; 0xe56 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    11c0:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    11c4:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    11c6:	0f 90       	pop	r0
    11c8:	0f 90       	pop	r0
    11ca:	0f 90       	pop	r0
    11cc:	0f 90       	pop	r0
    11ce:	0f 90       	pop	r0
    11d0:	df 91       	pop	r29
    11d2:	cf 91       	pop	r28
    11d4:	1f 91       	pop	r17
    11d6:	0f 91       	pop	r16
    11d8:	ff 90       	pop	r15
    11da:	ef 90       	pop	r14
    11dc:	df 90       	pop	r13
    11de:	cf 90       	pop	r12
    11e0:	bf 90       	pop	r11
    11e2:	9f 90       	pop	r9
    11e4:	8f 90       	pop	r8
    11e6:	08 95       	ret

000011e8 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    11e8:	cf 93       	push	r28
    11ea:	df 93       	push	r29
    11ec:	48 2f       	mov	r20, r24
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    11ee:	81 e0       	ldi	r24, 0x01	; 1
    11f0:	60 e0       	ldi	r22, 0x00	; 0
    11f2:	0e 94 25 08 	call	0x104a	; 0x104a <xQueueGenericCreate>
    11f6:	ec 01       	movw	r28, r24

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
		if( pxNewQueue != NULL )
    11f8:	00 97       	sbiw	r24, 0x00	; 0
    11fa:	61 f0       	breq	.+24     	; 0x1214 <xQueueCreateMutex+0x2c>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    11fc:	1b 82       	std	Y+3, r1	; 0x03
    11fe:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1200:	19 82       	std	Y+1, r1	; 0x01
    1202:	18 82       	st	Y, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
    1204:	1e 82       	std	Y+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1206:	60 e0       	ldi	r22, 0x00	; 0
    1208:	70 e0       	ldi	r23, 0x00	; 0
    120a:	40 e0       	ldi	r20, 0x00	; 0
    120c:	50 e0       	ldi	r21, 0x00	; 0
    120e:	20 e0       	ldi	r18, 0x00	; 0
    1210:	0e 94 4e 08 	call	0x109c	; 0x109c <xQueueGenericSend>

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
		prvInitialiseMutex( pxNewQueue );

		return pxNewQueue;
	}
    1214:	8c 2f       	mov	r24, r28
    1216:	9d 2f       	mov	r25, r29
    1218:	df 91       	pop	r29
    121a:	cf 91       	pop	r28
    121c:	08 95       	ret

0000121e <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    121e:	ef 92       	push	r14
    1220:	ff 92       	push	r15
    1222:	0f 93       	push	r16
    1224:	1f 93       	push	r17
    1226:	cf 93       	push	r28
    1228:	8c 01       	movw	r16, r24
    122a:	7a 01       	movw	r14, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    122c:	fc 01       	movw	r30, r24
    122e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1230:	83 8d       	ldd	r24, Z+27	; 0x1b
    1232:	98 17       	cp	r25, r24
    1234:	10 f0       	brcs	.+4      	; 0x123a <xQueueGenericSendFromISR+0x1c>
    1236:	22 30       	cpi	r18, 0x02	; 2
    1238:	f1 f4       	brne	.+60     	; 0x1276 <xQueueGenericSendFromISR+0x58>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    123a:	f8 01       	movw	r30, r16
    123c:	c6 8d       	ldd	r28, Z+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    123e:	c8 01       	movw	r24, r16
    1240:	42 2f       	mov	r20, r18
    1242:	0e 94 80 07 	call	0xf00	; 0xf00 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1246:	cf 3f       	cpi	r28, 0xFF	; 255
    1248:	89 f4       	brne	.+34     	; 0x126c <xQueueGenericSendFromISR+0x4e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    124a:	f8 01       	movw	r30, r16
    124c:	81 89       	ldd	r24, Z+17	; 0x11
    124e:	88 23       	and	r24, r24
    1250:	a1 f0       	breq	.+40     	; 0x127a <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1252:	c8 01       	movw	r24, r16
    1254:	41 96       	adiw	r24, 0x11	; 17
    1256:	0e 94 ae 11 	call	0x235c	; 0x235c <xTaskRemoveFromEventList>
    125a:	88 23       	and	r24, r24
    125c:	81 f0       	breq	.+32     	; 0x127e <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    125e:	e1 14       	cp	r14, r1
    1260:	f1 04       	cpc	r15, r1
    1262:	79 f0       	breq	.+30     	; 0x1282 <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1264:	81 e0       	ldi	r24, 0x01	; 1
    1266:	f7 01       	movw	r30, r14
    1268:	80 83       	st	Z, r24
    126a:	0c c0       	rjmp	.+24     	; 0x1284 <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    126c:	cf 5f       	subi	r28, 0xFF	; 255
    126e:	f8 01       	movw	r30, r16
    1270:	c6 8f       	std	Z+30, r28	; 0x1e
			}

			xReturn = pdPASS;
    1272:	81 e0       	ldi	r24, 0x01	; 1
    1274:	07 c0       	rjmp	.+14     	; 0x1284 <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1276:	80 e0       	ldi	r24, 0x00	; 0
    1278:	05 c0       	rjmp	.+10     	; 0x1284 <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    127a:	81 e0       	ldi	r24, 0x01	; 1
    127c:	03 c0       	rjmp	.+6      	; 0x1284 <xQueueGenericSendFromISR+0x66>
    127e:	81 e0       	ldi	r24, 0x01	; 1
    1280:	01 c0       	rjmp	.+2      	; 0x1284 <xQueueGenericSendFromISR+0x66>
    1282:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1284:	cf 91       	pop	r28
    1286:	1f 91       	pop	r17
    1288:	0f 91       	pop	r16
    128a:	ff 90       	pop	r15
    128c:	ef 90       	pop	r14
    128e:	08 95       	ret

00001290 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1290:	cf 93       	push	r28
    1292:	df 93       	push	r29
    1294:	fc 01       	movw	r30, r24
    1296:	eb 01       	movw	r28, r22
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1298:	82 8d       	ldd	r24, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    129a:	93 8d       	ldd	r25, Z+27	; 0x1b
    129c:	89 17       	cp	r24, r25
    129e:	b8 f4       	brcc	.+46     	; 0x12ce <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    12a0:	96 8d       	ldd	r25, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    12a2:	8f 5f       	subi	r24, 0xFF	; 255
    12a4:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    12a6:	9f 3f       	cpi	r25, 0xFF	; 255
    12a8:	71 f4       	brne	.+28     	; 0x12c6 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12aa:	81 89       	ldd	r24, Z+17	; 0x11
    12ac:	88 23       	and	r24, r24
    12ae:	89 f0       	breq	.+34     	; 0x12d2 <xQueueGiveFromISR+0x42>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12b0:	cf 01       	movw	r24, r30
    12b2:	41 96       	adiw	r24, 0x11	; 17
    12b4:	0e 94 ae 11 	call	0x235c	; 0x235c <xTaskRemoveFromEventList>
    12b8:	88 23       	and	r24, r24
    12ba:	69 f0       	breq	.+26     	; 0x12d6 <xQueueGiveFromISR+0x46>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    12bc:	20 97       	sbiw	r28, 0x00	; 0
    12be:	69 f0       	breq	.+26     	; 0x12da <xQueueGiveFromISR+0x4a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    12c0:	81 e0       	ldi	r24, 0x01	; 1
    12c2:	88 83       	st	Y, r24
    12c4:	0b c0       	rjmp	.+22     	; 0x12dc <xQueueGiveFromISR+0x4c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    12c6:	9f 5f       	subi	r25, 0xFF	; 255
    12c8:	96 8f       	std	Z+30, r25	; 0x1e
			}

			xReturn = pdPASS;
    12ca:	81 e0       	ldi	r24, 0x01	; 1
    12cc:	07 c0       	rjmp	.+14     	; 0x12dc <xQueueGiveFromISR+0x4c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    12ce:	80 e0       	ldi	r24, 0x00	; 0
    12d0:	05 c0       	rjmp	.+10     	; 0x12dc <xQueueGiveFromISR+0x4c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    12d2:	81 e0       	ldi	r24, 0x01	; 1
    12d4:	03 c0       	rjmp	.+6      	; 0x12dc <xQueueGiveFromISR+0x4c>
    12d6:	81 e0       	ldi	r24, 0x01	; 1
    12d8:	01 c0       	rjmp	.+2      	; 0x12dc <xQueueGiveFromISR+0x4c>
    12da:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    12dc:	df 91       	pop	r29
    12de:	cf 91       	pop	r28
    12e0:	08 95       	ret

000012e2 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    12e2:	8f 92       	push	r8
    12e4:	9f 92       	push	r9
    12e6:	af 92       	push	r10
    12e8:	bf 92       	push	r11
    12ea:	cf 92       	push	r12
    12ec:	df 92       	push	r13
    12ee:	ef 92       	push	r14
    12f0:	ff 92       	push	r15
    12f2:	0f 93       	push	r16
    12f4:	1f 93       	push	r17
    12f6:	cf 93       	push	r28
    12f8:	df 93       	push	r29
    12fa:	00 d0       	rcall	.+0      	; 0x12fc <xQueueGenericReceive+0x1a>
    12fc:	00 d0       	rcall	.+0      	; 0x12fe <xQueueGenericReceive+0x1c>
    12fe:	0f 92       	push	r0
    1300:	cd b7       	in	r28, 0x3d	; 61
    1302:	de b7       	in	r29, 0x3e	; 62
    1304:	7c 01       	movw	r14, r24
    1306:	4b 01       	movw	r8, r22
    1308:	5d 83       	std	Y+5, r21	; 0x05
    130a:	4c 83       	std	Y+4, r20	; 0x04
    130c:	c2 2e       	mov	r12, r18
BaseType_t xEntryTimeSet = pdFALSE;
    130e:	00 e0       	ldi	r16, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1310:	dd 24       	eor	r13, r13
    1312:	d3 94       	inc	r13
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1314:	0f 2e       	mov	r0, r31
    1316:	f1 e1       	ldi	r31, 0x11	; 17
    1318:	af 2e       	mov	r10, r31
    131a:	bb 24       	eor	r11, r11
    131c:	f0 2d       	mov	r31, r0
    131e:	a8 0e       	add	r10, r24
    1320:	b9 1e       	adc	r11, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1322:	0f b6       	in	r0, 0x3f	; 63
    1324:	f8 94       	cli
    1326:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1328:	f7 01       	movw	r30, r14
    132a:	12 8d       	ldd	r17, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    132c:	11 23       	and	r17, r17
    132e:	99 f1       	breq	.+102    	; 0x1396 <xQueueGenericReceive+0xb4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1330:	a6 80       	ldd	r10, Z+6	; 0x06
    1332:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1334:	c7 01       	movw	r24, r14
    1336:	b4 01       	movw	r22, r8
    1338:	0e 94 0e 07 	call	0xe1c	; 0xe1c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    133c:	cc 20       	and	r12, r12
    133e:	c9 f4       	brne	.+50     	; 0x1372 <xQueueGenericReceive+0x90>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1340:	11 50       	subi	r17, 0x01	; 1
    1342:	f7 01       	movw	r30, r14
    1344:	12 8f       	std	Z+26, r17	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1346:	80 81       	ld	r24, Z
    1348:	91 81       	ldd	r25, Z+1	; 0x01
    134a:	00 97       	sbiw	r24, 0x00	; 0
    134c:	29 f4       	brne	.+10     	; 0x1358 <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    134e:	0e 94 33 13 	call	0x2666	; 0x2666 <pvTaskIncrementMutexHeldCount>
    1352:	f7 01       	movw	r30, r14
    1354:	93 83       	std	Z+3, r25	; 0x03
    1356:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1358:	f7 01       	movw	r30, r14
    135a:	80 85       	ldd	r24, Z+8	; 0x08
    135c:	88 23       	and	r24, r24
    135e:	b9 f0       	breq	.+46     	; 0x138e <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1360:	c7 01       	movw	r24, r14
    1362:	08 96       	adiw	r24, 0x08	; 8
    1364:	0e 94 ae 11 	call	0x235c	; 0x235c <xTaskRemoveFromEventList>
    1368:	88 23       	and	r24, r24
    136a:	89 f0       	breq	.+34     	; 0x138e <xQueueGenericReceive+0xac>
						{
							queueYIELD_IF_USING_PREEMPTION();
    136c:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>
    1370:	0e c0       	rjmp	.+28     	; 0x138e <xQueueGenericReceive+0xac>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1372:	f7 01       	movw	r30, r14
    1374:	b7 82       	std	Z+7, r11	; 0x07
    1376:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1378:	81 89       	ldd	r24, Z+17	; 0x11
    137a:	88 23       	and	r24, r24
    137c:	41 f0       	breq	.+16     	; 0x138e <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    137e:	c7 01       	movw	r24, r14
    1380:	41 96       	adiw	r24, 0x11	; 17
    1382:	0e 94 ae 11 	call	0x235c	; 0x235c <xTaskRemoveFromEventList>
    1386:	88 23       	and	r24, r24
    1388:	11 f0       	breq	.+4      	; 0x138e <xQueueGenericReceive+0xac>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    138a:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    138e:	0f 90       	pop	r0
    1390:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1392:	81 e0       	ldi	r24, 0x01	; 1
    1394:	61 c0       	rjmp	.+194    	; 0x1458 <xQueueGenericReceive+0x176>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1396:	8c 81       	ldd	r24, Y+4	; 0x04
    1398:	9d 81       	ldd	r25, Y+5	; 0x05
    139a:	00 97       	sbiw	r24, 0x00	; 0
    139c:	21 f4       	brne	.+8      	; 0x13a6 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    139e:	0f 90       	pop	r0
    13a0:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    13a2:	80 e0       	ldi	r24, 0x00	; 0
    13a4:	59 c0       	rjmp	.+178    	; 0x1458 <xQueueGenericReceive+0x176>
				}
				else if( xEntryTimeSet == pdFALSE )
    13a6:	00 23       	and	r16, r16
    13a8:	29 f4       	brne	.+10     	; 0x13b4 <xQueueGenericReceive+0xd2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    13aa:	ce 01       	movw	r24, r28
    13ac:	01 96       	adiw	r24, 0x01	; 1
    13ae:	0e 94 33 12 	call	0x2466	; 0x2466 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    13b2:	0d 2d       	mov	r16, r13
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    13b4:	0f 90       	pop	r0
    13b6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    13b8:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    13bc:	0f b6       	in	r0, 0x3f	; 63
    13be:	f8 94       	cli
    13c0:	0f 92       	push	r0
    13c2:	f7 01       	movw	r30, r14
    13c4:	85 8d       	ldd	r24, Z+29	; 0x1d
    13c6:	8f 3f       	cpi	r24, 0xFF	; 255
    13c8:	09 f4       	brne	.+2      	; 0x13cc <xQueueGenericReceive+0xea>
    13ca:	15 8e       	std	Z+29, r1	; 0x1d
    13cc:	f7 01       	movw	r30, r14
    13ce:	86 8d       	ldd	r24, Z+30	; 0x1e
    13d0:	8f 3f       	cpi	r24, 0xFF	; 255
    13d2:	09 f4       	brne	.+2      	; 0x13d6 <xQueueGenericReceive+0xf4>
    13d4:	16 8e       	std	Z+30, r1	; 0x1e
    13d6:	0f 90       	pop	r0
    13d8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    13da:	ce 01       	movw	r24, r28
    13dc:	01 96       	adiw	r24, 0x01	; 1
    13de:	be 01       	movw	r22, r28
    13e0:	6c 5f       	subi	r22, 0xFC	; 252
    13e2:	7f 4f       	sbci	r23, 0xFF	; 255
    13e4:	0e 94 3e 12 	call	0x247c	; 0x247c <xTaskCheckForTimeOut>
    13e8:	88 23       	and	r24, r24
    13ea:	51 f5       	brne	.+84     	; 0x1440 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    13ec:	c7 01       	movw	r24, r14
    13ee:	0e 94 03 07 	call	0xe06	; 0xe06 <prvIsQueueEmpty>
    13f2:	88 23       	and	r24, r24
    13f4:	f9 f0       	breq	.+62     	; 0x1434 <xQueueGenericReceive+0x152>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    13f6:	f7 01       	movw	r30, r14
    13f8:	80 81       	ld	r24, Z
    13fa:	91 81       	ldd	r25, Z+1	; 0x01
    13fc:	00 97       	sbiw	r24, 0x00	; 0
    13fe:	51 f4       	brne	.+20     	; 0x1414 <xQueueGenericReceive+0x132>
					{
						taskENTER_CRITICAL();
    1400:	0f b6       	in	r0, 0x3f	; 63
    1402:	f8 94       	cli
    1404:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1406:	f7 01       	movw	r30, r14
    1408:	82 81       	ldd	r24, Z+2	; 0x02
    140a:	93 81       	ldd	r25, Z+3	; 0x03
    140c:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1410:	0f 90       	pop	r0
    1412:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1414:	6c 81       	ldd	r22, Y+4	; 0x04
    1416:	7d 81       	ldd	r23, Y+5	; 0x05
    1418:	c5 01       	movw	r24, r10
    141a:	0e 94 83 11 	call	0x2306	; 0x2306 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    141e:	c7 01       	movw	r24, r14
    1420:	0e 94 2b 07 	call	0xe56	; 0xe56 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1424:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <xTaskResumeAll>
    1428:	88 23       	and	r24, r24
    142a:	09 f0       	breq	.+2      	; 0x142e <xQueueGenericReceive+0x14c>
    142c:	7a cf       	rjmp	.-268    	; 0x1322 <xQueueGenericReceive+0x40>
				{
					portYIELD_WITHIN_API();
    142e:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>
    1432:	77 cf       	rjmp	.-274    	; 0x1322 <xQueueGenericReceive+0x40>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1434:	c7 01       	movw	r24, r14
    1436:	0e 94 2b 07 	call	0xe56	; 0xe56 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    143a:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <xTaskResumeAll>
    143e:	71 cf       	rjmp	.-286    	; 0x1322 <xQueueGenericReceive+0x40>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1440:	c7 01       	movw	r24, r14
    1442:	0e 94 2b 07 	call	0xe56	; 0xe56 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1446:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    144a:	c7 01       	movw	r24, r14
    144c:	0e 94 03 07 	call	0xe06	; 0xe06 <prvIsQueueEmpty>
    1450:	88 23       	and	r24, r24
    1452:	09 f4       	brne	.+2      	; 0x1456 <xQueueGenericReceive+0x174>
    1454:	66 cf       	rjmp	.-308    	; 0x1322 <xQueueGenericReceive+0x40>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1456:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    1458:	0f 90       	pop	r0
    145a:	0f 90       	pop	r0
    145c:	0f 90       	pop	r0
    145e:	0f 90       	pop	r0
    1460:	0f 90       	pop	r0
    1462:	df 91       	pop	r29
    1464:	cf 91       	pop	r28
    1466:	1f 91       	pop	r17
    1468:	0f 91       	pop	r16
    146a:	ff 90       	pop	r15
    146c:	ef 90       	pop	r14
    146e:	df 90       	pop	r13
    1470:	cf 90       	pop	r12
    1472:	bf 90       	pop	r11
    1474:	af 90       	pop	r10
    1476:	9f 90       	pop	r9
    1478:	8f 90       	pop	r8
    147a:	08 95       	ret

0000147c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    147c:	ef 92       	push	r14
    147e:	ff 92       	push	r15
    1480:	0f 93       	push	r16
    1482:	1f 93       	push	r17
    1484:	cf 93       	push	r28
    1486:	df 93       	push	r29
    1488:	8c 01       	movw	r16, r24
    148a:	7a 01       	movw	r14, r20
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    148c:	fc 01       	movw	r30, r24
    148e:	c2 8d       	ldd	r28, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1490:	cc 23       	and	r28, r28
    1492:	e9 f0       	breq	.+58     	; 0x14ce <xQueueReceiveFromISR+0x52>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1494:	d5 8d       	ldd	r29, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1496:	0e 94 0e 07 	call	0xe1c	; 0xe1c <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    149a:	c1 50       	subi	r28, 0x01	; 1
    149c:	f8 01       	movw	r30, r16
    149e:	c2 8f       	std	Z+26, r28	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    14a0:	df 3f       	cpi	r29, 0xFF	; 255
    14a2:	81 f4       	brne	.+32     	; 0x14c4 <xQueueReceiveFromISR+0x48>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14a4:	80 85       	ldd	r24, Z+8	; 0x08
    14a6:	88 23       	and	r24, r24
    14a8:	a1 f0       	breq	.+40     	; 0x14d2 <xQueueReceiveFromISR+0x56>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    14aa:	c8 01       	movw	r24, r16
    14ac:	08 96       	adiw	r24, 0x08	; 8
    14ae:	0e 94 ae 11 	call	0x235c	; 0x235c <xTaskRemoveFromEventList>
    14b2:	88 23       	and	r24, r24
    14b4:	81 f0       	breq	.+32     	; 0x14d6 <xQueueReceiveFromISR+0x5a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    14b6:	e1 14       	cp	r14, r1
    14b8:	f1 04       	cpc	r15, r1
    14ba:	79 f0       	breq	.+30     	; 0x14da <xQueueReceiveFromISR+0x5e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    14bc:	81 e0       	ldi	r24, 0x01	; 1
    14be:	f7 01       	movw	r30, r14
    14c0:	80 83       	st	Z, r24
    14c2:	0c c0       	rjmp	.+24     	; 0x14dc <xQueueReceiveFromISR+0x60>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    14c4:	df 5f       	subi	r29, 0xFF	; 255
    14c6:	f8 01       	movw	r30, r16
    14c8:	d5 8f       	std	Z+29, r29	; 0x1d
			}

			xReturn = pdPASS;
    14ca:	81 e0       	ldi	r24, 0x01	; 1
    14cc:	07 c0       	rjmp	.+14     	; 0x14dc <xQueueReceiveFromISR+0x60>
		}
		else
		{
			xReturn = pdFAIL;
    14ce:	80 e0       	ldi	r24, 0x00	; 0
    14d0:	05 c0       	rjmp	.+10     	; 0x14dc <xQueueReceiveFromISR+0x60>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
			}

			xReturn = pdPASS;
    14d2:	81 e0       	ldi	r24, 0x01	; 1
    14d4:	03 c0       	rjmp	.+6      	; 0x14dc <xQueueReceiveFromISR+0x60>
    14d6:	81 e0       	ldi	r24, 0x01	; 1
    14d8:	01 c0       	rjmp	.+2      	; 0x14dc <xQueueReceiveFromISR+0x60>
    14da:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    14dc:	df 91       	pop	r29
    14de:	cf 91       	pop	r28
    14e0:	1f 91       	pop	r17
    14e2:	0f 91       	pop	r16
    14e4:	ff 90       	pop	r15
    14e6:	ef 90       	pop	r14
    14e8:	08 95       	ret

000014ea <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    14ea:	0f 93       	push	r16
    14ec:	1f 93       	push	r17
    14ee:	cf 93       	push	r28
    14f0:	df 93       	push	r29
    14f2:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    14f4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    14f6:	88 23       	and	r24, r24
    14f8:	49 f0       	breq	.+18     	; 0x150c <xQueuePeekFromISR+0x22>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    14fa:	0e 81       	ldd	r16, Y+6	; 0x06
    14fc:	1f 81       	ldd	r17, Y+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    14fe:	ce 01       	movw	r24, r28
    1500:	0e 94 0e 07 	call	0xe1c	; 0xe1c <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1504:	1f 83       	std	Y+7, r17	; 0x07
    1506:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1508:	81 e0       	ldi	r24, 0x01	; 1
    150a:	01 c0       	rjmp	.+2      	; 0x150e <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    150c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    150e:	df 91       	pop	r29
    1510:	cf 91       	pop	r28
    1512:	1f 91       	pop	r17
    1514:	0f 91       	pop	r16
    1516:	08 95       	ret

00001518 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1518:	0f b6       	in	r0, 0x3f	; 63
    151a:	f8 94       	cli
    151c:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    151e:	fc 01       	movw	r30, r24
    1520:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1522:	0f 90       	pop	r0
    1524:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1526:	08 95       	ret

00001528 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    1528:	fc 01       	movw	r30, r24
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    152a:	0f b6       	in	r0, 0x3f	; 63
    152c:	f8 94       	cli
    152e:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1530:	92 8d       	ldd	r25, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1532:	0f 90       	pop	r0
    1534:	0f be       	out	0x3f, r0	; 63
	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1536:	83 8d       	ldd	r24, Z+27	; 0x1b
	}
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1538:	89 1b       	sub	r24, r25
    153a:	08 95       	ret

0000153c <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    153c:	fc 01       	movw	r30, r24
    153e:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1540:	08 95       	ret

00001542 <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1542:	fc 01       	movw	r30, r24
    1544:	92 8d       	ldd	r25, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    1546:	81 e0       	ldi	r24, 0x01	; 1
    1548:	91 11       	cpse	r25, r1
    154a:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    154c:	08 95       	ret

0000154e <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    154e:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    1550:	22 8d       	ldd	r18, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    1552:	81 e0       	ldi	r24, 0x01	; 1
    1554:	93 8d       	ldd	r25, Z+27	; 0x1b
    1556:	29 13       	cpse	r18, r25
    1558:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    155a:	08 95       	ret

0000155c <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    155c:	dc 01       	movw	r26, r24

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
    155e:	80 91 1a 04 	lds	r24, 0x041A
    1562:	90 91 1b 04 	lds	r25, 0x041B
    1566:	00 97       	sbiw	r24, 0x00	; 0
    1568:	51 f0       	breq	.+20     	; 0x157e <vQueueAddToRegistry+0x22>
    156a:	ee e1       	ldi	r30, 0x1E	; 30
    156c:	f4 e0       	ldi	r31, 0x04	; 4
    156e:	21 e0       	ldi	r18, 0x01	; 1
    1570:	30 e0       	ldi	r19, 0x00	; 0
    1572:	a9 01       	movw	r20, r18
    1574:	80 81       	ld	r24, Z
    1576:	91 81       	ldd	r25, Z+1	; 0x01
    1578:	00 97       	sbiw	r24, 0x00	; 0
    157a:	79 f4       	brne	.+30     	; 0x159a <vQueueAddToRegistry+0x3e>
    157c:	02 c0       	rjmp	.+4      	; 0x1582 <vQueueAddToRegistry+0x26>
    157e:	40 e0       	ldi	r20, 0x00	; 0
    1580:	50 e0       	ldi	r21, 0x00	; 0
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
    1582:	fa 01       	movw	r30, r20
    1584:	ee 0f       	add	r30, r30
    1586:	ff 1f       	adc	r31, r31
    1588:	ee 0f       	add	r30, r30
    158a:	ff 1f       	adc	r31, r31
    158c:	e6 5e       	subi	r30, 0xE6	; 230
    158e:	fb 4f       	sbci	r31, 0xFB	; 251
    1590:	71 83       	std	Z+1, r23	; 0x01
    1592:	60 83       	st	Z, r22
				xQueueRegistry[ ux ].xHandle = xQueue;
    1594:	b3 83       	std	Z+3, r27	; 0x03
    1596:	a2 83       	std	Z+2, r26	; 0x02

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
    1598:	08 95       	ret
    159a:	2f 5f       	subi	r18, 0xFF	; 255
    159c:	3f 4f       	sbci	r19, 0xFF	; 255
    159e:	34 96       	adiw	r30, 0x04	; 4
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    15a0:	28 30       	cpi	r18, 0x08	; 8
    15a2:	31 05       	cpc	r19, r1
    15a4:	31 f7       	brne	.-52     	; 0x1572 <vQueueAddToRegistry+0x16>
    15a6:	08 95       	ret

000015a8 <pcQueueGetName>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    15a8:	ac 01       	movw	r20, r24

		/* Note there is nothing here to protect against another task adding or
		removing entries from the registry while it is being searched. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
    15aa:	80 91 1c 04 	lds	r24, 0x041C
    15ae:	90 91 1d 04 	lds	r25, 0x041D
    15b2:	84 17       	cp	r24, r20
    15b4:	95 07       	cpc	r25, r21
    15b6:	59 f0       	breq	.+22     	; 0x15ce <pcQueueGetName+0x26>
    15b8:	e0 e2       	ldi	r30, 0x20	; 32
    15ba:	f4 e0       	ldi	r31, 0x04	; 4
    15bc:	21 e0       	ldi	r18, 0x01	; 1
    15be:	30 e0       	ldi	r19, 0x00	; 0
    15c0:	b9 01       	movw	r22, r18
    15c2:	80 81       	ld	r24, Z
    15c4:	91 81       	ldd	r25, Z+1	; 0x01
    15c6:	84 17       	cp	r24, r20
    15c8:	95 07       	cpc	r25, r21
    15ca:	69 f4       	brne	.+26     	; 0x15e6 <pcQueueGetName+0x3e>
    15cc:	02 c0       	rjmp	.+4      	; 0x15d2 <pcQueueGetName+0x2a>
    15ce:	60 e0       	ldi	r22, 0x00	; 0
    15d0:	70 e0       	ldi	r23, 0x00	; 0
			{
				pcReturn = xQueueRegistry[ ux ].pcQueueName;
    15d2:	fb 01       	movw	r30, r22
    15d4:	ee 0f       	add	r30, r30
    15d6:	ff 1f       	adc	r31, r31
    15d8:	ee 0f       	add	r30, r30
    15da:	ff 1f       	adc	r31, r31
    15dc:	e6 5e       	subi	r30, 0xE6	; 230
    15de:	fb 4f       	sbci	r31, 0xFB	; 251
    15e0:	80 81       	ld	r24, Z
    15e2:	91 81       	ldd	r25, Z+1	; 0x01
				break;
    15e4:	08 95       	ret
    15e6:	2f 5f       	subi	r18, 0xFF	; 255
    15e8:	3f 4f       	sbci	r19, 0xFF	; 255
    15ea:	34 96       	adiw	r30, 0x04	; 4
	UBaseType_t ux;
	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */

		/* Note there is nothing here to protect against another task adding or
		removing entries from the registry while it is being searched. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    15ec:	28 30       	cpi	r18, 0x08	; 8
    15ee:	31 05       	cpc	r19, r1
    15f0:	39 f7       	brne	.-50     	; 0x15c0 <pcQueueGetName+0x18>
#if ( configQUEUE_REGISTRY_SIZE > 0 )

	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
	UBaseType_t ux;
	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    15f2:	80 e0       	ldi	r24, 0x00	; 0
    15f4:	90 e0       	ldi	r25, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}

		return pcReturn;
	}
    15f6:	08 95       	ret

000015f8 <vQueueUnregisterQueue>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueUnregisterQueue( QueueHandle_t xQueue )
	{
    15f8:	ac 01       	movw	r20, r24

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
    15fa:	80 91 1c 04 	lds	r24, 0x041C
    15fe:	90 91 1d 04 	lds	r25, 0x041D
    1602:	84 17       	cp	r24, r20
    1604:	95 07       	cpc	r25, r21
    1606:	59 f0       	breq	.+22     	; 0x161e <vQueueUnregisterQueue+0x26>
    1608:	e0 e2       	ldi	r30, 0x20	; 32
    160a:	f4 e0       	ldi	r31, 0x04	; 4
    160c:	21 e0       	ldi	r18, 0x01	; 1
    160e:	30 e0       	ldi	r19, 0x00	; 0
    1610:	b9 01       	movw	r22, r18
    1612:	80 81       	ld	r24, Z
    1614:	91 81       	ldd	r25, Z+1	; 0x01
    1616:	84 17       	cp	r24, r20
    1618:	95 07       	cpc	r25, r21
    161a:	79 f4       	brne	.+30     	; 0x163a <vQueueUnregisterQueue+0x42>
    161c:	02 c0       	rjmp	.+4      	; 0x1622 <vQueueUnregisterQueue+0x2a>
    161e:	60 e0       	ldi	r22, 0x00	; 0
    1620:	70 e0       	ldi	r23, 0x00	; 0
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
    1622:	fb 01       	movw	r30, r22
    1624:	ee 0f       	add	r30, r30
    1626:	ff 1f       	adc	r31, r31
    1628:	ee 0f       	add	r30, r30
    162a:	ff 1f       	adc	r31, r31
    162c:	e6 5e       	subi	r30, 0xE6	; 230
    162e:	fb 4f       	sbci	r31, 0xFB	; 251
    1630:	11 82       	std	Z+1, r1	; 0x01
    1632:	10 82       	st	Z, r1

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
    1634:	13 82       	std	Z+3, r1	; 0x03
    1636:	12 82       	std	Z+2, r1	; 0x02
				break;
    1638:	08 95       	ret
    163a:	2f 5f       	subi	r18, 0xFF	; 255
    163c:	3f 4f       	sbci	r19, 0xFF	; 255
    163e:	34 96       	adiw	r30, 0x04	; 4
	{
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    1640:	28 30       	cpi	r18, 0x08	; 8
    1642:	31 05       	cpc	r19, r1
    1644:	29 f7       	brne	.-54     	; 0x1610 <vQueueUnregisterQueue+0x18>
    1646:	08 95       	ret

00001648 <vQueueDelete>:
	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    1648:	cf 93       	push	r28
    164a:	df 93       	push	r29
    164c:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );
	traceQUEUE_DELETE( pxQueue );

	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
    164e:	0e 94 fc 0a 	call	0x15f8	; 0x15f8 <vQueueUnregisterQueue>

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1652:	ce 01       	movw	r24, r28
    1654:	0e 94 c4 02 	call	0x588	; 0x588 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    1658:	df 91       	pop	r29
    165a:	cf 91       	pop	r28
    165c:	08 95       	ret

0000165e <task1>:
		{
			PORTC ^= (1<<6);
		}
		if(input == '3')
		{
			PORTC ^= (1<<5);
    165e:	c0 e2       	ldi	r28, 0x20	; 32
		{
			PORTC ^= (1<<7);
		}
		if(input == '2')
		{
			PORTC ^= (1<<6);
    1660:	10 e4       	ldi	r17, 0x40	; 64
		{
			PORTC ^= (1<<5);
		}
		if(input == '4')
		{
			PORTC ^= (1<<4);
    1662:	00 e1       	ldi	r16, 0x10	; 16
	short ss;
	while(1)
	{
		
		
		char input= SPI_SlaveReceive();
    1664:	0e 94 a0 0b 	call	0x1740	; 0x1740 <SPI_SlaveReceive>
		
		if(input == '1')
    1668:	81 33       	cpi	r24, 0x31	; 49
    166a:	21 f4       	brne	.+8      	; 0x1674 <task1+0x16>
		{
			PORTC ^= (1<<7);
    166c:	95 b3       	in	r25, 0x15	; 21
    166e:	90 58       	subi	r25, 0x80	; 128
    1670:	95 bb       	out	0x15, r25	; 21
    1672:	0c c0       	rjmp	.+24     	; 0x168c <task1+0x2e>
		}
		if(input == '2')
    1674:	82 33       	cpi	r24, 0x32	; 50
    1676:	21 f4       	brne	.+8      	; 0x1680 <task1+0x22>
		{
			PORTC ^= (1<<6);
    1678:	95 b3       	in	r25, 0x15	; 21
    167a:	91 27       	eor	r25, r17
    167c:	95 bb       	out	0x15, r25	; 21
    167e:	0c c0       	rjmp	.+24     	; 0x1698 <task1+0x3a>
		}
		if(input == '3')
    1680:	83 33       	cpi	r24, 0x33	; 51
    1682:	21 f4       	brne	.+8      	; 0x168c <task1+0x2e>
		{
			PORTC ^= (1<<5);
    1684:	85 b3       	in	r24, 0x15	; 21
    1686:	8c 27       	eor	r24, r28
    1688:	85 bb       	out	0x15, r24	; 21
    168a:	ec cf       	rjmp	.-40     	; 0x1664 <task1+0x6>
		}
		if(input == '4')
    168c:	84 33       	cpi	r24, 0x34	; 52
    168e:	21 f4       	brne	.+8      	; 0x1698 <task1+0x3a>
		{
			PORTC ^= (1<<4);
    1690:	85 b3       	in	r24, 0x15	; 21
    1692:	80 27       	eor	r24, r16
    1694:	85 bb       	out	0x15, r24	; 21
    1696:	e6 cf       	rjmp	.-52     	; 0x1664 <task1+0x6>
		}
		if(input == '5')
    1698:	85 33       	cpi	r24, 0x35	; 53
    169a:	21 f7       	brne	.-56     	; 0x1664 <task1+0x6>
		{
			input =SPI_SlaveReceive();
    169c:	0e 94 a0 0b 	call	0x1740	; 0x1740 <SPI_SlaveReceive>
    16a0:	d8 2f       	mov	r29, r24
			
			if((PORTC & (1<<3)) == 0)
    16a2:	ab 99       	sbic	0x15, 3	; 21
    16a4:	16 c0       	rjmp	.+44     	; 0x16d2 <task1+0x74>
			{
				ss = adc_read(0);
    16a6:	80 e0       	ldi	r24, 0x00	; 0
    16a8:	90 e0       	ldi	r25, 0x00	; 0
    16aa:	0e 94 4e 00 	call	0x9c	; 0x9c <adc_read>
				ss/=2;
    16ae:	28 2f       	mov	r18, r24
    16b0:	39 2f       	mov	r19, r25
    16b2:	33 23       	and	r19, r19
    16b4:	14 f4       	brge	.+4      	; 0x16ba <task1+0x5c>
    16b6:	2f 5f       	subi	r18, 0xFF	; 255
    16b8:	3f 4f       	sbci	r19, 0xFF	; 255
    16ba:	c9 01       	movw	r24, r18
    16bc:	95 95       	asr	r25
    16be:	87 95       	ror	r24
				
				if(ss>input+1)
    16c0:	2d 2f       	mov	r18, r29
    16c2:	30 e0       	ldi	r19, 0x00	; 0
    16c4:	2f 5f       	subi	r18, 0xFF	; 255
    16c6:	3f 4f       	sbci	r19, 0xFF	; 255
    16c8:	28 17       	cp	r18, r24
    16ca:	39 07       	cpc	r19, r25
    16cc:	5c f6       	brge	.-106    	; 0x1664 <task1+0x6>
				{
					PORTC |= (1<<3);
    16ce:	ab 9a       	sbi	0x15, 3	; 21
    16d0:	c9 cf       	rjmp	.-110    	; 0x1664 <task1+0x6>
				}
			}			
			else
			{
				
				PORTC &=(~(1<<3));
    16d2:	ab 98       	cbi	0x15, 3	; 21
    16d4:	c7 cf       	rjmp	.-114    	; 0x1664 <task1+0x6>

000016d6 <main>:



int main(void)
{
	sei();
    16d6:	78 94       	sei
	adc_init();
    16d8:	0e 94 49 00 	call	0x92	; 0x92 <adc_init>
	SPI_SlaveInit();
    16dc:	0e 94 9d 0b 	call	0x173a	; 0x173a <SPI_SlaveInit>
	
	DDRC |=(1<<7);
    16e0:	a7 9a       	sbi	0x14, 7	; 20
	DDRC |=(1<<6);
    16e2:	a6 9a       	sbi	0x14, 6	; 20
	DDRC |=(1<<5);
    16e4:	a5 9a       	sbi	0x14, 5	; 20
	DDRC |=(1<<4);
    16e6:	a4 9a       	sbi	0x14, 4	; 20
	DDRC |=(1<<3);
    16e8:	a3 9a       	sbi	0x14, 3	; 20
	
	
    while(1)
    {	
		
		xTaskCreate(
    16ea:	cf e2       	ldi	r28, 0x2F	; 47
    16ec:	db e0       	ldi	r29, 0x0B	; 11
    16ee:	0f 2e       	mov	r0, r31
    16f0:	f2 e7       	ldi	r31, 0x72	; 114
    16f2:	cf 2e       	mov	r12, r31
    16f4:	f0 e0       	ldi	r31, 0x00	; 0
    16f6:	df 2e       	mov	r13, r31
    16f8:	f0 2d       	mov	r31, r0
    16fa:	e0 90 a9 03 	lds	r14, 0x03A9
    16fe:	f0 90 aa 03 	lds	r15, 0x03AA
    1702:	ce 01       	movw	r24, r28
    1704:	b6 01       	movw	r22, r12
    1706:	44 e6       	ldi	r20, 0x64	; 100
    1708:	50 e0       	ldi	r21, 0x00	; 0
    170a:	20 e0       	ldi	r18, 0x00	; 0
    170c:	30 e0       	ldi	r19, 0x00	; 0
    170e:	01 e0       	ldi	r16, 0x01	; 1
    1710:	0e 94 3f 0c 	call	0x187e	; 0x187e <xTaskCreate>
		1 ,           // proirity the bigger the more priority
		task1handel          // handler 
		);
		
		
		vTaskStartScheduler();
    1714:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <vTaskStartScheduler>
    1718:	f0 cf       	rjmp	.-32     	; 0x16fa <main+0x24>

0000171a <SPI_MasterInit>:


void SPI_MasterInit(void)
{
	/*Set clock to fosc/16*/
	SPCR |= (1<<SPR0);
    171a:	68 9a       	sbi	0x0d, 0	; 13
	SPCR &= (~(1<<SPR1));
    171c:	69 98       	cbi	0x0d, 1	; 13
	SPCR &= (~(1<<SPI2X));
    171e:	68 98       	cbi	0x0d, 0	; 13
	
	/*Enable Master mode*/
	SPCR |=(1<<MSTR);
    1720:	6c 9a       	sbi	0x0d, 4	; 13
	/*At the End,  Enable SPI*/
	SPCR |=(1<<SPE);
    1722:	6e 9a       	sbi	0x0d, 6	; 13
	/*Set SS--> Pin 4 / MOSI --> Pin 5 / SCK --> Pin 7 as outputs for master*/
	DDRB |=(1<<SS);
    1724:	bc 9a       	sbi	0x17, 4	; 23
	DDRB |=(1<<MOSI);
    1726:	bd 9a       	sbi	0x17, 5	; 23
	DDRB |=(1<<SCK);
    1728:	bf 9a       	sbi	0x17, 7	; 23
	
	/*Set SS Pin to high*/
	PORTB |=(1<<SS);
    172a:	c4 9a       	sbi	0x18, 4	; 24
}
    172c:	08 95       	ret

0000172e <SPI_MasterTransmit>:

void SPI_MasterTransmit(char Data)
{
	/*Clear SS to write to slave*/
	PORTB &=(~(1<<SS));
    172e:	c4 98       	cbi	0x18, 4	; 24
	/*Put data on bus*/
	SPDR = Data;
    1730:	8f b9       	out	0x0f, r24	; 15
	/*Wait until the transmission is finished*/
	while(((SPSR&(1<<SPIF))==0))
    1732:	77 9b       	sbis	0x0e, 7	; 14
    1734:	fe cf       	rjmp	.-4      	; 0x1732 <SPI_MasterTransmit+0x4>
	{
		
		
	}
	/*Set SS to high*/
	PORTB |=(1<<SS);
    1736:	c4 9a       	sbi	0x18, 4	; 24
	
}
    1738:	08 95       	ret

0000173a <SPI_SlaveInit>:

void SPI_SlaveInit(void)
{
	/*Enable SPI*/
	SPCR |=(1<<SPE);
    173a:	6e 9a       	sbi	0x0d, 6	; 13
	/*Set MISO as output*/
	PORTB &=(~(1<<MISO));
    173c:	c6 98       	cbi	0x18, 6	; 24

}
    173e:	08 95       	ret

00001740 <SPI_SlaveReceive>:

char SPI_SlaveReceive(void)
{
	/*Wait until data is received in SPI register*/
	while(((SPSR&(1<<SPIF))==0))
    1740:	77 9b       	sbis	0x0e, 7	; 14
    1742:	fe cf       	rjmp	.-4      	; 0x1740 <SPI_SlaveReceive>
		
		
	}
	/*The data arrived read it*/
	
	return SPDR;
    1744:	8f b1       	in	r24, 0x0f	; 15
    1746:	08 95       	ret

00001748 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    1748:	fc 01       	movw	r30, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    174a:	82 85       	ldd	r24, Z+10	; 0x0a
    174c:	93 85       	ldd	r25, Z+11	; 0x0b
    174e:	24 e0       	ldi	r18, 0x04	; 4
    1750:	8f 30       	cpi	r24, 0x0F	; 15
    1752:	92 07       	cpc	r25, r18
    1754:	61 f4       	brne	.+24     	; 0x176e <prvTaskIsTaskSuspended+0x26>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    1756:	24 89       	ldd	r18, Z+20	; 0x14
    1758:	35 89       	ldd	r19, Z+21	; 0x15
    175a:	83 e0       	ldi	r24, 0x03	; 3
    175c:	2d 3f       	cpi	r18, 0xFD	; 253
    175e:	38 07       	cpc	r19, r24
    1760:	41 f0       	breq	.+16     	; 0x1772 <prvTaskIsTaskSuspended+0x2a>

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
	BaseType_t xReturn = pdFALSE;
    1762:	81 e0       	ldi	r24, 0x01	; 1
    1764:	21 15       	cp	r18, r1
    1766:	31 05       	cpc	r19, r1
    1768:	29 f0       	breq	.+10     	; 0x1774 <prvTaskIsTaskSuspended+0x2c>
    176a:	80 e0       	ldi	r24, 0x00	; 0
    176c:	08 95       	ret
    176e:	80 e0       	ldi	r24, 0x00	; 0
    1770:	08 95       	ret
    1772:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    1774:	08 95       	ret

00001776 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1776:	e0 91 bb 03 	lds	r30, 0x03BB
    177a:	f0 91 bc 03 	lds	r31, 0x03BC
    177e:	80 81       	ld	r24, Z
    1780:	88 23       	and	r24, r24
    1782:	39 f4       	brne	.+14     	; 0x1792 <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    1784:	8f ef       	ldi	r24, 0xFF	; 255
    1786:	9f ef       	ldi	r25, 0xFF	; 255
    1788:	90 93 af 03 	sts	0x03AF, r25
    178c:	80 93 ae 03 	sts	0x03AE, r24
    1790:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1792:	e0 91 bb 03 	lds	r30, 0x03BB
    1796:	f0 91 bc 03 	lds	r31, 0x03BC
    179a:	05 80       	ldd	r0, Z+5	; 0x05
    179c:	f6 81       	ldd	r31, Z+6	; 0x06
    179e:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    17a0:	06 80       	ldd	r0, Z+6	; 0x06
    17a2:	f7 81       	ldd	r31, Z+7	; 0x07
    17a4:	e0 2d       	mov	r30, r0
    17a6:	82 81       	ldd	r24, Z+2	; 0x02
    17a8:	93 81       	ldd	r25, Z+3	; 0x03
    17aa:	90 93 af 03 	sts	0x03AF, r25
    17ae:	80 93 ae 03 	sts	0x03AE, r24
    17b2:	08 95       	ret

000017b4 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    17b4:	ef 92       	push	r14
    17b6:	ff 92       	push	r15
    17b8:	1f 93       	push	r17
    17ba:	cf 93       	push	r28
    17bc:	df 93       	push	r29
    17be:	ec 01       	movw	r28, r24
    17c0:	16 2f       	mov	r17, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    17c2:	e0 90 b5 03 	lds	r14, 0x03B5
    17c6:	f0 90 b6 03 	lds	r15, 0x03B6
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    17ca:	80 91 ab 03 	lds	r24, 0x03AB
    17ce:	90 91 ac 03 	lds	r25, 0x03AC
    17d2:	02 96       	adiw	r24, 0x02	; 2
    17d4:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    17d8:	8f ef       	ldi	r24, 0xFF	; 255
    17da:	cf 3f       	cpi	r28, 0xFF	; 255
    17dc:	d8 07       	cpc	r29, r24
    17de:	69 f4       	brne	.+26     	; 0x17fa <prvAddCurrentTaskToDelayedList+0x46>
    17e0:	11 23       	and	r17, r17
    17e2:	59 f0       	breq	.+22     	; 0x17fa <prvAddCurrentTaskToDelayedList+0x46>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    17e4:	60 91 ab 03 	lds	r22, 0x03AB
    17e8:	70 91 ac 03 	lds	r23, 0x03AC
    17ec:	6e 5f       	subi	r22, 0xFE	; 254
    17ee:	7f 4f       	sbci	r23, 0xFF	; 255
    17f0:	8f e0       	ldi	r24, 0x0F	; 15
    17f2:	94 e0       	ldi	r25, 0x04	; 4
    17f4:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>
    17f8:	2f c0       	rjmp	.+94     	; 0x1858 <prvAddCurrentTaskToDelayedList+0xa4>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    17fa:	ce 0d       	add	r28, r14
    17fc:	df 1d       	adc	r29, r15

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    17fe:	e0 91 ab 03 	lds	r30, 0x03AB
    1802:	f0 91 ac 03 	lds	r31, 0x03AC
    1806:	d3 83       	std	Z+3, r29	; 0x03
    1808:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
    180a:	ce 15       	cp	r28, r14
    180c:	df 05       	cpc	r29, r15
    180e:	68 f4       	brcc	.+26     	; 0x182a <prvAddCurrentTaskToDelayedList+0x76>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1810:	80 91 b9 03 	lds	r24, 0x03B9
    1814:	90 91 ba 03 	lds	r25, 0x03BA
    1818:	60 91 ab 03 	lds	r22, 0x03AB
    181c:	70 91 ac 03 	lds	r23, 0x03AC
    1820:	6e 5f       	subi	r22, 0xFE	; 254
    1822:	7f 4f       	sbci	r23, 0xFF	; 255
    1824:	0e 94 2a 05 	call	0xa54	; 0xa54 <vListInsert>
    1828:	17 c0       	rjmp	.+46     	; 0x1858 <prvAddCurrentTaskToDelayedList+0xa4>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    182a:	80 91 bb 03 	lds	r24, 0x03BB
    182e:	90 91 bc 03 	lds	r25, 0x03BC
    1832:	60 91 ab 03 	lds	r22, 0x03AB
    1836:	70 91 ac 03 	lds	r23, 0x03AC
    183a:	6e 5f       	subi	r22, 0xFE	; 254
    183c:	7f 4f       	sbci	r23, 0xFF	; 255
    183e:	0e 94 2a 05 	call	0xa54	; 0xa54 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    1842:	80 91 ae 03 	lds	r24, 0x03AE
    1846:	90 91 af 03 	lds	r25, 0x03AF
    184a:	c8 17       	cp	r28, r24
    184c:	d9 07       	cpc	r29, r25
    184e:	20 f4       	brcc	.+8      	; 0x1858 <prvAddCurrentTaskToDelayedList+0xa4>
				{
					xNextTaskUnblockTime = xTimeToWake;
    1850:	d0 93 af 03 	sts	0x03AF, r29
    1854:	c0 93 ae 03 	sts	0x03AE, r28

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    1858:	df 91       	pop	r29
    185a:	cf 91       	pop	r28
    185c:	1f 91       	pop	r17
    185e:	ff 90       	pop	r15
    1860:	ef 90       	pop	r14
    1862:	08 95       	ret

00001864 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    1864:	cf 93       	push	r28
    1866:	df 93       	push	r29
    1868:	ec 01       	movw	r28, r24

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    186a:	8f 89       	ldd	r24, Y+23	; 0x17
    186c:	98 8d       	ldd	r25, Y+24	; 0x18
    186e:	0e 94 c4 02 	call	0x588	; 0x588 <vPortFree>
			vPortFree( pxTCB );
    1872:	ce 01       	movw	r24, r28
    1874:	0e 94 c4 02 	call	0x588	; 0x588 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    1878:	df 91       	pop	r29
    187a:	cf 91       	pop	r28
    187c:	08 95       	ret

0000187e <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    187e:	2f 92       	push	r2
    1880:	3f 92       	push	r3
    1882:	4f 92       	push	r4
    1884:	5f 92       	push	r5
    1886:	6f 92       	push	r6
    1888:	7f 92       	push	r7
    188a:	8f 92       	push	r8
    188c:	9f 92       	push	r9
    188e:	af 92       	push	r10
    1890:	bf 92       	push	r11
    1892:	df 92       	push	r13
    1894:	ef 92       	push	r14
    1896:	ff 92       	push	r15
    1898:	0f 93       	push	r16
    189a:	1f 93       	push	r17
    189c:	cf 93       	push	r28
    189e:	df 93       	push	r29
    18a0:	3c 01       	movw	r6, r24
    18a2:	5b 01       	movw	r10, r22
    18a4:	ea 01       	movw	r28, r20
    18a6:	29 01       	movw	r4, r18
    18a8:	d0 2e       	mov	r13, r16
    18aa:	47 01       	movw	r8, r14
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    18ac:	ca 01       	movw	r24, r20
    18ae:	0e 94 24 02 	call	0x448	; 0x448 <pvPortMalloc>
    18b2:	7c 01       	movw	r14, r24

			if( pxStack != NULL )
    18b4:	00 97       	sbiw	r24, 0x00	; 0
    18b6:	09 f4       	brne	.+2      	; 0x18ba <xTaskCreate+0x3c>
    18b8:	ed c0       	rjmp	.+474    	; 0x1a94 <xTaskCreate+0x216>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    18ba:	8a e2       	ldi	r24, 0x2A	; 42
    18bc:	90 e0       	ldi	r25, 0x00	; 0
    18be:	0e 94 24 02 	call	0x448	; 0x448 <pvPortMalloc>
    18c2:	8c 01       	movw	r16, r24

				if( pxNewTCB != NULL )
    18c4:	00 97       	sbiw	r24, 0x00	; 0
    18c6:	81 f0       	breq	.+32     	; 0x18e8 <xTaskCreate+0x6a>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    18c8:	fc 01       	movw	r30, r24
    18ca:	f0 8e       	std	Z+24, r15	; 0x18
    18cc:	e7 8a       	std	Z+23, r14	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    18ce:	21 97       	sbiw	r28, 0x01	; 1
    18d0:	17 01       	movw	r2, r14
    18d2:	2c 0e       	add	r2, r28
    18d4:	3d 1e       	adc	r3, r29
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    18d6:	f5 01       	movw	r30, r10
    18d8:	80 81       	ld	r24, Z
    18da:	f8 01       	movw	r30, r16
    18dc:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    18de:	f5 01       	movw	r30, r10
    18e0:	80 81       	ld	r24, Z
    18e2:	88 23       	and	r24, r24
    18e4:	31 f4       	brne	.+12     	; 0x18f2 <xTaskCreate+0x74>
    18e6:	13 c0       	rjmp	.+38     	; 0x190e <xTaskCreate+0x90>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    18e8:	c7 01       	movw	r24, r14
    18ea:	0e 94 c4 02 	call	0x588	; 0x588 <vPortFree>
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    18ee:	8f ef       	ldi	r24, 0xFF	; 255
    18f0:	d6 c0       	rjmp	.+428    	; 0x1a9e <xTaskCreate+0x220>
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    18f2:	e8 01       	movw	r28, r16
    18f4:	6a 96       	adiw	r28, 0x1a	; 26
    18f6:	d5 01       	movw	r26, r10
    18f8:	11 96       	adiw	r26, 0x01	; 1
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    18fa:	81 e0       	ldi	r24, 0x01	; 1
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    18fc:	fd 01       	movw	r30, r26
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    18fe:	9d 91       	ld	r25, X+
    1900:	99 93       	st	Y+, r25

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1902:	90 81       	ld	r25, Z
    1904:	99 23       	and	r25, r25
    1906:	19 f0       	breq	.+6      	; 0x190e <xTaskCreate+0x90>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1908:	8f 5f       	subi	r24, 0xFF	; 255
    190a:	8a 30       	cpi	r24, 0x0A	; 10
    190c:	b9 f7       	brne	.-18     	; 0x18fc <xTaskCreate+0x7e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    190e:	f8 01       	movw	r30, r16
    1910:	12 a2       	lds	r17, 0x92
    1912:	cd 2d       	mov	r28, r13
    1914:	c5 30       	cpi	r28, 0x05	; 5
    1916:	08 f0       	brcs	.+2      	; 0x191a <xTaskCreate+0x9c>
    1918:	c4 e0       	ldi	r28, 0x04	; 4
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    191a:	f8 01       	movw	r30, r16
    191c:	c6 8b       	std	Z+22, r28	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    191e:	c3 a3       	lds	r28, 0x53
		pxNewTCB->uxMutexesHeld = 0;
    1920:	14 a2       	lds	r17, 0x94
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    1922:	ee 24       	eor	r14, r14
    1924:	ff 24       	eor	r15, r15
    1926:	68 94       	set
    1928:	e1 f8       	bld	r14, 1
    192a:	e0 0e       	add	r14, r16
    192c:	f1 1e       	adc	r15, r17
    192e:	c7 01       	movw	r24, r14
    1930:	0e 94 07 05 	call	0xa0e	; 0xa0e <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    1934:	c8 01       	movw	r24, r16
    1936:	0c 96       	adiw	r24, 0x0c	; 12
    1938:	0e 94 07 05 	call	0xa0e	; 0xa0e <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    193c:	f8 01       	movw	r30, r16
    193e:	11 87       	std	Z+9, r17	; 0x09
    1940:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1942:	85 e0       	ldi	r24, 0x05	; 5
    1944:	90 e0       	ldi	r25, 0x00	; 0
    1946:	8c 1b       	sub	r24, r28
    1948:	91 09       	sbc	r25, r1
    194a:	95 87       	std	Z+13, r25	; 0x0d
    194c:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    194e:	13 8b       	std	Z+19, r17	; 0x13
    1950:	02 8b       	std	Z+18, r16	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    1952:	15 a2       	lds	r17, 0x95
    1954:	16 a2       	lds	r17, 0x96
    1956:	17 a2       	lds	r17, 0x97
    1958:	10 a6       	lds	r17, 0xb0
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    195a:	11 a6       	lds	r17, 0xb1
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    195c:	c1 01       	movw	r24, r2
    195e:	b3 01       	movw	r22, r6
    1960:	a2 01       	movw	r20, r4
    1962:	0e 94 84 05 	call	0xb08	; 0xb08 <pxPortInitialiseStack>
    1966:	f8 01       	movw	r30, r16
    1968:	91 83       	std	Z+1, r25	; 0x01
    196a:	80 83       	st	Z, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    196c:	81 14       	cp	r8, r1
    196e:	91 04       	cpc	r9, r1
    1970:	19 f0       	breq	.+6      	; 0x1978 <xTaskCreate+0xfa>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1972:	f4 01       	movw	r30, r8
    1974:	11 83       	std	Z+1, r17	; 0x01
    1976:	00 83       	st	Z, r16

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    1978:	0f b6       	in	r0, 0x3f	; 63
    197a:	f8 94       	cli
    197c:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    197e:	80 91 b7 03 	lds	r24, 0x03B7
    1982:	8f 5f       	subi	r24, 0xFF	; 255
    1984:	80 93 b7 03 	sts	0x03B7, r24
		if( pxCurrentTCB == NULL )
    1988:	80 91 ab 03 	lds	r24, 0x03AB
    198c:	90 91 ac 03 	lds	r25, 0x03AC
    1990:	00 97       	sbiw	r24, 0x00	; 0
    1992:	09 f0       	breq	.+2      	; 0x1996 <xTaskCreate+0x118>
    1994:	3f c0       	rjmp	.+126    	; 0x1a14 <xTaskCreate+0x196>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    1996:	10 93 ac 03 	sts	0x03AC, r17
    199a:	00 93 ab 03 	sts	0x03AB, r16

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    199e:	80 91 b7 03 	lds	r24, 0x03B7
    19a2:	81 30       	cpi	r24, 0x01	; 1
    19a4:	09 f0       	breq	.+2      	; 0x19a8 <xTaskCreate+0x12a>
    19a6:	47 c0       	rjmp	.+142    	; 0x1a36 <xTaskCreate+0x1b8>
    19a8:	c0 e0       	ldi	r28, 0x00	; 0
    19aa:	d0 e0       	ldi	r29, 0x00	; 0
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    19ac:	ce 01       	movw	r24, r28
    19ae:	88 0f       	add	r24, r24
    19b0:	99 1f       	adc	r25, r25
    19b2:	88 0f       	add	r24, r24
    19b4:	99 1f       	adc	r25, r25
    19b6:	88 0f       	add	r24, r24
    19b8:	99 1f       	adc	r25, r25
    19ba:	8c 0f       	add	r24, r28
    19bc:	9d 1f       	adc	r25, r29
    19be:	82 54       	subi	r24, 0x42	; 66
    19c0:	9c 4f       	sbci	r25, 0xFC	; 252
    19c2:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInitialise>
    19c6:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    19c8:	c5 30       	cpi	r28, 0x05	; 5
    19ca:	d1 05       	cpc	r29, r1
    19cc:	79 f7       	brne	.-34     	; 0x19ac <xTaskCreate+0x12e>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    19ce:	cb ee       	ldi	r28, 0xEB	; 235
    19d0:	d3 e0       	ldi	r29, 0x03	; 3
    19d2:	ce 01       	movw	r24, r28
    19d4:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    19d8:	0f 2e       	mov	r0, r31
    19da:	f4 ef       	ldi	r31, 0xF4	; 244
    19dc:	af 2e       	mov	r10, r31
    19de:	f3 e0       	ldi	r31, 0x03	; 3
    19e0:	bf 2e       	mov	r11, r31
    19e2:	f0 2d       	mov	r31, r0
    19e4:	c5 01       	movw	r24, r10
    19e6:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    19ea:	8d ef       	ldi	r24, 0xFD	; 253
    19ec:	93 e0       	ldi	r25, 0x03	; 3
    19ee:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    19f2:	86 e0       	ldi	r24, 0x06	; 6
    19f4:	94 e0       	ldi	r25, 0x04	; 4
    19f6:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    19fa:	8f e0       	ldi	r24, 0x0F	; 15
    19fc:	94 e0       	ldi	r25, 0x04	; 4
    19fe:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1a02:	d0 93 bc 03 	sts	0x03BC, r29
    1a06:	c0 93 bb 03 	sts	0x03BB, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1a0a:	b0 92 ba 03 	sts	0x03BA, r11
    1a0e:	a0 92 b9 03 	sts	0x03B9, r10
    1a12:	11 c0       	rjmp	.+34     	; 0x1a36 <xTaskCreate+0x1b8>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    1a14:	80 91 b3 03 	lds	r24, 0x03B3
    1a18:	88 23       	and	r24, r24
    1a1a:	69 f4       	brne	.+26     	; 0x1a36 <xTaskCreate+0x1b8>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    1a1c:	e0 91 ab 03 	lds	r30, 0x03AB
    1a20:	f0 91 ac 03 	lds	r31, 0x03AC
    1a24:	96 89       	ldd	r25, Z+22	; 0x16
    1a26:	f8 01       	movw	r30, r16
    1a28:	86 89       	ldd	r24, Z+22	; 0x16
    1a2a:	89 17       	cp	r24, r25
    1a2c:	20 f0       	brcs	.+8      	; 0x1a36 <xTaskCreate+0x1b8>
				{
					pxCurrentTCB = pxNewTCB;
    1a2e:	10 93 ac 03 	sts	0x03AC, r17
    1a32:	00 93 ab 03 	sts	0x03AB, r16
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    1a36:	80 91 bd 03 	lds	r24, 0x03BD
    1a3a:	8f 5f       	subi	r24, 0xFF	; 255
    1a3c:	80 93 bd 03 	sts	0x03BD, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    1a40:	f8 01       	movw	r30, r16
    1a42:	86 89       	ldd	r24, Z+22	; 0x16
    1a44:	90 91 b4 03 	lds	r25, 0x03B4
    1a48:	98 17       	cp	r25, r24
    1a4a:	10 f4       	brcc	.+4      	; 0x1a50 <xTaskCreate+0x1d2>
    1a4c:	80 93 b4 03 	sts	0x03B4, r24
    1a50:	90 e0       	ldi	r25, 0x00	; 0
    1a52:	9c 01       	movw	r18, r24
    1a54:	22 0f       	add	r18, r18
    1a56:	33 1f       	adc	r19, r19
    1a58:	22 0f       	add	r18, r18
    1a5a:	33 1f       	adc	r19, r19
    1a5c:	22 0f       	add	r18, r18
    1a5e:	33 1f       	adc	r19, r19
    1a60:	82 0f       	add	r24, r18
    1a62:	93 1f       	adc	r25, r19
    1a64:	82 54       	subi	r24, 0x42	; 66
    1a66:	9c 4f       	sbci	r25, 0xFC	; 252
    1a68:	b7 01       	movw	r22, r14
    1a6a:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    1a6e:	0f 90       	pop	r0
    1a70:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    1a72:	80 91 b3 03 	lds	r24, 0x03B3
    1a76:	88 23       	and	r24, r24
    1a78:	79 f0       	breq	.+30     	; 0x1a98 <xTaskCreate+0x21a>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    1a7a:	e0 91 ab 03 	lds	r30, 0x03AB
    1a7e:	f0 91 ac 03 	lds	r31, 0x03AC
    1a82:	96 89       	ldd	r25, Z+22	; 0x16
    1a84:	f8 01       	movw	r30, r16
    1a86:	86 89       	ldd	r24, Z+22	; 0x16
    1a88:	98 17       	cp	r25, r24
    1a8a:	40 f4       	brcc	.+16     	; 0x1a9c <xTaskCreate+0x21e>
		{
			taskYIELD_IF_USING_PREEMPTION();
    1a8c:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    1a90:	81 e0       	ldi	r24, 0x01	; 1
    1a92:	05 c0       	rjmp	.+10     	; 0x1a9e <xTaskCreate+0x220>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1a94:	8f ef       	ldi	r24, 0xFF	; 255
    1a96:	03 c0       	rjmp	.+6      	; 0x1a9e <xTaskCreate+0x220>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    1a98:	81 e0       	ldi	r24, 0x01	; 1
    1a9a:	01 c0       	rjmp	.+2      	; 0x1a9e <xTaskCreate+0x220>
    1a9c:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
		}

		return xReturn;
	}
    1a9e:	df 91       	pop	r29
    1aa0:	cf 91       	pop	r28
    1aa2:	1f 91       	pop	r17
    1aa4:	0f 91       	pop	r16
    1aa6:	ff 90       	pop	r15
    1aa8:	ef 90       	pop	r14
    1aaa:	df 90       	pop	r13
    1aac:	bf 90       	pop	r11
    1aae:	af 90       	pop	r10
    1ab0:	9f 90       	pop	r9
    1ab2:	8f 90       	pop	r8
    1ab4:	7f 90       	pop	r7
    1ab6:	6f 90       	pop	r6
    1ab8:	5f 90       	pop	r5
    1aba:	4f 90       	pop	r4
    1abc:	3f 90       	pop	r3
    1abe:	2f 90       	pop	r2
    1ac0:	08 95       	ret

00001ac2 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    1ac2:	0f 93       	push	r16
    1ac4:	1f 93       	push	r17
    1ac6:	cf 93       	push	r28
    1ac8:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    1aca:	0f b6       	in	r0, 0x3f	; 63
    1acc:	f8 94       	cli
    1ace:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    1ad0:	00 97       	sbiw	r24, 0x00	; 0
    1ad2:	29 f4       	brne	.+10     	; 0x1ade <vTaskDelete+0x1c>
    1ad4:	c0 91 ab 03 	lds	r28, 0x03AB
    1ad8:	d0 91 ac 03 	lds	r29, 0x03AC
    1adc:	01 c0       	rjmp	.+2      	; 0x1ae0 <vTaskDelete+0x1e>
    1ade:	ec 01       	movw	r28, r24

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1ae0:	8e 01       	movw	r16, r28
    1ae2:	0e 5f       	subi	r16, 0xFE	; 254
    1ae4:	1f 4f       	sbci	r17, 0xFF	; 255
    1ae6:	c8 01       	movw	r24, r16
    1ae8:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1aec:	8c 89       	ldd	r24, Y+20	; 0x14
    1aee:	9d 89       	ldd	r25, Y+21	; 0x15
    1af0:	00 97       	sbiw	r24, 0x00	; 0
    1af2:	21 f0       	breq	.+8      	; 0x1afc <vTaskDelete+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1af4:	ce 01       	movw	r24, r28
    1af6:	0c 96       	adiw	r24, 0x0c	; 12
    1af8:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    1afc:	80 91 bd 03 	lds	r24, 0x03BD
    1b00:	8f 5f       	subi	r24, 0xFF	; 255
    1b02:	80 93 bd 03 	sts	0x03BD, r24

			if( pxTCB == pxCurrentTCB )
    1b06:	80 91 ab 03 	lds	r24, 0x03AB
    1b0a:	90 91 ac 03 	lds	r25, 0x03AC
    1b0e:	c8 17       	cp	r28, r24
    1b10:	d9 07       	cpc	r29, r25
    1b12:	59 f4       	brne	.+22     	; 0x1b2a <vTaskDelete+0x68>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    1b14:	86 e0       	ldi	r24, 0x06	; 6
    1b16:	94 e0       	ldi	r25, 0x04	; 4
    1b18:	b8 01       	movw	r22, r16
    1b1a:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    1b1e:	80 91 b8 03 	lds	r24, 0x03B8
    1b22:	8f 5f       	subi	r24, 0xFF	; 255
    1b24:	80 93 b8 03 	sts	0x03B8, r24
    1b28:	0a c0       	rjmp	.+20     	; 0x1b3e <vTaskDelete+0x7c>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    1b2a:	80 91 b7 03 	lds	r24, 0x03B7
    1b2e:	81 50       	subi	r24, 0x01	; 1
    1b30:	80 93 b7 03 	sts	0x03B7, r24
				prvDeleteTCB( pxTCB );
    1b34:	ce 01       	movw	r24, r28
    1b36:	0e 94 32 0c 	call	0x1864	; 0x1864 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    1b3a:	0e 94 bb 0b 	call	0x1776	; 0x1776 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1b3e:	0f 90       	pop	r0
    1b40:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    1b42:	80 91 b3 03 	lds	r24, 0x03B3
    1b46:	88 23       	and	r24, r24
    1b48:	49 f0       	breq	.+18     	; 0x1b5c <vTaskDelete+0x9a>
		{
			if( pxTCB == pxCurrentTCB )
    1b4a:	80 91 ab 03 	lds	r24, 0x03AB
    1b4e:	90 91 ac 03 	lds	r25, 0x03AC
    1b52:	c8 17       	cp	r28, r24
    1b54:	d9 07       	cpc	r29, r25
    1b56:	11 f4       	brne	.+4      	; 0x1b5c <vTaskDelete+0x9a>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    1b58:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    1b5c:	df 91       	pop	r29
    1b5e:	cf 91       	pop	r28
    1b60:	1f 91       	pop	r17
    1b62:	0f 91       	pop	r16
    1b64:	08 95       	ret

00001b66 <uxTaskPriorityGet>:
	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    1b66:	0f b6       	in	r0, 0x3f	; 63
    1b68:	f8 94       	cli
    1b6a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1b6c:	00 97       	sbiw	r24, 0x00	; 0
    1b6e:	29 f4       	brne	.+10     	; 0x1b7a <uxTaskPriorityGet+0x14>
    1b70:	e0 91 ab 03 	lds	r30, 0x03AB
    1b74:	f0 91 ac 03 	lds	r31, 0x03AC
    1b78:	01 c0       	rjmp	.+2      	; 0x1b7c <uxTaskPriorityGet+0x16>
    1b7a:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    1b7c:	0f 90       	pop	r0
    1b7e:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    1b80:	86 89       	ldd	r24, Z+22	; 0x16
    1b82:	08 95       	ret

00001b84 <uxTaskPriorityGetFromISR>:

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1b84:	00 97       	sbiw	r24, 0x00	; 0
    1b86:	29 f4       	brne	.+10     	; 0x1b92 <uxTaskPriorityGetFromISR+0xe>
    1b88:	e0 91 ab 03 	lds	r30, 0x03AB
    1b8c:	f0 91 ac 03 	lds	r31, 0x03AC
    1b90:	01 c0       	rjmp	.+2      	; 0x1b94 <uxTaskPriorityGetFromISR+0x10>
    1b92:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
	}
    1b94:	86 89       	ldd	r24, Z+22	; 0x16
    1b96:	08 95       	ret

00001b98 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    1b98:	ef 92       	push	r14
    1b9a:	ff 92       	push	r15
    1b9c:	1f 93       	push	r17
    1b9e:	cf 93       	push	r28
    1ba0:	df 93       	push	r29
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    1ba2:	65 30       	cpi	r22, 0x05	; 5
    1ba4:	08 f0       	brcs	.+2      	; 0x1ba8 <vTaskPrioritySet+0x10>
    1ba6:	64 e0       	ldi	r22, 0x04	; 4
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    1ba8:	0f b6       	in	r0, 0x3f	; 63
    1baa:	f8 94       	cli
    1bac:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1bae:	00 97       	sbiw	r24, 0x00	; 0
    1bb0:	29 f4       	brne	.+10     	; 0x1bbc <vTaskPrioritySet+0x24>
    1bb2:	c0 91 ab 03 	lds	r28, 0x03AB
    1bb6:	d0 91 ac 03 	lds	r29, 0x03AC
    1bba:	01 c0       	rjmp	.+2      	; 0x1bbe <vTaskPrioritySet+0x26>
    1bbc:	ec 01       	movw	r28, r24

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    1bbe:	2b a1       	lds	r18, 0x4b
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    1bc0:	26 17       	cp	r18, r22
    1bc2:	09 f4       	brne	.+2      	; 0x1bc6 <vTaskPrioritySet+0x2e>
    1bc4:	61 c0       	rjmp	.+194    	; 0x1c88 <vTaskPrioritySet+0xf0>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    1bc6:	26 17       	cp	r18, r22
    1bc8:	88 f4       	brcc	.+34     	; 0x1bec <vTaskPrioritySet+0x54>
				{
					if( pxTCB != pxCurrentTCB )
    1bca:	80 91 ab 03 	lds	r24, 0x03AB
    1bce:	90 91 ac 03 	lds	r25, 0x03AC
    1bd2:	c8 17       	cp	r28, r24
    1bd4:	d9 07       	cpc	r29, r25
    1bd6:	a1 f0       	breq	.+40     	; 0x1c00 <vTaskPrioritySet+0x68>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    1bd8:	e0 91 ab 03 	lds	r30, 0x03AB
    1bdc:	f0 91 ac 03 	lds	r31, 0x03AC
						{
							xYieldRequired = pdTRUE;
    1be0:	11 e0       	ldi	r17, 0x01	; 1
    1be2:	86 89       	ldd	r24, Z+22	; 0x16
    1be4:	68 17       	cp	r22, r24
    1be6:	68 f4       	brcc	.+26     	; 0x1c02 <vTaskPrioritySet+0x6a>
    1be8:	10 e0       	ldi	r17, 0x00	; 0
    1bea:	0b c0       	rjmp	.+22     	; 0x1c02 <vTaskPrioritySet+0x6a>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    1bec:	80 91 ab 03 	lds	r24, 0x03AB
    1bf0:	90 91 ac 03 	lds	r25, 0x03AC
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
						{
							xYieldRequired = pdTRUE;
    1bf4:	11 e0       	ldi	r17, 0x01	; 1
    1bf6:	c8 17       	cp	r28, r24
    1bf8:	d9 07       	cpc	r29, r25
    1bfa:	19 f0       	breq	.+6      	; 0x1c02 <vTaskPrioritySet+0x6a>
    1bfc:	10 e0       	ldi	r17, 0x00	; 0
    1bfe:	01 c0       	rjmp	.+2      	; 0x1c02 <vTaskPrioritySet+0x6a>

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    1c00:	10 e0       	ldi	r17, 0x00	; 0
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    1c02:	8e 89       	ldd	r24, Y+22	; 0x16

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    1c04:	28 17       	cp	r18, r24
    1c06:	09 f4       	brne	.+2      	; 0x1c0a <vTaskPrioritySet+0x72>
					{
						pxTCB->uxPriority = uxNewPriority;
    1c08:	6e 8b       	std	Y+22, r22	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    1c0a:	6b a3       	lds	r22, 0x5b
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1c0c:	2c 85       	ldd	r18, Y+12	; 0x0c
    1c0e:	3d 85       	ldd	r19, Y+13	; 0x0d
    1c10:	33 23       	and	r19, r19
    1c12:	34 f0       	brlt	.+12     	; 0x1c20 <vTaskPrioritySet+0x88>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1c14:	25 e0       	ldi	r18, 0x05	; 5
    1c16:	30 e0       	ldi	r19, 0x00	; 0
    1c18:	26 1b       	sub	r18, r22
    1c1a:	31 09       	sbc	r19, r1
    1c1c:	3d 87       	std	Y+13, r19	; 0x0d
    1c1e:	2c 87       	std	Y+12, r18	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    1c20:	90 e0       	ldi	r25, 0x00	; 0
    1c22:	9c 01       	movw	r18, r24
    1c24:	22 0f       	add	r18, r18
    1c26:	33 1f       	adc	r19, r19
    1c28:	22 0f       	add	r18, r18
    1c2a:	33 1f       	adc	r19, r19
    1c2c:	22 0f       	add	r18, r18
    1c2e:	33 1f       	adc	r19, r19
    1c30:	82 0f       	add	r24, r18
    1c32:	93 1f       	adc	r25, r19
    1c34:	82 54       	subi	r24, 0x42	; 66
    1c36:	9c 4f       	sbci	r25, 0xFC	; 252
    1c38:	2a 85       	ldd	r18, Y+10	; 0x0a
    1c3a:	3b 85       	ldd	r19, Y+11	; 0x0b
    1c3c:	28 17       	cp	r18, r24
    1c3e:	39 07       	cpc	r19, r25
    1c40:	f9 f4       	brne	.+62     	; 0x1c80 <vTaskPrioritySet+0xe8>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1c42:	ee 24       	eor	r14, r14
    1c44:	ff 24       	eor	r15, r15
    1c46:	68 94       	set
    1c48:	e1 f8       	bld	r14, 1
    1c4a:	ec 0e       	add	r14, r28
    1c4c:	fd 1e       	adc	r15, r29
    1c4e:	c7 01       	movw	r24, r14
    1c50:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    1c54:	8e 89       	ldd	r24, Y+22	; 0x16
    1c56:	90 91 b4 03 	lds	r25, 0x03B4
    1c5a:	98 17       	cp	r25, r24
    1c5c:	10 f4       	brcc	.+4      	; 0x1c62 <vTaskPrioritySet+0xca>
    1c5e:	80 93 b4 03 	sts	0x03B4, r24
    1c62:	90 e0       	ldi	r25, 0x00	; 0
    1c64:	9c 01       	movw	r18, r24
    1c66:	22 0f       	add	r18, r18
    1c68:	33 1f       	adc	r19, r19
    1c6a:	22 0f       	add	r18, r18
    1c6c:	33 1f       	adc	r19, r19
    1c6e:	22 0f       	add	r18, r18
    1c70:	33 1f       	adc	r19, r19
    1c72:	82 0f       	add	r24, r18
    1c74:	93 1f       	adc	r25, r19
    1c76:	82 54       	subi	r24, 0x42	; 66
    1c78:	9c 4f       	sbci	r25, 0xFC	; 252
    1c7a:	b7 01       	movw	r22, r14
    1c7c:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    1c80:	11 23       	and	r17, r17
    1c82:	11 f0       	breq	.+4      	; 0x1c88 <vTaskPrioritySet+0xf0>
				{
					taskYIELD_IF_USING_PREEMPTION();
    1c84:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    1c88:	0f 90       	pop	r0
    1c8a:	0f be       	out	0x3f, r0	; 63
	}
    1c8c:	df 91       	pop	r29
    1c8e:	cf 91       	pop	r28
    1c90:	1f 91       	pop	r17
    1c92:	ff 90       	pop	r15
    1c94:	ef 90       	pop	r14
    1c96:	08 95       	ret

00001c98 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    1c98:	0f 93       	push	r16
    1c9a:	1f 93       	push	r17
    1c9c:	cf 93       	push	r28
    1c9e:	df 93       	push	r29
    1ca0:	ec 01       	movw	r28, r24
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    1ca2:	00 97       	sbiw	r24, 0x00	; 0
    1ca4:	b9 f1       	breq	.+110    	; 0x1d14 <vTaskResume+0x7c>
    1ca6:	80 91 ab 03 	lds	r24, 0x03AB
    1caa:	90 91 ac 03 	lds	r25, 0x03AC
    1cae:	c8 17       	cp	r28, r24
    1cb0:	d9 07       	cpc	r29, r25
    1cb2:	81 f1       	breq	.+96     	; 0x1d14 <vTaskResume+0x7c>
		{
			taskENTER_CRITICAL();
    1cb4:	0f b6       	in	r0, 0x3f	; 63
    1cb6:	f8 94       	cli
    1cb8:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    1cba:	ce 01       	movw	r24, r28
    1cbc:	0e 94 a4 0b 	call	0x1748	; 0x1748 <prvTaskIsTaskSuspended>
    1cc0:	88 23       	and	r24, r24
    1cc2:	31 f1       	breq	.+76     	; 0x1d10 <vTaskResume+0x78>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    1cc4:	8e 01       	movw	r16, r28
    1cc6:	0e 5f       	subi	r16, 0xFE	; 254
    1cc8:	1f 4f       	sbci	r17, 0xFF	; 255
    1cca:	c8 01       	movw	r24, r16
    1ccc:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1cd0:	8e 89       	ldd	r24, Y+22	; 0x16
    1cd2:	90 91 b4 03 	lds	r25, 0x03B4
    1cd6:	98 17       	cp	r25, r24
    1cd8:	10 f4       	brcc	.+4      	; 0x1cde <vTaskResume+0x46>
    1cda:	80 93 b4 03 	sts	0x03B4, r24
    1cde:	90 e0       	ldi	r25, 0x00	; 0
    1ce0:	9c 01       	movw	r18, r24
    1ce2:	22 0f       	add	r18, r18
    1ce4:	33 1f       	adc	r19, r19
    1ce6:	22 0f       	add	r18, r18
    1ce8:	33 1f       	adc	r19, r19
    1cea:	22 0f       	add	r18, r18
    1cec:	33 1f       	adc	r19, r19
    1cee:	82 0f       	add	r24, r18
    1cf0:	93 1f       	adc	r25, r19
    1cf2:	82 54       	subi	r24, 0x42	; 66
    1cf4:	9c 4f       	sbci	r25, 0xFC	; 252
    1cf6:	b8 01       	movw	r22, r16
    1cf8:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1cfc:	e0 91 ab 03 	lds	r30, 0x03AB
    1d00:	f0 91 ac 03 	lds	r31, 0x03AC
    1d04:	9e 89       	ldd	r25, Y+22	; 0x16
    1d06:	86 89       	ldd	r24, Z+22	; 0x16
    1d08:	98 17       	cp	r25, r24
    1d0a:	10 f0       	brcs	.+4      	; 0x1d10 <vTaskResume+0x78>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    1d0c:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    1d10:	0f 90       	pop	r0
    1d12:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1d14:	df 91       	pop	r29
    1d16:	cf 91       	pop	r28
    1d18:	1f 91       	pop	r17
    1d1a:	0f 91       	pop	r16
    1d1c:	08 95       	ret

00001d1e <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    1d1e:	ef 92       	push	r14
    1d20:	ff 92       	push	r15
    1d22:	1f 93       	push	r17
    1d24:	cf 93       	push	r28
    1d26:	df 93       	push	r29
    1d28:	ec 01       	movw	r28, r24
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    1d2a:	0e 94 a4 0b 	call	0x1748	; 0x1748 <prvTaskIsTaskSuspended>
    1d2e:	88 23       	and	r24, r24
    1d30:	b9 f1       	breq	.+110    	; 0x1da0 <xTaskResumeFromISR+0x82>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1d32:	80 91 ad 03 	lds	r24, 0x03AD
    1d36:	88 23       	and	r24, r24
    1d38:	51 f5       	brne	.+84     	; 0x1d8e <xTaskResumeFromISR+0x70>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1d3a:	e0 91 ab 03 	lds	r30, 0x03AB
    1d3e:	f0 91 ac 03 	lds	r31, 0x03AC

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
    1d42:	11 e0       	ldi	r17, 0x01	; 1
    1d44:	9e 89       	ldd	r25, Y+22	; 0x16
    1d46:	86 89       	ldd	r24, Z+22	; 0x16
    1d48:	98 17       	cp	r25, r24
    1d4a:	08 f4       	brcc	.+2      	; 0x1d4e <xTaskResumeFromISR+0x30>
    1d4c:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1d4e:	ee 24       	eor	r14, r14
    1d50:	ff 24       	eor	r15, r15
    1d52:	68 94       	set
    1d54:	e1 f8       	bld	r14, 1
    1d56:	ec 0e       	add	r14, r28
    1d58:	fd 1e       	adc	r15, r29
    1d5a:	c7 01       	movw	r24, r14
    1d5c:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1d60:	8e 89       	ldd	r24, Y+22	; 0x16
    1d62:	90 91 b4 03 	lds	r25, 0x03B4
    1d66:	98 17       	cp	r25, r24
    1d68:	10 f4       	brcc	.+4      	; 0x1d6e <xTaskResumeFromISR+0x50>
    1d6a:	80 93 b4 03 	sts	0x03B4, r24
    1d6e:	90 e0       	ldi	r25, 0x00	; 0
    1d70:	9c 01       	movw	r18, r24
    1d72:	22 0f       	add	r18, r18
    1d74:	33 1f       	adc	r19, r19
    1d76:	22 0f       	add	r18, r18
    1d78:	33 1f       	adc	r19, r19
    1d7a:	22 0f       	add	r18, r18
    1d7c:	33 1f       	adc	r19, r19
    1d7e:	82 0f       	add	r24, r18
    1d80:	93 1f       	adc	r25, r19
    1d82:	82 54       	subi	r24, 0x42	; 66
    1d84:	9c 4f       	sbci	r25, 0xFC	; 252
    1d86:	b7 01       	movw	r22, r14
    1d88:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>
    1d8c:	0a c0       	rjmp	.+20     	; 0x1da2 <xTaskResumeFromISR+0x84>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1d8e:	be 01       	movw	r22, r28
    1d90:	64 5f       	subi	r22, 0xF4	; 244
    1d92:	7f 4f       	sbci	r23, 0xFF	; 255
    1d94:	8d ef       	ldi	r24, 0xFD	; 253
    1d96:	93 e0       	ldi	r25, 0x03	; 3
    1d98:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
    1d9c:	10 e0       	ldi	r17, 0x00	; 0
    1d9e:	01 c0       	rjmp	.+2      	; 0x1da2 <xTaskResumeFromISR+0x84>
    1da0:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
    1da2:	81 2f       	mov	r24, r17
    1da4:	df 91       	pop	r29
    1da6:	cf 91       	pop	r28
    1da8:	1f 91       	pop	r17
    1daa:	ff 90       	pop	r15
    1dac:	ef 90       	pop	r14
    1dae:	08 95       	ret

00001db0 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    1db0:	ef 92       	push	r14
    1db2:	ff 92       	push	r15
    1db4:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    1db6:	8d e4       	ldi	r24, 0x4D	; 77
    1db8:	90 e1       	ldi	r25, 0x10	; 16
    1dba:	6b e7       	ldi	r22, 0x7B	; 123
    1dbc:	70 e0       	ldi	r23, 0x00	; 0
    1dbe:	48 ec       	ldi	r20, 0xC8	; 200
    1dc0:	50 e0       	ldi	r21, 0x00	; 0
    1dc2:	20 e0       	ldi	r18, 0x00	; 0
    1dc4:	30 e0       	ldi	r19, 0x00	; 0
    1dc6:	00 e0       	ldi	r16, 0x00	; 0
    1dc8:	0f 2e       	mov	r0, r31
    1dca:	f8 e1       	ldi	r31, 0x18	; 24
    1dcc:	ef 2e       	mov	r14, r31
    1dce:	f4 e0       	ldi	r31, 0x04	; 4
    1dd0:	ff 2e       	mov	r15, r31
    1dd2:	f0 2d       	mov	r31, r0
    1dd4:	0e 94 3f 0c 	call	0x187e	; 0x187e <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    1dd8:	81 30       	cpi	r24, 0x01	; 1
    1dda:	81 f4       	brne	.+32     	; 0x1dfc <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    1ddc:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    1dde:	8f ef       	ldi	r24, 0xFF	; 255
    1de0:	9f ef       	ldi	r25, 0xFF	; 255
    1de2:	90 93 af 03 	sts	0x03AF, r25
    1de6:	80 93 ae 03 	sts	0x03AE, r24
		xSchedulerRunning = pdTRUE;
    1dea:	81 e0       	ldi	r24, 0x01	; 1
    1dec:	80 93 b3 03 	sts	0x03B3, r24
		xTickCount = ( TickType_t ) 0U;
    1df0:	10 92 b6 03 	sts	0x03B6, r1
    1df4:	10 92 b5 03 	sts	0x03B5, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1df8:	0e 94 14 06 	call	0xc28	; 0xc28 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    1dfc:	0f 91       	pop	r16
    1dfe:	ff 90       	pop	r15
    1e00:	ef 90       	pop	r14
    1e02:	08 95       	ret

00001e04 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1e04:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1e06:	10 92 b3 03 	sts	0x03B3, r1
	vPortEndScheduler();
    1e0a:	0e 94 49 06 	call	0xc92	; 0xc92 <vPortEndScheduler>
}
    1e0e:	08 95       	ret

00001e10 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    1e10:	80 91 ad 03 	lds	r24, 0x03AD
    1e14:	8f 5f       	subi	r24, 0xFF	; 255
    1e16:	80 93 ad 03 	sts	0x03AD, r24
}
    1e1a:	08 95       	ret

00001e1c <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    1e1c:	0f b6       	in	r0, 0x3f	; 63
    1e1e:	f8 94       	cli
    1e20:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1e22:	80 91 b5 03 	lds	r24, 0x03B5
    1e26:	90 91 b6 03 	lds	r25, 0x03B6
	}
	portTICK_TYPE_EXIT_CRITICAL();
    1e2a:	0f 90       	pop	r0
    1e2c:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1e2e:	08 95       	ret

00001e30 <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    1e30:	80 91 b5 03 	lds	r24, 0x03B5
    1e34:	90 91 b6 03 	lds	r25, 0x03B6
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1e38:	08 95       	ret

00001e3a <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    1e3a:	80 91 b7 03 	lds	r24, 0x03B7
}
    1e3e:	08 95       	ret

00001e40 <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1e40:	00 97       	sbiw	r24, 0x00	; 0
    1e42:	21 f4       	brne	.+8      	; 0x1e4c <pcTaskGetName+0xc>
    1e44:	80 91 ab 03 	lds	r24, 0x03AB
    1e48:	90 91 ac 03 	lds	r25, 0x03AC
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    1e4c:	49 96       	adiw	r24, 0x19	; 25
}
    1e4e:	08 95       	ret

00001e50 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    1e50:	cf 92       	push	r12
    1e52:	df 92       	push	r13
    1e54:	ef 92       	push	r14
    1e56:	ff 92       	push	r15
    1e58:	0f 93       	push	r16
    1e5a:	1f 93       	push	r17
    1e5c:	cf 93       	push	r28
    1e5e:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1e60:	80 91 ad 03 	lds	r24, 0x03AD
    1e64:	88 23       	and	r24, r24
    1e66:	09 f0       	breq	.+2      	; 0x1e6a <xTaskIncrementTick+0x1a>
    1e68:	82 c0       	rjmp	.+260    	; 0x1f6e <xTaskIncrementTick+0x11e>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    1e6a:	c0 90 b5 03 	lds	r12, 0x03B5
    1e6e:	d0 90 b6 03 	lds	r13, 0x03B6
    1e72:	08 94       	sec
    1e74:	c1 1c       	adc	r12, r1
    1e76:	d1 1c       	adc	r13, r1

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    1e78:	d0 92 b6 03 	sts	0x03B6, r13
    1e7c:	c0 92 b5 03 	sts	0x03B5, r12

		if( xConstTickCount == ( TickType_t ) 0U )
    1e80:	c1 14       	cp	r12, r1
    1e82:	d1 04       	cpc	r13, r1
    1e84:	b9 f4       	brne	.+46     	; 0x1eb4 <xTaskIncrementTick+0x64>
		{
			taskSWITCH_DELAYED_LISTS();
    1e86:	80 91 bb 03 	lds	r24, 0x03BB
    1e8a:	90 91 bc 03 	lds	r25, 0x03BC
    1e8e:	20 91 b9 03 	lds	r18, 0x03B9
    1e92:	30 91 ba 03 	lds	r19, 0x03BA
    1e96:	30 93 bc 03 	sts	0x03BC, r19
    1e9a:	20 93 bb 03 	sts	0x03BB, r18
    1e9e:	90 93 ba 03 	sts	0x03BA, r25
    1ea2:	80 93 b9 03 	sts	0x03B9, r24
    1ea6:	80 91 b0 03 	lds	r24, 0x03B0
    1eaa:	8f 5f       	subi	r24, 0xFF	; 255
    1eac:	80 93 b0 03 	sts	0x03B0, r24
    1eb0:	0e 94 bb 0b 	call	0x1776	; 0x1776 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    1eb4:	80 91 ae 03 	lds	r24, 0x03AE
    1eb8:	90 91 af 03 	lds	r25, 0x03AF
    1ebc:	c8 16       	cp	r12, r24
    1ebe:	d9 06       	cpc	r13, r25
    1ec0:	20 f4       	brcc	.+8      	; 0x1eca <xTaskIncrementTick+0x7a>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    1ec2:	ff 24       	eor	r15, r15
    1ec4:	5a c0       	rjmp	.+180    	; 0x1f7a <xTaskIncrementTick+0x12a>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    1ec6:	fe 2c       	mov	r15, r14
    1ec8:	03 c0       	rjmp	.+6      	; 0x1ed0 <xTaskIncrementTick+0x80>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    1eca:	ff 24       	eor	r15, r15
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    1ecc:	ee 24       	eor	r14, r14
    1ece:	e3 94       	inc	r14
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1ed0:	e0 91 bb 03 	lds	r30, 0x03BB
    1ed4:	f0 91 bc 03 	lds	r31, 0x03BC
    1ed8:	80 81       	ld	r24, Z
    1eda:	88 23       	and	r24, r24
    1edc:	39 f4       	brne	.+14     	; 0x1eec <xTaskIncrementTick+0x9c>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1ede:	8f ef       	ldi	r24, 0xFF	; 255
    1ee0:	9f ef       	ldi	r25, 0xFF	; 255
    1ee2:	90 93 af 03 	sts	0x03AF, r25
    1ee6:	80 93 ae 03 	sts	0x03AE, r24
					break;
    1eea:	47 c0       	rjmp	.+142    	; 0x1f7a <xTaskIncrementTick+0x12a>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1eec:	e0 91 bb 03 	lds	r30, 0x03BB
    1ef0:	f0 91 bc 03 	lds	r31, 0x03BC
    1ef4:	05 80       	ldd	r0, Z+5	; 0x05
    1ef6:	f6 81       	ldd	r31, Z+6	; 0x06
    1ef8:	e0 2d       	mov	r30, r0
    1efa:	c6 81       	ldd	r28, Z+6	; 0x06
    1efc:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    1efe:	8a 81       	ldd	r24, Y+2	; 0x02
    1f00:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
    1f02:	c8 16       	cp	r12, r24
    1f04:	d9 06       	cpc	r13, r25
    1f06:	28 f4       	brcc	.+10     	; 0x1f12 <xTaskIncrementTick+0xc2>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    1f08:	90 93 af 03 	sts	0x03AF, r25
    1f0c:	80 93 ae 03 	sts	0x03AE, r24
						break;
    1f10:	34 c0       	rjmp	.+104    	; 0x1f7a <xTaskIncrementTick+0x12a>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1f12:	8e 01       	movw	r16, r28
    1f14:	0e 5f       	subi	r16, 0xFE	; 254
    1f16:	1f 4f       	sbci	r17, 0xFF	; 255
    1f18:	c8 01       	movw	r24, r16
    1f1a:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1f1e:	8c 89       	ldd	r24, Y+20	; 0x14
    1f20:	9d 89       	ldd	r25, Y+21	; 0x15
    1f22:	00 97       	sbiw	r24, 0x00	; 0
    1f24:	21 f0       	breq	.+8      	; 0x1f2e <xTaskIncrementTick+0xde>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1f26:	ce 01       	movw	r24, r28
    1f28:	0c 96       	adiw	r24, 0x0c	; 12
    1f2a:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    1f2e:	8e 89       	ldd	r24, Y+22	; 0x16
    1f30:	90 91 b4 03 	lds	r25, 0x03B4
    1f34:	98 17       	cp	r25, r24
    1f36:	10 f4       	brcc	.+4      	; 0x1f3c <xTaskIncrementTick+0xec>
    1f38:	80 93 b4 03 	sts	0x03B4, r24
    1f3c:	90 e0       	ldi	r25, 0x00	; 0
    1f3e:	9c 01       	movw	r18, r24
    1f40:	22 0f       	add	r18, r18
    1f42:	33 1f       	adc	r19, r19
    1f44:	22 0f       	add	r18, r18
    1f46:	33 1f       	adc	r19, r19
    1f48:	22 0f       	add	r18, r18
    1f4a:	33 1f       	adc	r19, r19
    1f4c:	82 0f       	add	r24, r18
    1f4e:	93 1f       	adc	r25, r19
    1f50:	82 54       	subi	r24, 0x42	; 66
    1f52:	9c 4f       	sbci	r25, 0xFC	; 252
    1f54:	b8 01       	movw	r22, r16
    1f56:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1f5a:	e0 91 ab 03 	lds	r30, 0x03AB
    1f5e:	f0 91 ac 03 	lds	r31, 0x03AC
    1f62:	9e 89       	ldd	r25, Y+22	; 0x16
    1f64:	86 89       	ldd	r24, Z+22	; 0x16
    1f66:	98 17       	cp	r25, r24
    1f68:	08 f0       	brcs	.+2      	; 0x1f6c <xTaskIncrementTick+0x11c>
    1f6a:	ad cf       	rjmp	.-166    	; 0x1ec6 <xTaskIncrementTick+0x76>
    1f6c:	b1 cf       	rjmp	.-158    	; 0x1ed0 <xTaskIncrementTick+0x80>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    1f6e:	80 91 b2 03 	lds	r24, 0x03B2
    1f72:	8f 5f       	subi	r24, 0xFF	; 255
    1f74:	80 93 b2 03 	sts	0x03B2, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    1f78:	ff 24       	eor	r15, r15
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    1f7a:	80 91 b1 03 	lds	r24, 0x03B1
    1f7e:	88 23       	and	r24, r24
    1f80:	11 f0       	breq	.+4      	; 0x1f86 <xTaskIncrementTick+0x136>
		{
			xSwitchRequired = pdTRUE;
    1f82:	ff 24       	eor	r15, r15
    1f84:	f3 94       	inc	r15
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    1f86:	8f 2d       	mov	r24, r15
    1f88:	df 91       	pop	r29
    1f8a:	cf 91       	pop	r28
    1f8c:	1f 91       	pop	r17
    1f8e:	0f 91       	pop	r16
    1f90:	ff 90       	pop	r15
    1f92:	ef 90       	pop	r14
    1f94:	df 90       	pop	r13
    1f96:	cf 90       	pop	r12
    1f98:	08 95       	ret

00001f9a <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    1f9a:	df 92       	push	r13
    1f9c:	ef 92       	push	r14
    1f9e:	ff 92       	push	r15
    1fa0:	0f 93       	push	r16
    1fa2:	1f 93       	push	r17
    1fa4:	cf 93       	push	r28
    1fa6:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1fa8:	0f b6       	in	r0, 0x3f	; 63
    1faa:	f8 94       	cli
    1fac:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1fae:	80 91 ad 03 	lds	r24, 0x03AD
    1fb2:	81 50       	subi	r24, 0x01	; 1
    1fb4:	80 93 ad 03 	sts	0x03AD, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1fb8:	80 91 ad 03 	lds	r24, 0x03AD
    1fbc:	88 23       	and	r24, r24
    1fbe:	09 f0       	breq	.+2      	; 0x1fc2 <xTaskResumeAll+0x28>
    1fc0:	5f c0       	rjmp	.+190    	; 0x2080 <xTaskResumeAll+0xe6>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1fc2:	80 91 b7 03 	lds	r24, 0x03B7
    1fc6:	88 23       	and	r24, r24
    1fc8:	91 f5       	brne	.+100    	; 0x202e <xTaskResumeAll+0x94>
    1fca:	5d c0       	rjmp	.+186    	; 0x2086 <xTaskResumeAll+0xec>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    1fcc:	e0 91 02 04 	lds	r30, 0x0402
    1fd0:	f0 91 03 04 	lds	r31, 0x0403
    1fd4:	c6 81       	ldd	r28, Z+6	; 0x06
    1fd6:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1fd8:	ce 01       	movw	r24, r28
    1fda:	0c 96       	adiw	r24, 0x0c	; 12
    1fdc:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1fe0:	8e 01       	movw	r16, r28
    1fe2:	0e 5f       	subi	r16, 0xFE	; 254
    1fe4:	1f 4f       	sbci	r17, 0xFF	; 255
    1fe6:	c8 01       	movw	r24, r16
    1fe8:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1fec:	8e 89       	ldd	r24, Y+22	; 0x16
    1fee:	90 91 b4 03 	lds	r25, 0x03B4
    1ff2:	98 17       	cp	r25, r24
    1ff4:	10 f4       	brcc	.+4      	; 0x1ffa <xTaskResumeAll+0x60>
    1ff6:	80 93 b4 03 	sts	0x03B4, r24
    1ffa:	90 e0       	ldi	r25, 0x00	; 0
    1ffc:	9c 01       	movw	r18, r24
    1ffe:	22 0f       	add	r18, r18
    2000:	33 1f       	adc	r19, r19
    2002:	22 0f       	add	r18, r18
    2004:	33 1f       	adc	r19, r19
    2006:	22 0f       	add	r18, r18
    2008:	33 1f       	adc	r19, r19
    200a:	82 0f       	add	r24, r18
    200c:	93 1f       	adc	r25, r19
    200e:	82 54       	subi	r24, 0x42	; 66
    2010:	9c 4f       	sbci	r25, 0xFC	; 252
    2012:	b8 01       	movw	r22, r16
    2014:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2018:	e0 91 ab 03 	lds	r30, 0x03AB
    201c:	f0 91 ac 03 	lds	r31, 0x03AC
    2020:	9e 89       	ldd	r25, Y+22	; 0x16
    2022:	86 89       	ldd	r24, Z+22	; 0x16
    2024:	98 17       	cp	r25, r24
    2026:	68 f0       	brcs	.+26     	; 0x2042 <xTaskResumeAll+0xa8>
					{
						xYieldPending = pdTRUE;
    2028:	d0 92 b1 03 	sts	0x03B1, r13
    202c:	0a c0       	rjmp	.+20     	; 0x2042 <xTaskResumeAll+0xa8>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    202e:	c0 e0       	ldi	r28, 0x00	; 0
    2030:	d0 e0       	ldi	r29, 0x00	; 0
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    2032:	0f 2e       	mov	r0, r31
    2034:	fd ef       	ldi	r31, 0xFD	; 253
    2036:	ef 2e       	mov	r14, r31
    2038:	f3 e0       	ldi	r31, 0x03	; 3
    203a:	ff 2e       	mov	r15, r31
    203c:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    203e:	dd 24       	eor	r13, r13
    2040:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    2042:	f7 01       	movw	r30, r14
    2044:	80 81       	ld	r24, Z
    2046:	88 23       	and	r24, r24
    2048:	09 f6       	brne	.-126    	; 0x1fcc <xTaskResumeAll+0x32>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    204a:	20 97       	sbiw	r28, 0x00	; 0
    204c:	11 f0       	breq	.+4      	; 0x2052 <xTaskResumeAll+0xb8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    204e:	0e 94 bb 0b 	call	0x1776	; 0x1776 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    2052:	c0 91 b2 03 	lds	r28, 0x03B2

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    2056:	cc 23       	and	r28, r28
    2058:	59 f0       	breq	.+22     	; 0x2070 <xTaskResumeAll+0xd6>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
    205a:	01 e0       	ldi	r16, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    205c:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <xTaskIncrementTick>
    2060:	88 23       	and	r24, r24
    2062:	11 f0       	breq	.+4      	; 0x2068 <xTaskResumeAll+0xce>
							{
								xYieldPending = pdTRUE;
    2064:	00 93 b1 03 	sts	0x03B1, r16
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    2068:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    206a:	c1 f7       	brne	.-16     	; 0x205c <xTaskResumeAll+0xc2>

						uxPendedTicks = 0;
    206c:	10 92 b2 03 	sts	0x03B2, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    2070:	80 91 b1 03 	lds	r24, 0x03B1
    2074:	88 23       	and	r24, r24
    2076:	31 f0       	breq	.+12     	; 0x2084 <xTaskResumeAll+0xea>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    2078:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    207c:	81 e0       	ldi	r24, 0x01	; 1
    207e:	03 c0       	rjmp	.+6      	; 0x2086 <xTaskResumeAll+0xec>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
    2080:	80 e0       	ldi	r24, 0x00	; 0
    2082:	01 c0       	rjmp	.+2      	; 0x2086 <xTaskResumeAll+0xec>
    2084:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2086:	0f 90       	pop	r0
    2088:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    208a:	df 91       	pop	r29
    208c:	cf 91       	pop	r28
    208e:	1f 91       	pop	r17
    2090:	0f 91       	pop	r16
    2092:	ff 90       	pop	r15
    2094:	ef 90       	pop	r14
    2096:	df 90       	pop	r13
    2098:	08 95       	ret

0000209a <prvIdleTask>:
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    209a:	06 e0       	ldi	r16, 0x06	; 6
    209c:	14 e0       	ldi	r17, 0x04	; 4

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    209e:	0f 2e       	mov	r0, r31
    20a0:	fe eb       	ldi	r31, 0xBE	; 190
    20a2:	ef 2e       	mov	r14, r31
    20a4:	f3 e0       	ldi	r31, 0x03	; 3
    20a6:	ff 2e       	mov	r15, r31
    20a8:	f0 2d       	mov	r31, r0
    20aa:	24 c0       	rjmp	.+72     	; 0x20f4 <prvIdleTask+0x5a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    20ac:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    20b0:	f8 01       	movw	r30, r16
    20b2:	c0 81       	ld	r28, Z
			}
			( void ) xTaskResumeAll();
    20b4:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    20b8:	cc 23       	and	r28, r28
    20ba:	e1 f0       	breq	.+56     	; 0x20f4 <prvIdleTask+0x5a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    20bc:	0f b6       	in	r0, 0x3f	; 63
    20be:	f8 94       	cli
    20c0:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    20c2:	e0 91 0b 04 	lds	r30, 0x040B
    20c6:	f0 91 0c 04 	lds	r31, 0x040C
    20ca:	c6 81       	ldd	r28, Z+6	; 0x06
    20cc:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    20ce:	ce 01       	movw	r24, r28
    20d0:	02 96       	adiw	r24, 0x02	; 2
    20d2:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>
					--uxCurrentNumberOfTasks;
    20d6:	80 91 b7 03 	lds	r24, 0x03B7
    20da:	81 50       	subi	r24, 0x01	; 1
    20dc:	80 93 b7 03 	sts	0x03B7, r24
					--uxDeletedTasksWaitingCleanUp;
    20e0:	80 91 b8 03 	lds	r24, 0x03B8
    20e4:	81 50       	subi	r24, 0x01	; 1
    20e6:	80 93 b8 03 	sts	0x03B8, r24
				}
				taskEXIT_CRITICAL();
    20ea:	0f 90       	pop	r0
    20ec:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    20ee:	ce 01       	movw	r24, r28
    20f0:	0e 94 32 0c 	call	0x1864	; 0x1864 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    20f4:	80 91 b8 03 	lds	r24, 0x03B8
    20f8:	88 23       	and	r24, r24
    20fa:	c1 f6       	brne	.-80     	; 0x20ac <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    20fc:	f7 01       	movw	r30, r14
    20fe:	80 81       	ld	r24, Z
    2100:	82 30       	cpi	r24, 0x02	; 2
    2102:	c0 f3       	brcs	.-16     	; 0x20f4 <prvIdleTask+0x5a>
			{
				taskYIELD();
    2104:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>
    2108:	f5 cf       	rjmp	.-22     	; 0x20f4 <prvIdleTask+0x5a>

0000210a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    210a:	cf 93       	push	r28
    210c:	df 93       	push	r29
    210e:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2110:	00 97       	sbiw	r24, 0x00	; 0
    2112:	51 f0       	breq	.+20     	; 0x2128 <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2114:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    2118:	ce 01       	movw	r24, r28
    211a:	60 e0       	ldi	r22, 0x00	; 0
    211c:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2120:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2124:	88 23       	and	r24, r24
    2126:	11 f4       	brne	.+4      	; 0x212c <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
    2128:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    212c:	df 91       	pop	r29
    212e:	cf 91       	pop	r28
    2130:	08 95       	ret

00002132 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    2132:	0f 93       	push	r16
    2134:	1f 93       	push	r17
    2136:	cf 93       	push	r28
    2138:	df 93       	push	r29
    213a:	8c 01       	movw	r16, r24
    213c:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    213e:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2142:	80 91 b5 03 	lds	r24, 0x03B5
    2146:	90 91 b6 03 	lds	r25, 0x03B6

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    214a:	f8 01       	movw	r30, r16
    214c:	20 81       	ld	r18, Z
    214e:	31 81       	ldd	r19, Z+1	; 0x01
    2150:	c2 0f       	add	r28, r18
    2152:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
    2154:	82 17       	cp	r24, r18
    2156:	93 07       	cpc	r25, r19
    2158:	48 f4       	brcc	.+18     	; 0x216c <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    215a:	c2 17       	cp	r28, r18
    215c:	d3 07       	cpc	r29, r19
    215e:	f8 f4       	brcc	.+62     	; 0x219e <vTaskDelayUntil+0x6c>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2160:	d1 83       	std	Z+1, r29	; 0x01
    2162:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    2164:	8c 17       	cp	r24, r28
    2166:	9d 07       	cpc	r25, r29
    2168:	78 f4       	brcc	.+30     	; 0x2188 <vTaskDelayUntil+0x56>
    216a:	07 c0       	rjmp	.+14     	; 0x217a <vTaskDelayUntil+0x48>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    216c:	c2 17       	cp	r28, r18
    216e:	d3 07       	cpc	r29, r19
    2170:	90 f0       	brcs	.+36     	; 0x2196 <vTaskDelayUntil+0x64>
    2172:	8c 17       	cp	r24, r28
    2174:	9d 07       	cpc	r25, r29
    2176:	78 f0       	brcs	.+30     	; 0x2196 <vTaskDelayUntil+0x64>
    2178:	12 c0       	rjmp	.+36     	; 0x219e <vTaskDelayUntil+0x6c>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    217a:	9e 01       	movw	r18, r28
    217c:	28 1b       	sub	r18, r24
    217e:	39 0b       	sbc	r19, r25
    2180:	c9 01       	movw	r24, r18
    2182:	60 e0       	ldi	r22, 0x00	; 0
    2184:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2188:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    218c:	88 23       	and	r24, r24
    218e:	59 f4       	brne	.+22     	; 0x21a6 <vTaskDelayUntil+0x74>
		{
			portYIELD_WITHIN_API();
    2190:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>
    2194:	08 c0       	rjmp	.+16     	; 0x21a6 <vTaskDelayUntil+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2196:	f8 01       	movw	r30, r16
    2198:	d1 83       	std	Z+1, r29	; 0x01
    219a:	c0 83       	st	Z, r28
    219c:	ee cf       	rjmp	.-36     	; 0x217a <vTaskDelayUntil+0x48>
    219e:	f8 01       	movw	r30, r16
    21a0:	d1 83       	std	Z+1, r29	; 0x01
    21a2:	c0 83       	st	Z, r28
    21a4:	f1 cf       	rjmp	.-30     	; 0x2188 <vTaskDelayUntil+0x56>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    21a6:	df 91       	pop	r29
    21a8:	cf 91       	pop	r28
    21aa:	1f 91       	pop	r17
    21ac:	0f 91       	pop	r16
    21ae:	08 95       	ret

000021b0 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    21b0:	80 91 ad 03 	lds	r24, 0x03AD
    21b4:	88 23       	and	r24, r24
    21b6:	21 f0       	breq	.+8      	; 0x21c0 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    21b8:	81 e0       	ldi	r24, 0x01	; 1
    21ba:	80 93 b1 03 	sts	0x03B1, r24
    21be:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    21c0:	10 92 b1 03 	sts	0x03B1, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    21c4:	20 91 b4 03 	lds	r18, 0x03B4
    21c8:	82 2f       	mov	r24, r18
    21ca:	90 e0       	ldi	r25, 0x00	; 0
    21cc:	fc 01       	movw	r30, r24
    21ce:	ee 0f       	add	r30, r30
    21d0:	ff 1f       	adc	r31, r31
    21d2:	ee 0f       	add	r30, r30
    21d4:	ff 1f       	adc	r31, r31
    21d6:	ee 0f       	add	r30, r30
    21d8:	ff 1f       	adc	r31, r31
    21da:	e8 0f       	add	r30, r24
    21dc:	f9 1f       	adc	r31, r25
    21de:	e2 54       	subi	r30, 0x42	; 66
    21e0:	fc 4f       	sbci	r31, 0xFC	; 252
    21e2:	30 81       	ld	r19, Z
    21e4:	33 23       	and	r19, r19
    21e6:	89 f4       	brne	.+34     	; 0x220a <vTaskSwitchContext+0x5a>
    21e8:	21 50       	subi	r18, 0x01	; 1
    21ea:	82 2f       	mov	r24, r18
    21ec:	90 e0       	ldi	r25, 0x00	; 0
    21ee:	fc 01       	movw	r30, r24
    21f0:	ee 0f       	add	r30, r30
    21f2:	ff 1f       	adc	r31, r31
    21f4:	ee 0f       	add	r30, r30
    21f6:	ff 1f       	adc	r31, r31
    21f8:	ee 0f       	add	r30, r30
    21fa:	ff 1f       	adc	r31, r31
    21fc:	e8 0f       	add	r30, r24
    21fe:	f9 1f       	adc	r31, r25
    2200:	e2 54       	subi	r30, 0x42	; 66
    2202:	fc 4f       	sbci	r31, 0xFC	; 252
    2204:	30 81       	ld	r19, Z
    2206:	33 23       	and	r19, r19
    2208:	79 f3       	breq	.-34     	; 0x21e8 <vTaskSwitchContext+0x38>
    220a:	dc 01       	movw	r26, r24
    220c:	aa 0f       	add	r26, r26
    220e:	bb 1f       	adc	r27, r27
    2210:	aa 0f       	add	r26, r26
    2212:	bb 1f       	adc	r27, r27
    2214:	aa 0f       	add	r26, r26
    2216:	bb 1f       	adc	r27, r27
    2218:	8a 0f       	add	r24, r26
    221a:	9b 1f       	adc	r25, r27
    221c:	dc 01       	movw	r26, r24
    221e:	a2 54       	subi	r26, 0x42	; 66
    2220:	bc 4f       	sbci	r27, 0xFC	; 252
    2222:	11 96       	adiw	r26, 0x01	; 1
    2224:	ed 91       	ld	r30, X+
    2226:	fc 91       	ld	r31, X
    2228:	12 97       	sbiw	r26, 0x02	; 2
    222a:	02 80       	ldd	r0, Z+2	; 0x02
    222c:	f3 81       	ldd	r31, Z+3	; 0x03
    222e:	e0 2d       	mov	r30, r0
    2230:	12 96       	adiw	r26, 0x02	; 2
    2232:	fc 93       	st	X, r31
    2234:	ee 93       	st	-X, r30
    2236:	11 97       	sbiw	r26, 0x01	; 1
    2238:	cd 01       	movw	r24, r26
    223a:	03 96       	adiw	r24, 0x03	; 3
    223c:	e8 17       	cp	r30, r24
    223e:	f9 07       	cpc	r31, r25
    2240:	31 f4       	brne	.+12     	; 0x224e <vTaskSwitchContext+0x9e>
    2242:	82 81       	ldd	r24, Z+2	; 0x02
    2244:	93 81       	ldd	r25, Z+3	; 0x03
    2246:	12 96       	adiw	r26, 0x02	; 2
    2248:	9c 93       	st	X, r25
    224a:	8e 93       	st	-X, r24
    224c:	11 97       	sbiw	r26, 0x01	; 1
    224e:	11 96       	adiw	r26, 0x01	; 1
    2250:	ed 91       	ld	r30, X+
    2252:	fc 91       	ld	r31, X
    2254:	12 97       	sbiw	r26, 0x02	; 2
    2256:	86 81       	ldd	r24, Z+6	; 0x06
    2258:	97 81       	ldd	r25, Z+7	; 0x07
    225a:	90 93 ac 03 	sts	0x03AC, r25
    225e:	80 93 ab 03 	sts	0x03AB, r24
    2262:	20 93 b4 03 	sts	0x03B4, r18
    2266:	08 95       	ret

00002268 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    2268:	0f 93       	push	r16
    226a:	1f 93       	push	r17
    226c:	cf 93       	push	r28
    226e:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    2270:	0f b6       	in	r0, 0x3f	; 63
    2272:	f8 94       	cli
    2274:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    2276:	00 97       	sbiw	r24, 0x00	; 0
    2278:	29 f4       	brne	.+10     	; 0x2284 <vTaskSuspend+0x1c>
    227a:	00 91 ab 03 	lds	r16, 0x03AB
    227e:	10 91 ac 03 	lds	r17, 0x03AC
    2282:	01 c0       	rjmp	.+2      	; 0x2286 <vTaskSuspend+0x1e>
    2284:	8c 01       	movw	r16, r24

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2286:	e8 01       	movw	r28, r16
    2288:	22 96       	adiw	r28, 0x02	; 2
    228a:	ce 01       	movw	r24, r28
    228c:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2290:	f8 01       	movw	r30, r16
    2292:	84 89       	ldd	r24, Z+20	; 0x14
    2294:	95 89       	ldd	r25, Z+21	; 0x15
    2296:	00 97       	sbiw	r24, 0x00	; 0
    2298:	21 f0       	breq	.+8      	; 0x22a2 <vTaskSuspend+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    229a:	c8 01       	movw	r24, r16
    229c:	0c 96       	adiw	r24, 0x0c	; 12
    229e:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    22a2:	8f e0       	ldi	r24, 0x0F	; 15
    22a4:	94 e0       	ldi	r25, 0x04	; 4
    22a6:	be 01       	movw	r22, r28
    22a8:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    22ac:	0f 90       	pop	r0
    22ae:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    22b0:	80 91 b3 03 	lds	r24, 0x03B3
    22b4:	88 23       	and	r24, r24
    22b6:	39 f0       	breq	.+14     	; 0x22c6 <vTaskSuspend+0x5e>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    22b8:	0f b6       	in	r0, 0x3f	; 63
    22ba:	f8 94       	cli
    22bc:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    22be:	0e 94 bb 0b 	call	0x1776	; 0x1776 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    22c2:	0f 90       	pop	r0
    22c4:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    22c6:	80 91 ab 03 	lds	r24, 0x03AB
    22ca:	90 91 ac 03 	lds	r25, 0x03AC
    22ce:	08 17       	cp	r16, r24
    22d0:	19 07       	cpc	r17, r25
    22d2:	a1 f4       	brne	.+40     	; 0x22fc <vTaskSuspend+0x94>
		{
			if( xSchedulerRunning != pdFALSE )
    22d4:	80 91 b3 03 	lds	r24, 0x03B3
    22d8:	88 23       	and	r24, r24
    22da:	19 f0       	breq	.+6      	; 0x22e2 <vTaskSuspend+0x7a>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    22dc:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>
    22e0:	0d c0       	rjmp	.+26     	; 0x22fc <vTaskSuspend+0x94>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    22e2:	80 91 b7 03 	lds	r24, 0x03B7
    22e6:	90 91 0f 04 	lds	r25, 0x040F
    22ea:	98 17       	cp	r25, r24
    22ec:	29 f4       	brne	.+10     	; 0x22f8 <vTaskSuspend+0x90>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    22ee:	10 92 ac 03 	sts	0x03AC, r1
    22f2:	10 92 ab 03 	sts	0x03AB, r1
    22f6:	02 c0       	rjmp	.+4      	; 0x22fc <vTaskSuspend+0x94>
				}
				else
				{
					vTaskSwitchContext();
    22f8:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    22fc:	df 91       	pop	r29
    22fe:	cf 91       	pop	r28
    2300:	1f 91       	pop	r17
    2302:	0f 91       	pop	r16
    2304:	08 95       	ret

00002306 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    2306:	cf 93       	push	r28
    2308:	df 93       	push	r29
    230a:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    230c:	60 91 ab 03 	lds	r22, 0x03AB
    2310:	70 91 ac 03 	lds	r23, 0x03AC
    2314:	64 5f       	subi	r22, 0xF4	; 244
    2316:	7f 4f       	sbci	r23, 0xFF	; 255
    2318:	0e 94 2a 05 	call	0xa54	; 0xa54 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    231c:	ce 01       	movw	r24, r28
    231e:	61 e0       	ldi	r22, 0x01	; 1
    2320:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <prvAddCurrentTaskToDelayedList>
}
    2324:	df 91       	pop	r29
    2326:	cf 91       	pop	r28
    2328:	08 95       	ret

0000232a <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    232a:	cf 93       	push	r28
    232c:	df 93       	push	r29
    232e:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2330:	e0 91 ab 03 	lds	r30, 0x03AB
    2334:	f0 91 ac 03 	lds	r31, 0x03AC
    2338:	70 68       	ori	r23, 0x80	; 128
    233a:	75 87       	std	Z+13, r23	; 0x0d
    233c:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    233e:	60 91 ab 03 	lds	r22, 0x03AB
    2342:	70 91 ac 03 	lds	r23, 0x03AC
    2346:	64 5f       	subi	r22, 0xF4	; 244
    2348:	7f 4f       	sbci	r23, 0xFF	; 255
    234a:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    234e:	ce 01       	movw	r24, r28
    2350:	61 e0       	ldi	r22, 0x01	; 1
    2352:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <prvAddCurrentTaskToDelayedList>
}
    2356:	df 91       	pop	r29
    2358:	cf 91       	pop	r28
    235a:	08 95       	ret

0000235c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    235c:	0f 93       	push	r16
    235e:	1f 93       	push	r17
    2360:	cf 93       	push	r28
    2362:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2364:	dc 01       	movw	r26, r24
    2366:	15 96       	adiw	r26, 0x05	; 5
    2368:	ed 91       	ld	r30, X+
    236a:	fc 91       	ld	r31, X
    236c:	16 97       	sbiw	r26, 0x06	; 6
    236e:	06 81       	ldd	r16, Z+6	; 0x06
    2370:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2372:	e8 01       	movw	r28, r16
    2374:	2c 96       	adiw	r28, 0x0c	; 12
    2376:	ce 01       	movw	r24, r28
    2378:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    237c:	80 91 ad 03 	lds	r24, 0x03AD
    2380:	88 23       	and	r24, r24
    2382:	e9 f4       	brne	.+58     	; 0x23be <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    2384:	e8 01       	movw	r28, r16
    2386:	22 96       	adiw	r28, 0x02	; 2
    2388:	ce 01       	movw	r24, r28
    238a:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    238e:	f8 01       	movw	r30, r16
    2390:	86 89       	ldd	r24, Z+22	; 0x16
    2392:	90 91 b4 03 	lds	r25, 0x03B4
    2396:	98 17       	cp	r25, r24
    2398:	10 f4       	brcc	.+4      	; 0x239e <xTaskRemoveFromEventList+0x42>
    239a:	80 93 b4 03 	sts	0x03B4, r24
    239e:	90 e0       	ldi	r25, 0x00	; 0
    23a0:	9c 01       	movw	r18, r24
    23a2:	22 0f       	add	r18, r18
    23a4:	33 1f       	adc	r19, r19
    23a6:	22 0f       	add	r18, r18
    23a8:	33 1f       	adc	r19, r19
    23aa:	22 0f       	add	r18, r18
    23ac:	33 1f       	adc	r19, r19
    23ae:	82 0f       	add	r24, r18
    23b0:	93 1f       	adc	r25, r19
    23b2:	82 54       	subi	r24, 0x42	; 66
    23b4:	9c 4f       	sbci	r25, 0xFC	; 252
    23b6:	be 01       	movw	r22, r28
    23b8:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>
    23bc:	05 c0       	rjmp	.+10     	; 0x23c8 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    23be:	8d ef       	ldi	r24, 0xFD	; 253
    23c0:	93 e0       	ldi	r25, 0x03	; 3
    23c2:	be 01       	movw	r22, r28
    23c4:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    23c8:	e0 91 ab 03 	lds	r30, 0x03AB
    23cc:	f0 91 ac 03 	lds	r31, 0x03AC
    23d0:	d8 01       	movw	r26, r16
    23d2:	56 96       	adiw	r26, 0x16	; 22
    23d4:	9c 91       	ld	r25, X
    23d6:	56 97       	sbiw	r26, 0x16	; 22
    23d8:	86 89       	ldd	r24, Z+22	; 0x16
    23da:	89 17       	cp	r24, r25
    23dc:	20 f4       	brcc	.+8      	; 0x23e6 <xTaskRemoveFromEventList+0x8a>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    23de:	81 e0       	ldi	r24, 0x01	; 1
    23e0:	80 93 b1 03 	sts	0x03B1, r24
    23e4:	01 c0       	rjmp	.+2      	; 0x23e8 <xTaskRemoveFromEventList+0x8c>
	}
	else
	{
		xReturn = pdFALSE;
    23e6:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    23e8:	df 91       	pop	r29
    23ea:	cf 91       	pop	r28
    23ec:	1f 91       	pop	r17
    23ee:	0f 91       	pop	r16
    23f0:	08 95       	ret

000023f2 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    23f2:	0f 93       	push	r16
    23f4:	1f 93       	push	r17
    23f6:	cf 93       	push	r28
    23f8:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    23fa:	70 68       	ori	r23, 0x80	; 128
    23fc:	fc 01       	movw	r30, r24
    23fe:	71 83       	std	Z+1, r23	; 0x01
    2400:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    2402:	c6 81       	ldd	r28, Z+6	; 0x06
    2404:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    2406:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    240a:	8e 01       	movw	r16, r28
    240c:	0e 5f       	subi	r16, 0xFE	; 254
    240e:	1f 4f       	sbci	r17, 0xFF	; 255
    2410:	c8 01       	movw	r24, r16
    2412:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    2416:	8e 89       	ldd	r24, Y+22	; 0x16
    2418:	90 91 b4 03 	lds	r25, 0x03B4
    241c:	98 17       	cp	r25, r24
    241e:	10 f4       	brcc	.+4      	; 0x2424 <xTaskRemoveFromUnorderedEventList+0x32>
    2420:	80 93 b4 03 	sts	0x03B4, r24
    2424:	90 e0       	ldi	r25, 0x00	; 0
    2426:	9c 01       	movw	r18, r24
    2428:	22 0f       	add	r18, r18
    242a:	33 1f       	adc	r19, r19
    242c:	22 0f       	add	r18, r18
    242e:	33 1f       	adc	r19, r19
    2430:	22 0f       	add	r18, r18
    2432:	33 1f       	adc	r19, r19
    2434:	82 0f       	add	r24, r18
    2436:	93 1f       	adc	r25, r19
    2438:	82 54       	subi	r24, 0x42	; 66
    243a:	9c 4f       	sbci	r25, 0xFC	; 252
    243c:	b8 01       	movw	r22, r16
    243e:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2442:	e0 91 ab 03 	lds	r30, 0x03AB
    2446:	f0 91 ac 03 	lds	r31, 0x03AC
    244a:	9e 89       	ldd	r25, Y+22	; 0x16
    244c:	86 89       	ldd	r24, Z+22	; 0x16
    244e:	89 17       	cp	r24, r25
    2450:	20 f4       	brcc	.+8      	; 0x245a <xTaskRemoveFromUnorderedEventList+0x68>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    2452:	81 e0       	ldi	r24, 0x01	; 1
    2454:	80 93 b1 03 	sts	0x03B1, r24
    2458:	01 c0       	rjmp	.+2      	; 0x245c <xTaskRemoveFromUnorderedEventList+0x6a>
	}
	else
	{
		xReturn = pdFALSE;
    245a:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    245c:	df 91       	pop	r29
    245e:	cf 91       	pop	r28
    2460:	1f 91       	pop	r17
    2462:	0f 91       	pop	r16
    2464:	08 95       	ret

00002466 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    2466:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2468:	80 91 b0 03 	lds	r24, 0x03B0
    246c:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    246e:	80 91 b5 03 	lds	r24, 0x03B5
    2472:	90 91 b6 03 	lds	r25, 0x03B6
    2476:	92 83       	std	Z+2, r25	; 0x02
    2478:	81 83       	std	Z+1, r24	; 0x01
}
    247a:	08 95       	ret

0000247c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    247c:	fc 01       	movw	r30, r24
    247e:	db 01       	movw	r26, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2480:	0f b6       	in	r0, 0x3f	; 63
    2482:	f8 94       	cli
    2484:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2486:	60 91 b5 03 	lds	r22, 0x03B5
    248a:	70 91 b6 03 	lds	r23, 0x03B6
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    248e:	4d 91       	ld	r20, X+
    2490:	5c 91       	ld	r21, X
    2492:	11 97       	sbiw	r26, 0x01	; 1
    2494:	8f ef       	ldi	r24, 0xFF	; 255
    2496:	4f 3f       	cpi	r20, 0xFF	; 255
    2498:	58 07       	cpc	r21, r24
    249a:	e9 f0       	breq	.+58     	; 0x24d6 <xTaskCheckForTimeOut+0x5a>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    249c:	80 91 b0 03 	lds	r24, 0x03B0
    24a0:	90 81       	ld	r25, Z
    24a2:	98 17       	cp	r25, r24
    24a4:	29 f0       	breq	.+10     	; 0x24b0 <xTaskCheckForTimeOut+0x34>
    24a6:	81 81       	ldd	r24, Z+1	; 0x01
    24a8:	92 81       	ldd	r25, Z+2	; 0x02
    24aa:	68 17       	cp	r22, r24
    24ac:	79 07       	cpc	r23, r25
    24ae:	a8 f4       	brcc	.+42     	; 0x24da <xTaskCheckForTimeOut+0x5e>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    24b0:	81 81       	ldd	r24, Z+1	; 0x01
    24b2:	92 81       	ldd	r25, Z+2	; 0x02
    24b4:	9b 01       	movw	r18, r22
    24b6:	28 1b       	sub	r18, r24
    24b8:	39 0b       	sbc	r19, r25
    24ba:	24 17       	cp	r18, r20
    24bc:	35 07       	cpc	r19, r21
    24be:	78 f4       	brcc	.+30     	; 0x24de <xTaskCheckForTimeOut+0x62>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    24c0:	86 1b       	sub	r24, r22
    24c2:	97 0b       	sbc	r25, r23
    24c4:	84 0f       	add	r24, r20
    24c6:	95 1f       	adc	r25, r21
    24c8:	8d 93       	st	X+, r24
    24ca:	9c 93       	st	X, r25
			vTaskSetTimeOutState( pxTimeOut );
    24cc:	cf 01       	movw	r24, r30
    24ce:	0e 94 33 12 	call	0x2466	; 0x2466 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    24d2:	80 e0       	ldi	r24, 0x00	; 0
    24d4:	05 c0       	rjmp	.+10     	; 0x24e0 <xTaskCheckForTimeOut+0x64>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    24d6:	80 e0       	ldi	r24, 0x00	; 0
    24d8:	03 c0       	rjmp	.+6      	; 0x24e0 <xTaskCheckForTimeOut+0x64>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    24da:	81 e0       	ldi	r24, 0x01	; 1
    24dc:	01 c0       	rjmp	.+2      	; 0x24e0 <xTaskCheckForTimeOut+0x64>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    24de:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    24e0:	0f 90       	pop	r0
    24e2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    24e4:	08 95       	ret

000024e6 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    24e6:	81 e0       	ldi	r24, 0x01	; 1
    24e8:	80 93 b1 03 	sts	0x03B1, r24
}
    24ec:	08 95       	ret

000024ee <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    24ee:	80 91 ab 03 	lds	r24, 0x03AB
    24f2:	90 91 ac 03 	lds	r25, 0x03AC

		return xReturn;
	}
    24f6:	08 95       	ret

000024f8 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    24f8:	0f 93       	push	r16
    24fa:	1f 93       	push	r17
    24fc:	cf 93       	push	r28
    24fe:	df 93       	push	r29
    2500:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    2502:	00 97       	sbiw	r24, 0x00	; 0
    2504:	09 f4       	brne	.+2      	; 0x2508 <vTaskPriorityInherit+0x10>
    2506:	51 c0       	rjmp	.+162    	; 0x25aa <vTaskPriorityInherit+0xb2>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2508:	8e 89       	ldd	r24, Y+22	; 0x16
    250a:	e0 91 ab 03 	lds	r30, 0x03AB
    250e:	f0 91 ac 03 	lds	r31, 0x03AC
    2512:	96 89       	ldd	r25, Z+22	; 0x16
    2514:	89 17       	cp	r24, r25
    2516:	08 f0       	brcs	.+2      	; 0x251a <vTaskPriorityInherit+0x22>
    2518:	48 c0       	rjmp	.+144    	; 0x25aa <vTaskPriorityInherit+0xb2>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    251a:	2c 85       	ldd	r18, Y+12	; 0x0c
    251c:	3d 85       	ldd	r19, Y+13	; 0x0d
    251e:	33 23       	and	r19, r19
    2520:	5c f0       	brlt	.+22     	; 0x2538 <vTaskPriorityInherit+0x40>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2522:	e0 91 ab 03 	lds	r30, 0x03AB
    2526:	f0 91 ac 03 	lds	r31, 0x03AC
    252a:	96 89       	ldd	r25, Z+22	; 0x16
    252c:	25 e0       	ldi	r18, 0x05	; 5
    252e:	30 e0       	ldi	r19, 0x00	; 0
    2530:	29 1b       	sub	r18, r25
    2532:	31 09       	sbc	r19, r1
    2534:	3d 87       	std	Y+13, r19	; 0x0d
    2536:	2c 87       	std	Y+12, r18	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    2538:	90 e0       	ldi	r25, 0x00	; 0
    253a:	9c 01       	movw	r18, r24
    253c:	22 0f       	add	r18, r18
    253e:	33 1f       	adc	r19, r19
    2540:	22 0f       	add	r18, r18
    2542:	33 1f       	adc	r19, r19
    2544:	22 0f       	add	r18, r18
    2546:	33 1f       	adc	r19, r19
    2548:	82 0f       	add	r24, r18
    254a:	93 1f       	adc	r25, r19
    254c:	82 54       	subi	r24, 0x42	; 66
    254e:	9c 4f       	sbci	r25, 0xFC	; 252
    2550:	2a 85       	ldd	r18, Y+10	; 0x0a
    2552:	3b 85       	ldd	r19, Y+11	; 0x0b
    2554:	28 17       	cp	r18, r24
    2556:	39 07       	cpc	r19, r25
    2558:	11 f5       	brne	.+68     	; 0x259e <vTaskPriorityInherit+0xa6>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    255a:	8e 01       	movw	r16, r28
    255c:	0e 5f       	subi	r16, 0xFE	; 254
    255e:	1f 4f       	sbci	r17, 0xFF	; 255
    2560:	c8 01       	movw	r24, r16
    2562:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2566:	e0 91 ab 03 	lds	r30, 0x03AB
    256a:	f0 91 ac 03 	lds	r31, 0x03AC
    256e:	86 89       	ldd	r24, Z+22	; 0x16
    2570:	8e 8b       	std	Y+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    2572:	90 91 b4 03 	lds	r25, 0x03B4
    2576:	98 17       	cp	r25, r24
    2578:	10 f4       	brcc	.+4      	; 0x257e <vTaskPriorityInherit+0x86>
    257a:	80 93 b4 03 	sts	0x03B4, r24
    257e:	90 e0       	ldi	r25, 0x00	; 0
    2580:	9c 01       	movw	r18, r24
    2582:	22 0f       	add	r18, r18
    2584:	33 1f       	adc	r19, r19
    2586:	22 0f       	add	r18, r18
    2588:	33 1f       	adc	r19, r19
    258a:	22 0f       	add	r18, r18
    258c:	33 1f       	adc	r19, r19
    258e:	82 0f       	add	r24, r18
    2590:	93 1f       	adc	r25, r19
    2592:	82 54       	subi	r24, 0x42	; 66
    2594:	9c 4f       	sbci	r25, 0xFC	; 252
    2596:	b8 01       	movw	r22, r16
    2598:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>
    259c:	06 c0       	rjmp	.+12     	; 0x25aa <vTaskPriorityInherit+0xb2>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    259e:	e0 91 ab 03 	lds	r30, 0x03AB
    25a2:	f0 91 ac 03 	lds	r31, 0x03AC
    25a6:	86 89       	ldd	r24, Z+22	; 0x16
    25a8:	8e 8b       	std	Y+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    25aa:	df 91       	pop	r29
    25ac:	cf 91       	pop	r28
    25ae:	1f 91       	pop	r17
    25b0:	0f 91       	pop	r16
    25b2:	08 95       	ret

000025b4 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    25b4:	0f 93       	push	r16
    25b6:	1f 93       	push	r17
    25b8:	cf 93       	push	r28
    25ba:	df 93       	push	r29
    25bc:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    25be:	00 97       	sbiw	r24, 0x00	; 0
    25c0:	81 f1       	breq	.+96     	; 0x2622 <xTaskPriorityDisinherit+0x6e>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    25c2:	8c a1       	lds	r24, 0x4c
    25c4:	81 50       	subi	r24, 0x01	; 1
    25c6:	8c a3       	lds	r24, 0x5c

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    25c8:	2e 89       	ldd	r18, Y+22	; 0x16
    25ca:	9b a1       	lds	r25, 0x4b
    25cc:	29 17       	cp	r18, r25
    25ce:	59 f1       	breq	.+86     	; 0x2626 <xTaskPriorityDisinherit+0x72>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    25d0:	88 23       	and	r24, r24
    25d2:	59 f5       	brne	.+86     	; 0x262a <xTaskPriorityDisinherit+0x76>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    25d4:	8e 01       	movw	r16, r28
    25d6:	0e 5f       	subi	r16, 0xFE	; 254
    25d8:	1f 4f       	sbci	r17, 0xFF	; 255
    25da:	c8 01       	movw	r24, r16
    25dc:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    25e0:	4b a1       	lds	r20, 0x4b
    25e2:	4e 8b       	std	Y+22, r20	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    25e4:	24 2f       	mov	r18, r20
    25e6:	30 e0       	ldi	r19, 0x00	; 0
    25e8:	85 e0       	ldi	r24, 0x05	; 5
    25ea:	90 e0       	ldi	r25, 0x00	; 0
    25ec:	82 1b       	sub	r24, r18
    25ee:	93 0b       	sbc	r25, r19
    25f0:	9d 87       	std	Y+13, r25	; 0x0d
    25f2:	8c 87       	std	Y+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    25f4:	80 91 b4 03 	lds	r24, 0x03B4
    25f8:	84 17       	cp	r24, r20
    25fa:	10 f4       	brcc	.+4      	; 0x2600 <xTaskPriorityDisinherit+0x4c>
    25fc:	40 93 b4 03 	sts	0x03B4, r20
    2600:	c9 01       	movw	r24, r18
    2602:	88 0f       	add	r24, r24
    2604:	99 1f       	adc	r25, r25
    2606:	88 0f       	add	r24, r24
    2608:	99 1f       	adc	r25, r25
    260a:	88 0f       	add	r24, r24
    260c:	99 1f       	adc	r25, r25
    260e:	28 0f       	add	r18, r24
    2610:	39 1f       	adc	r19, r25
    2612:	c9 01       	movw	r24, r18
    2614:	82 54       	subi	r24, 0x42	; 66
    2616:	9c 4f       	sbci	r25, 0xFC	; 252
    2618:	b8 01       	movw	r22, r16
    261a:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    261e:	81 e0       	ldi	r24, 0x01	; 1
    2620:	05 c0       	rjmp	.+10     	; 0x262c <xTaskPriorityDisinherit+0x78>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    2622:	80 e0       	ldi	r24, 0x00	; 0
    2624:	03 c0       	rjmp	.+6      	; 0x262c <xTaskPriorityDisinherit+0x78>
    2626:	80 e0       	ldi	r24, 0x00	; 0
    2628:	01 c0       	rjmp	.+2      	; 0x262c <xTaskPriorityDisinherit+0x78>
    262a:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    262c:	df 91       	pop	r29
    262e:	cf 91       	pop	r28
    2630:	1f 91       	pop	r17
    2632:	0f 91       	pop	r16
    2634:	08 95       	ret

00002636 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    2636:	e0 91 ab 03 	lds	r30, 0x03AB
    263a:	f0 91 ac 03 	lds	r31, 0x03AC
    263e:	84 85       	ldd	r24, Z+12	; 0x0c
    2640:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2642:	e0 91 ab 03 	lds	r30, 0x03AB
    2646:	f0 91 ac 03 	lds	r31, 0x03AC
    264a:	a0 91 ab 03 	lds	r26, 0x03AB
    264e:	b0 91 ac 03 	lds	r27, 0x03AC
    2652:	56 96       	adiw	r26, 0x16	; 22
    2654:	4c 91       	ld	r20, X
    2656:	56 97       	sbiw	r26, 0x16	; 22
    2658:	25 e0       	ldi	r18, 0x05	; 5
    265a:	30 e0       	ldi	r19, 0x00	; 0
    265c:	24 1b       	sub	r18, r20
    265e:	31 09       	sbc	r19, r1
    2660:	35 87       	std	Z+13, r19	; 0x0d
    2662:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    2664:	08 95       	ret

00002666 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2666:	80 91 ab 03 	lds	r24, 0x03AB
    266a:	90 91 ac 03 	lds	r25, 0x03AC
    266e:	00 97       	sbiw	r24, 0x00	; 0
    2670:	39 f0       	breq	.+14     	; 0x2680 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2672:	e0 91 ab 03 	lds	r30, 0x03AB
    2676:	f0 91 ac 03 	lds	r31, 0x03AC
    267a:	84 a1       	lds	r24, 0x44
    267c:	8f 5f       	subi	r24, 0xFF	; 255
    267e:	84 a3       	lds	r24, 0x54
		}

		return pxCurrentTCB;
    2680:	80 91 ab 03 	lds	r24, 0x03AB
    2684:	90 91 ac 03 	lds	r25, 0x03AC
	}
    2688:	08 95       	ret

0000268a <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    268a:	0f 93       	push	r16
    268c:	1f 93       	push	r17
    268e:	cf 93       	push	r28
    2690:	c8 2f       	mov	r28, r24
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    2692:	0f b6       	in	r0, 0x3f	; 63
    2694:	f8 94       	cli
    2696:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    2698:	e0 91 ab 03 	lds	r30, 0x03AB
    269c:	f0 91 ac 03 	lds	r31, 0x03AC
    26a0:	85 a1       	lds	r24, 0x45
    26a2:	96 a1       	lds	r25, 0x46
    26a4:	a7 a1       	lds	r26, 0x47
    26a6:	b0 a5       	lds	r27, 0x60
    26a8:	00 97       	sbiw	r24, 0x00	; 0
    26aa:	a1 05       	cpc	r26, r1
    26ac:	b1 05       	cpc	r27, r1
    26ae:	79 f4       	brne	.+30     	; 0x26ce <ulTaskNotifyTake+0x44>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    26b0:	e0 91 ab 03 	lds	r30, 0x03AB
    26b4:	f0 91 ac 03 	lds	r31, 0x03AC
    26b8:	81 e0       	ldi	r24, 0x01	; 1
    26ba:	81 a7       	lds	r24, 0x71

				if( xTicksToWait > ( TickType_t ) 0 )
    26bc:	61 15       	cp	r22, r1
    26be:	71 05       	cpc	r23, r1
    26c0:	31 f0       	breq	.+12     	; 0x26ce <ulTaskNotifyTake+0x44>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    26c2:	cb 01       	movw	r24, r22
    26c4:	61 e0       	ldi	r22, 0x01	; 1
    26c6:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    26ca:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    26ce:	0f 90       	pop	r0
    26d0:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    26d2:	0f b6       	in	r0, 0x3f	; 63
    26d4:	f8 94       	cli
    26d6:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    26d8:	e0 91 ab 03 	lds	r30, 0x03AB
    26dc:	f0 91 ac 03 	lds	r31, 0x03AC
    26e0:	05 a1       	lds	r16, 0x45
    26e2:	16 a1       	lds	r17, 0x46
    26e4:	27 a1       	lds	r18, 0x47
    26e6:	30 a5       	lds	r19, 0x60

			if( ulReturn != 0UL )
    26e8:	01 15       	cp	r16, r1
    26ea:	11 05       	cpc	r17, r1
    26ec:	21 05       	cpc	r18, r1
    26ee:	31 05       	cpc	r19, r1
    26f0:	c1 f0       	breq	.+48     	; 0x2722 <ulTaskNotifyTake+0x98>
			{
				if( xClearCountOnExit != pdFALSE )
    26f2:	cc 23       	and	r28, r28
    26f4:	49 f0       	breq	.+18     	; 0x2708 <ulTaskNotifyTake+0x7e>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    26f6:	e0 91 ab 03 	lds	r30, 0x03AB
    26fa:	f0 91 ac 03 	lds	r31, 0x03AC
    26fe:	15 a2       	lds	r17, 0x95
    2700:	16 a2       	lds	r17, 0x96
    2702:	17 a2       	lds	r17, 0x97
    2704:	10 a6       	lds	r17, 0xb0
    2706:	0d c0       	rjmp	.+26     	; 0x2722 <ulTaskNotifyTake+0x98>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    2708:	e0 91 ab 03 	lds	r30, 0x03AB
    270c:	f0 91 ac 03 	lds	r31, 0x03AC
    2710:	d9 01       	movw	r26, r18
    2712:	c8 01       	movw	r24, r16
    2714:	01 97       	sbiw	r24, 0x01	; 1
    2716:	a1 09       	sbc	r26, r1
    2718:	b1 09       	sbc	r27, r1
    271a:	85 a3       	lds	r24, 0x55
    271c:	96 a3       	lds	r25, 0x56
    271e:	a7 a3       	lds	r26, 0x57
    2720:	b0 a7       	lds	r27, 0x70
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2722:	e0 91 ab 03 	lds	r30, 0x03AB
    2726:	f0 91 ac 03 	lds	r31, 0x03AC
    272a:	11 a6       	lds	r17, 0xb1
		}
		taskEXIT_CRITICAL();
    272c:	0f 90       	pop	r0
    272e:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    2730:	60 2f       	mov	r22, r16
    2732:	71 2f       	mov	r23, r17
    2734:	82 2f       	mov	r24, r18
    2736:	93 2f       	mov	r25, r19
    2738:	cf 91       	pop	r28
    273a:	1f 91       	pop	r17
    273c:	0f 91       	pop	r16
    273e:	08 95       	ret

00002740 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    2740:	8f 92       	push	r8
    2742:	9f 92       	push	r9
    2744:	af 92       	push	r10
    2746:	bf 92       	push	r11
    2748:	ef 92       	push	r14
    274a:	ff 92       	push	r15
    274c:	0f 93       	push	r16
    274e:	1f 93       	push	r17
    2750:	dc 01       	movw	r26, r24
    2752:	cb 01       	movw	r24, r22
    2754:	49 01       	movw	r8, r18
    2756:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    2758:	0f b6       	in	r0, 0x3f	; 63
    275a:	f8 94       	cli
    275c:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    275e:	e0 91 ab 03 	lds	r30, 0x03AB
    2762:	f0 91 ac 03 	lds	r31, 0x03AC
    2766:	21 a5       	lds	r18, 0x61
    2768:	22 30       	cpi	r18, 0x02	; 2
    276a:	19 f1       	breq	.+70     	; 0x27b2 <xTaskNotifyWait+0x72>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    276c:	e0 91 ab 03 	lds	r30, 0x03AB
    2770:	f0 91 ac 03 	lds	r31, 0x03AC
    2774:	45 a1       	lds	r20, 0x45
    2776:	56 a1       	lds	r21, 0x46
    2778:	67 a1       	lds	r22, 0x47
    277a:	70 a5       	lds	r23, 0x60
    277c:	80 95       	com	r24
    277e:	90 95       	com	r25
    2780:	a0 95       	com	r26
    2782:	b0 95       	com	r27
    2784:	84 23       	and	r24, r20
    2786:	95 23       	and	r25, r21
    2788:	a6 23       	and	r26, r22
    278a:	b7 23       	and	r27, r23
    278c:	85 a3       	lds	r24, 0x55
    278e:	96 a3       	lds	r25, 0x56
    2790:	a7 a3       	lds	r26, 0x57
    2792:	b0 a7       	lds	r27, 0x70

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    2794:	e0 91 ab 03 	lds	r30, 0x03AB
    2798:	f0 91 ac 03 	lds	r31, 0x03AC
    279c:	81 e0       	ldi	r24, 0x01	; 1
    279e:	81 a7       	lds	r24, 0x71

				if( xTicksToWait > ( TickType_t ) 0 )
    27a0:	e1 14       	cp	r14, r1
    27a2:	f1 04       	cpc	r15, r1
    27a4:	31 f0       	breq	.+12     	; 0x27b2 <xTaskNotifyWait+0x72>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    27a6:	c7 01       	movw	r24, r14
    27a8:	61 e0       	ldi	r22, 0x01	; 1
    27aa:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    27ae:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    27b2:	0f 90       	pop	r0
    27b4:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    27b6:	0f b6       	in	r0, 0x3f	; 63
    27b8:	f8 94       	cli
    27ba:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    27bc:	01 15       	cp	r16, r1
    27be:	11 05       	cpc	r17, r1
    27c0:	69 f0       	breq	.+26     	; 0x27dc <xTaskNotifyWait+0x9c>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    27c2:	e0 91 ab 03 	lds	r30, 0x03AB
    27c6:	f0 91 ac 03 	lds	r31, 0x03AC
    27ca:	85 a1       	lds	r24, 0x45
    27cc:	96 a1       	lds	r25, 0x46
    27ce:	a7 a1       	lds	r26, 0x47
    27d0:	b0 a5       	lds	r27, 0x60
    27d2:	f8 01       	movw	r30, r16
    27d4:	80 83       	st	Z, r24
    27d6:	91 83       	std	Z+1, r25	; 0x01
    27d8:	a2 83       	std	Z+2, r26	; 0x02
    27da:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    27dc:	e0 91 ab 03 	lds	r30, 0x03AB
    27e0:	f0 91 ac 03 	lds	r31, 0x03AC
    27e4:	81 a5       	lds	r24, 0x61
    27e6:	81 30       	cpi	r24, 0x01	; 1
    27e8:	b1 f0       	breq	.+44     	; 0x2816 <xTaskNotifyWait+0xd6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    27ea:	e0 91 ab 03 	lds	r30, 0x03AB
    27ee:	f0 91 ac 03 	lds	r31, 0x03AC
    27f2:	85 a1       	lds	r24, 0x45
    27f4:	96 a1       	lds	r25, 0x46
    27f6:	a7 a1       	lds	r26, 0x47
    27f8:	b0 a5       	lds	r27, 0x60
    27fa:	80 94       	com	r8
    27fc:	90 94       	com	r9
    27fe:	a0 94       	com	r10
    2800:	b0 94       	com	r11
    2802:	88 22       	and	r8, r24
    2804:	99 22       	and	r9, r25
    2806:	aa 22       	and	r10, r26
    2808:	bb 22       	and	r11, r27
    280a:	85 a2       	lds	r24, 0x95
    280c:	96 a2       	lds	r25, 0x96
    280e:	a7 a2       	lds	r26, 0x97
    2810:	b0 a6       	lds	r27, 0xb0
				xReturn = pdTRUE;
    2812:	81 e0       	ldi	r24, 0x01	; 1
    2814:	01 c0       	rjmp	.+2      	; 0x2818 <xTaskNotifyWait+0xd8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    2816:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2818:	e0 91 ab 03 	lds	r30, 0x03AB
    281c:	f0 91 ac 03 	lds	r31, 0x03AC
    2820:	11 a6       	lds	r17, 0xb1
		}
		taskEXIT_CRITICAL();
    2822:	0f 90       	pop	r0
    2824:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2826:	1f 91       	pop	r17
    2828:	0f 91       	pop	r16
    282a:	ff 90       	pop	r15
    282c:	ef 90       	pop	r14
    282e:	bf 90       	pop	r11
    2830:	af 90       	pop	r10
    2832:	9f 90       	pop	r9
    2834:	8f 90       	pop	r8
    2836:	08 95       	ret

00002838 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    2838:	0f 93       	push	r16
    283a:	1f 93       	push	r17
    283c:	cf 93       	push	r28
    283e:	df 93       	push	r29
    2840:	ec 01       	movw	r28, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    2842:	0f b6       	in	r0, 0x3f	; 63
    2844:	f8 94       	cli
    2846:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    2848:	01 15       	cp	r16, r1
    284a:	11 05       	cpc	r17, r1
    284c:	49 f0       	breq	.+18     	; 0x2860 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    284e:	8d a1       	lds	r24, 0x4d
    2850:	9e a1       	lds	r25, 0x4e
    2852:	af a1       	lds	r26, 0x4f
    2854:	b8 a5       	lds	r27, 0x68
    2856:	f8 01       	movw	r30, r16
    2858:	80 83       	st	Z, r24
    285a:	91 83       	std	Z+1, r25	; 0x01
    285c:	a2 83       	std	Z+2, r26	; 0x02
    285e:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2860:	39 a5       	lds	r19, 0x69

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    2862:	82 e0       	ldi	r24, 0x02	; 2
    2864:	89 a7       	lds	r24, 0x79

			switch( eAction )
    2866:	22 30       	cpi	r18, 0x02	; 2
    2868:	b9 f0       	breq	.+46     	; 0x2898 <xTaskGenericNotify+0x60>
    286a:	23 30       	cpi	r18, 0x03	; 3
    286c:	18 f4       	brcc	.+6      	; 0x2874 <xTaskGenericNotify+0x3c>
    286e:	21 30       	cpi	r18, 0x01	; 1
    2870:	51 f5       	brne	.+84     	; 0x28c6 <xTaskGenericNotify+0x8e>
    2872:	05 c0       	rjmp	.+10     	; 0x287e <xTaskGenericNotify+0x46>
    2874:	23 30       	cpi	r18, 0x03	; 3
    2876:	e1 f0       	breq	.+56     	; 0x28b0 <xTaskGenericNotify+0x78>
    2878:	24 30       	cpi	r18, 0x04	; 4
    287a:	29 f5       	brne	.+74     	; 0x28c6 <xTaskGenericNotify+0x8e>
    287c:	1e c0       	rjmp	.+60     	; 0x28ba <xTaskGenericNotify+0x82>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    287e:	8d a1       	lds	r24, 0x4d
    2880:	9e a1       	lds	r25, 0x4e
    2882:	af a1       	lds	r26, 0x4f
    2884:	b8 a5       	lds	r27, 0x68
    2886:	48 2b       	or	r20, r24
    2888:	59 2b       	or	r21, r25
    288a:	6a 2b       	or	r22, r26
    288c:	7b 2b       	or	r23, r27
    288e:	4d a3       	lds	r20, 0x5d
    2890:	5e a3       	lds	r21, 0x5e
    2892:	6f a3       	lds	r22, 0x5f
    2894:	78 a7       	lds	r23, 0x78
					break;
    2896:	17 c0       	rjmp	.+46     	; 0x28c6 <xTaskGenericNotify+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    2898:	8d a1       	lds	r24, 0x4d
    289a:	9e a1       	lds	r25, 0x4e
    289c:	af a1       	lds	r26, 0x4f
    289e:	b8 a5       	lds	r27, 0x68
    28a0:	01 96       	adiw	r24, 0x01	; 1
    28a2:	a1 1d       	adc	r26, r1
    28a4:	b1 1d       	adc	r27, r1
    28a6:	8d a3       	lds	r24, 0x5d
    28a8:	9e a3       	lds	r25, 0x5e
    28aa:	af a3       	lds	r26, 0x5f
    28ac:	b8 a7       	lds	r27, 0x78
					break;
    28ae:	0b c0       	rjmp	.+22     	; 0x28c6 <xTaskGenericNotify+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    28b0:	4d a3       	lds	r20, 0x5d
    28b2:	5e a3       	lds	r21, 0x5e
    28b4:	6f a3       	lds	r22, 0x5f
    28b6:	78 a7       	lds	r23, 0x78
					break;
    28b8:	06 c0       	rjmp	.+12     	; 0x28c6 <xTaskGenericNotify+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    28ba:	32 30       	cpi	r19, 0x02	; 2
    28bc:	71 f1       	breq	.+92     	; 0x291a <xTaskGenericNotify+0xe2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    28be:	4d a3       	lds	r20, 0x5d
    28c0:	5e a3       	lds	r21, 0x5e
    28c2:	6f a3       	lds	r22, 0x5f
    28c4:	78 a7       	lds	r23, 0x78

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    28c6:	31 30       	cpi	r19, 0x01	; 1
    28c8:	51 f5       	brne	.+84     	; 0x291e <xTaskGenericNotify+0xe6>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    28ca:	8e 01       	movw	r16, r28
    28cc:	0e 5f       	subi	r16, 0xFE	; 254
    28ce:	1f 4f       	sbci	r17, 0xFF	; 255
    28d0:	c8 01       	movw	r24, r16
    28d2:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    28d6:	8e 89       	ldd	r24, Y+22	; 0x16
    28d8:	90 91 b4 03 	lds	r25, 0x03B4
    28dc:	98 17       	cp	r25, r24
    28de:	10 f4       	brcc	.+4      	; 0x28e4 <xTaskGenericNotify+0xac>
    28e0:	80 93 b4 03 	sts	0x03B4, r24
    28e4:	90 e0       	ldi	r25, 0x00	; 0
    28e6:	9c 01       	movw	r18, r24
    28e8:	22 0f       	add	r18, r18
    28ea:	33 1f       	adc	r19, r19
    28ec:	22 0f       	add	r18, r18
    28ee:	33 1f       	adc	r19, r19
    28f0:	22 0f       	add	r18, r18
    28f2:	33 1f       	adc	r19, r19
    28f4:	82 0f       	add	r24, r18
    28f6:	93 1f       	adc	r25, r19
    28f8:	82 54       	subi	r24, 0x42	; 66
    28fa:	9c 4f       	sbci	r25, 0xFC	; 252
    28fc:	b8 01       	movw	r22, r16
    28fe:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2902:	e0 91 ab 03 	lds	r30, 0x03AB
    2906:	f0 91 ac 03 	lds	r31, 0x03AC
    290a:	9e 89       	ldd	r25, Y+22	; 0x16
    290c:	86 89       	ldd	r24, Z+22	; 0x16
    290e:	89 17       	cp	r24, r25
    2910:	40 f4       	brcc	.+16     	; 0x2922 <xTaskGenericNotify+0xea>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    2912:	0e 94 4a 06 	call	0xc94	; 0xc94 <vPortYield>
    2916:	81 e0       	ldi	r24, 0x01	; 1
    2918:	05 c0       	rjmp	.+10     	; 0x2924 <xTaskGenericNotify+0xec>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    291a:	80 e0       	ldi	r24, 0x00	; 0
    291c:	03 c0       	rjmp	.+6      	; 0x2924 <xTaskGenericNotify+0xec>

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    291e:	81 e0       	ldi	r24, 0x01	; 1
    2920:	01 c0       	rjmp	.+2      	; 0x2924 <xTaskGenericNotify+0xec>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2922:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2924:	0f 90       	pop	r0
    2926:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2928:	df 91       	pop	r29
    292a:	cf 91       	pop	r28
    292c:	1f 91       	pop	r17
    292e:	0f 91       	pop	r16
    2930:	08 95       	ret

00002932 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    2932:	ef 92       	push	r14
    2934:	ff 92       	push	r15
    2936:	0f 93       	push	r16
    2938:	1f 93       	push	r17
    293a:	cf 93       	push	r28
    293c:	df 93       	push	r29
    293e:	ec 01       	movw	r28, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    2940:	01 15       	cp	r16, r1
    2942:	11 05       	cpc	r17, r1
    2944:	49 f0       	breq	.+18     	; 0x2958 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    2946:	8d a1       	lds	r24, 0x4d
    2948:	9e a1       	lds	r25, 0x4e
    294a:	af a1       	lds	r26, 0x4f
    294c:	b8 a5       	lds	r27, 0x68
    294e:	f8 01       	movw	r30, r16
    2950:	80 83       	st	Z, r24
    2952:	91 83       	std	Z+1, r25	; 0x01
    2954:	a2 83       	std	Z+2, r26	; 0x02
    2956:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2958:	39 a5       	lds	r19, 0x69
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    295a:	82 e0       	ldi	r24, 0x02	; 2
    295c:	89 a7       	lds	r24, 0x79

			switch( eAction )
    295e:	22 30       	cpi	r18, 0x02	; 2
    2960:	b9 f0       	breq	.+46     	; 0x2990 <xTaskGenericNotifyFromISR+0x5e>
    2962:	23 30       	cpi	r18, 0x03	; 3
    2964:	18 f4       	brcc	.+6      	; 0x296c <xTaskGenericNotifyFromISR+0x3a>
    2966:	21 30       	cpi	r18, 0x01	; 1
    2968:	59 f5       	brne	.+86     	; 0x29c0 <xTaskGenericNotifyFromISR+0x8e>
    296a:	05 c0       	rjmp	.+10     	; 0x2976 <xTaskGenericNotifyFromISR+0x44>
    296c:	23 30       	cpi	r18, 0x03	; 3
    296e:	e1 f0       	breq	.+56     	; 0x29a8 <xTaskGenericNotifyFromISR+0x76>
    2970:	24 30       	cpi	r18, 0x04	; 4
    2972:	31 f5       	brne	.+76     	; 0x29c0 <xTaskGenericNotifyFromISR+0x8e>
    2974:	1e c0       	rjmp	.+60     	; 0x29b2 <xTaskGenericNotifyFromISR+0x80>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    2976:	8d a1       	lds	r24, 0x4d
    2978:	9e a1       	lds	r25, 0x4e
    297a:	af a1       	lds	r26, 0x4f
    297c:	b8 a5       	lds	r27, 0x68
    297e:	84 2b       	or	r24, r20
    2980:	95 2b       	or	r25, r21
    2982:	a6 2b       	or	r26, r22
    2984:	b7 2b       	or	r27, r23
    2986:	8d a3       	lds	r24, 0x5d
    2988:	9e a3       	lds	r25, 0x5e
    298a:	af a3       	lds	r26, 0x5f
    298c:	b8 a7       	lds	r27, 0x78
					break;
    298e:	18 c0       	rjmp	.+48     	; 0x29c0 <xTaskGenericNotifyFromISR+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    2990:	8d a1       	lds	r24, 0x4d
    2992:	9e a1       	lds	r25, 0x4e
    2994:	af a1       	lds	r26, 0x4f
    2996:	b8 a5       	lds	r27, 0x68
    2998:	01 96       	adiw	r24, 0x01	; 1
    299a:	a1 1d       	adc	r26, r1
    299c:	b1 1d       	adc	r27, r1
    299e:	8d a3       	lds	r24, 0x5d
    29a0:	9e a3       	lds	r25, 0x5e
    29a2:	af a3       	lds	r26, 0x5f
    29a4:	b8 a7       	lds	r27, 0x78
					break;
    29a6:	0c c0       	rjmp	.+24     	; 0x29c0 <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    29a8:	4d a3       	lds	r20, 0x5d
    29aa:	5e a3       	lds	r21, 0x5e
    29ac:	6f a3       	lds	r22, 0x5f
    29ae:	78 a7       	lds	r23, 0x78
					break;
    29b0:	07 c0       	rjmp	.+14     	; 0x29c0 <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    29b2:	32 30       	cpi	r19, 0x02	; 2
    29b4:	09 f4       	brne	.+2      	; 0x29b8 <xTaskGenericNotifyFromISR+0x86>
    29b6:	41 c0       	rjmp	.+130    	; 0x2a3a <xTaskGenericNotifyFromISR+0x108>
					{
						pxTCB->ulNotifiedValue = ulValue;
    29b8:	4d a3       	lds	r20, 0x5d
    29ba:	5e a3       	lds	r21, 0x5e
    29bc:	6f a3       	lds	r22, 0x5f
    29be:	78 a7       	lds	r23, 0x78

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    29c0:	31 30       	cpi	r19, 0x01	; 1
    29c2:	e9 f5       	brne	.+122    	; 0x2a3e <xTaskGenericNotifyFromISR+0x10c>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    29c4:	80 91 ad 03 	lds	r24, 0x03AD
    29c8:	88 23       	and	r24, r24
    29ca:	e9 f4       	brne	.+58     	; 0x2a06 <xTaskGenericNotifyFromISR+0xd4>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    29cc:	8e 01       	movw	r16, r28
    29ce:	0e 5f       	subi	r16, 0xFE	; 254
    29d0:	1f 4f       	sbci	r17, 0xFF	; 255
    29d2:	c8 01       	movw	r24, r16
    29d4:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    29d8:	8e 89       	ldd	r24, Y+22	; 0x16
    29da:	90 91 b4 03 	lds	r25, 0x03B4
    29de:	98 17       	cp	r25, r24
    29e0:	10 f4       	brcc	.+4      	; 0x29e6 <xTaskGenericNotifyFromISR+0xb4>
    29e2:	80 93 b4 03 	sts	0x03B4, r24
    29e6:	90 e0       	ldi	r25, 0x00	; 0
    29e8:	9c 01       	movw	r18, r24
    29ea:	22 0f       	add	r18, r18
    29ec:	33 1f       	adc	r19, r19
    29ee:	22 0f       	add	r18, r18
    29f0:	33 1f       	adc	r19, r19
    29f2:	22 0f       	add	r18, r18
    29f4:	33 1f       	adc	r19, r19
    29f6:	82 0f       	add	r24, r18
    29f8:	93 1f       	adc	r25, r19
    29fa:	82 54       	subi	r24, 0x42	; 66
    29fc:	9c 4f       	sbci	r25, 0xFC	; 252
    29fe:	b8 01       	movw	r22, r16
    2a00:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>
    2a04:	07 c0       	rjmp	.+14     	; 0x2a14 <xTaskGenericNotifyFromISR+0xe2>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2a06:	be 01       	movw	r22, r28
    2a08:	64 5f       	subi	r22, 0xF4	; 244
    2a0a:	7f 4f       	sbci	r23, 0xFF	; 255
    2a0c:	8d ef       	ldi	r24, 0xFD	; 253
    2a0e:	93 e0       	ldi	r25, 0x03	; 3
    2a10:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2a14:	e0 91 ab 03 	lds	r30, 0x03AB
    2a18:	f0 91 ac 03 	lds	r31, 0x03AC
    2a1c:	9e 89       	ldd	r25, Y+22	; 0x16
    2a1e:	86 89       	ldd	r24, Z+22	; 0x16
    2a20:	89 17       	cp	r24, r25
    2a22:	78 f4       	brcc	.+30     	; 0x2a42 <xTaskGenericNotifyFromISR+0x110>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    2a24:	e1 14       	cp	r14, r1
    2a26:	f1 04       	cpc	r15, r1
    2a28:	21 f0       	breq	.+8      	; 0x2a32 <xTaskGenericNotifyFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    2a2a:	81 e0       	ldi	r24, 0x01	; 1
    2a2c:	f7 01       	movw	r30, r14
    2a2e:	80 83       	st	Z, r24
    2a30:	09 c0       	rjmp	.+18     	; 0x2a44 <xTaskGenericNotifyFromISR+0x112>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    2a32:	81 e0       	ldi	r24, 0x01	; 1
    2a34:	80 93 b1 03 	sts	0x03B1, r24
    2a38:	05 c0       	rjmp	.+10     	; 0x2a44 <xTaskGenericNotifyFromISR+0x112>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    2a3a:	80 e0       	ldi	r24, 0x00	; 0
    2a3c:	03 c0       	rjmp	.+6      	; 0x2a44 <xTaskGenericNotifyFromISR+0x112>

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2a3e:	81 e0       	ldi	r24, 0x01	; 1
    2a40:	01 c0       	rjmp	.+2      	; 0x2a44 <xTaskGenericNotifyFromISR+0x112>
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2a42:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    2a44:	df 91       	pop	r29
    2a46:	cf 91       	pop	r28
    2a48:	1f 91       	pop	r17
    2a4a:	0f 91       	pop	r16
    2a4c:	ff 90       	pop	r15
    2a4e:	ef 90       	pop	r14
    2a50:	08 95       	ret

00002a52 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    2a52:	ef 92       	push	r14
    2a54:	ff 92       	push	r15
    2a56:	0f 93       	push	r16
    2a58:	1f 93       	push	r17
    2a5a:	cf 93       	push	r28
    2a5c:	df 93       	push	r29
    2a5e:	ec 01       	movw	r28, r24
    2a60:	8b 01       	movw	r16, r22

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2a62:	29 a5       	lds	r18, 0x69
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    2a64:	82 e0       	ldi	r24, 0x02	; 2
    2a66:	89 a7       	lds	r24, 0x79

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    2a68:	8d a1       	lds	r24, 0x4d
    2a6a:	9e a1       	lds	r25, 0x4e
    2a6c:	af a1       	lds	r26, 0x4f
    2a6e:	b8 a5       	lds	r27, 0x68
    2a70:	01 96       	adiw	r24, 0x01	; 1
    2a72:	a1 1d       	adc	r26, r1
    2a74:	b1 1d       	adc	r27, r1
    2a76:	8d a3       	lds	r24, 0x5d
    2a78:	9e a3       	lds	r25, 0x5e
    2a7a:	af a3       	lds	r26, 0x5f
    2a7c:	b8 a7       	lds	r27, 0x78

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2a7e:	21 30       	cpi	r18, 0x01	; 1
    2a80:	e9 f5       	brne	.+122    	; 0x2afc <vTaskNotifyGiveFromISR+0xaa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2a82:	80 91 ad 03 	lds	r24, 0x03AD
    2a86:	88 23       	and	r24, r24
    2a88:	01 f5       	brne	.+64     	; 0x2aca <vTaskNotifyGiveFromISR+0x78>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2a8a:	ee 24       	eor	r14, r14
    2a8c:	ff 24       	eor	r15, r15
    2a8e:	68 94       	set
    2a90:	e1 f8       	bld	r14, 1
    2a92:	ec 0e       	add	r14, r28
    2a94:	fd 1e       	adc	r15, r29
    2a96:	c7 01       	movw	r24, r14
    2a98:	0e 94 5c 05 	call	0xab8	; 0xab8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2a9c:	8e 89       	ldd	r24, Y+22	; 0x16
    2a9e:	90 91 b4 03 	lds	r25, 0x03B4
    2aa2:	98 17       	cp	r25, r24
    2aa4:	10 f4       	brcc	.+4      	; 0x2aaa <vTaskNotifyGiveFromISR+0x58>
    2aa6:	80 93 b4 03 	sts	0x03B4, r24
    2aaa:	90 e0       	ldi	r25, 0x00	; 0
    2aac:	9c 01       	movw	r18, r24
    2aae:	22 0f       	add	r18, r18
    2ab0:	33 1f       	adc	r19, r19
    2ab2:	22 0f       	add	r18, r18
    2ab4:	33 1f       	adc	r19, r19
    2ab6:	22 0f       	add	r18, r18
    2ab8:	33 1f       	adc	r19, r19
    2aba:	82 0f       	add	r24, r18
    2abc:	93 1f       	adc	r25, r19
    2abe:	82 54       	subi	r24, 0x42	; 66
    2ac0:	9c 4f       	sbci	r25, 0xFC	; 252
    2ac2:	b7 01       	movw	r22, r14
    2ac4:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>
    2ac8:	07 c0       	rjmp	.+14     	; 0x2ad8 <vTaskNotifyGiveFromISR+0x86>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2aca:	be 01       	movw	r22, r28
    2acc:	64 5f       	subi	r22, 0xF4	; 244
    2ace:	7f 4f       	sbci	r23, 0xFF	; 255
    2ad0:	8d ef       	ldi	r24, 0xFD	; 253
    2ad2:	93 e0       	ldi	r25, 0x03	; 3
    2ad4:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2ad8:	e0 91 ab 03 	lds	r30, 0x03AB
    2adc:	f0 91 ac 03 	lds	r31, 0x03AC
    2ae0:	9e 89       	ldd	r25, Y+22	; 0x16
    2ae2:	86 89       	ldd	r24, Z+22	; 0x16
    2ae4:	89 17       	cp	r24, r25
    2ae6:	50 f4       	brcc	.+20     	; 0x2afc <vTaskNotifyGiveFromISR+0xaa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    2ae8:	01 15       	cp	r16, r1
    2aea:	11 05       	cpc	r17, r1
    2aec:	21 f0       	breq	.+8      	; 0x2af6 <vTaskNotifyGiveFromISR+0xa4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    2aee:	81 e0       	ldi	r24, 0x01	; 1
    2af0:	f8 01       	movw	r30, r16
    2af2:	80 83       	st	Z, r24
    2af4:	03 c0       	rjmp	.+6      	; 0x2afc <vTaskNotifyGiveFromISR+0xaa>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    2af6:	81 e0       	ldi	r24, 0x01	; 1
    2af8:	80 93 b1 03 	sts	0x03B1, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    2afc:	df 91       	pop	r29
    2afe:	cf 91       	pop	r28
    2b00:	1f 91       	pop	r17
    2b02:	0f 91       	pop	r16
    2b04:	ff 90       	pop	r15
    2b06:	ef 90       	pop	r14
    2b08:	08 95       	ret

00002b0a <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    2b0a:	00 97       	sbiw	r24, 0x00	; 0
    2b0c:	29 f4       	brne	.+10     	; 0x2b18 <xTaskNotifyStateClear+0xe>
    2b0e:	e0 91 ab 03 	lds	r30, 0x03AB
    2b12:	f0 91 ac 03 	lds	r31, 0x03AC
    2b16:	01 c0       	rjmp	.+2      	; 0x2b1a <xTaskNotifyStateClear+0x10>
    2b18:	fc 01       	movw	r30, r24

		taskENTER_CRITICAL();
    2b1a:	0f b6       	in	r0, 0x3f	; 63
    2b1c:	f8 94       	cli
    2b1e:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    2b20:	81 a5       	lds	r24, 0x61
    2b22:	82 30       	cpi	r24, 0x02	; 2
    2b24:	19 f4       	brne	.+6      	; 0x2b2c <xTaskNotifyStateClear+0x22>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2b26:	11 a6       	lds	r17, 0xb1
				xReturn = pdPASS;
    2b28:	81 e0       	ldi	r24, 0x01	; 1
    2b2a:	01 c0       	rjmp	.+2      	; 0x2b2e <xTaskNotifyStateClear+0x24>
			}
			else
			{
				xReturn = pdFAIL;
    2b2c:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    2b2e:	0f 90       	pop	r0
    2b30:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2b32:	08 95       	ret

00002b34 <timer_init>:
#include <avr/io.h>

void timer_init()
{
	//set timer mode This is CTC mode
	TCCR0 &= (~(1<<WGM00));
    2b34:	83 b7       	in	r24, 0x33	; 51
    2b36:	8f 7b       	andi	r24, 0xBF	; 191
    2b38:	83 bf       	out	0x33, r24	; 51
	TCCR0 |= 1<<WGM01;
    2b3a:	83 b7       	in	r24, 0x33	; 51
    2b3c:	88 60       	ori	r24, 0x08	; 8
    2b3e:	83 bf       	out	0x33, r24	; 51
	//choose prescaler this is fcpu/1024
	TCCR0 |= (1<<CS00);
    2b40:	83 b7       	in	r24, 0x33	; 51
    2b42:	81 60       	ori	r24, 0x01	; 1
    2b44:	83 bf       	out	0x33, r24	; 51
	TCCR0 &= (~(1<<CS01));
    2b46:	83 b7       	in	r24, 0x33	; 51
    2b48:	8d 7f       	andi	r24, 0xFD	; 253
    2b4a:	83 bf       	out	0x33, r24	; 51
	TCCR0 |= (1<<CS02);
    2b4c:	83 b7       	in	r24, 0x33	; 51
    2b4e:	84 60       	ori	r24, 0x04	; 4
    2b50:	83 bf       	out	0x33, r24	; 51
	// we want timer to tick every 10ms;; 10ms = ((1024"the prescaler")/(8000000"FCPU"))*OCR0
	OCR0 = 78;
    2b52:	8e e4       	ldi	r24, 0x4E	; 78
    2b54:	8c bf       	out	0x3c, r24	; 60
	//enable sie for global interupts
	//ENABLE TIMER INTERRUPTS
	TIMSK |= (1<<OCIE0);
    2b56:	89 b7       	in	r24, 0x39	; 57
    2b58:	82 60       	ori	r24, 0x02	; 2
    2b5a:	89 bf       	out	0x39, r24	; 57
	
    2b5c:	08 95       	ret

00002b5e <memcpy>:
    2b5e:	fb 01       	movw	r30, r22
    2b60:	dc 01       	movw	r26, r24
    2b62:	02 c0       	rjmp	.+4      	; 0x2b68 <memcpy+0xa>
    2b64:	01 90       	ld	r0, Z+
    2b66:	0d 92       	st	X+, r0
    2b68:	41 50       	subi	r20, 0x01	; 1
    2b6a:	50 40       	sbci	r21, 0x00	; 0
    2b6c:	d8 f7       	brcc	.-10     	; 0x2b64 <memcpy+0x6>
    2b6e:	08 95       	ret

00002b70 <_exit>:
    2b70:	f8 94       	cli

00002b72 <__stop_program>:
    2b72:	ff cf       	rjmp	.-2      	; 0x2b72 <__stop_program>
